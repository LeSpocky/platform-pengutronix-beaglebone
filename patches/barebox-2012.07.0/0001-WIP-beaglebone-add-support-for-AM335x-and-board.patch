From 0513a2da4d48ed0c573384335f7f2ff71b44422d Mon Sep 17 00:00:00 2001
From: Jan Luebbe <jluebbe@debian.org>
Date: Sat, 23 Jun 2012 21:39:36 +0200
Subject: [PATCH] WIP beaglebone: add support for AM335x and board

Signed-off-by: Jan Luebbe <jluebbe@debian.org>
---
 Makefile                                           |    5 +
 arch/arm/Makefile                                  |    1 +
 arch/arm/boards/beaglebone/Makefile                |    1 +
 arch/arm/boards/beaglebone/board.c                 |  509 ++++++++++++++
 arch/arm/boards/beaglebone/clock.h                 |   36 +
 arch/arm/boards/beaglebone/clocks_am335x.h         |   65 ++
 arch/arm/boards/beaglebone/clocks_ti814x.h         |   72 ++
 arch/arm/boards/beaglebone/clocks_ti816x.h         |  162 +++++
 arch/arm/boards/beaglebone/common_def.h            |   48 ++
 arch/arm/boards/beaglebone/config.h                |   24 +
 arch/arm/boards/beaglebone/cpu.h                   |  726 ++++++++++++++++++++
 arch/arm/boards/beaglebone/ddr_defs.h              |  362 ++++++++++
 arch/arm/boards/beaglebone/env/boot/sd             |   16 +
 arch/arm/boards/beaglebone/env/init/bootargs-base  |    8 +
 arch/arm/boards/beaglebone/env/init/general        |   18 +
 arch/arm/boards/beaglebone/hardware.h              |  117 ++++
 arch/arm/boards/beaglebone/mux.c                   |  707 +++++++++++++++++++
 arch/arm/boards/beaglebone/pll.c                   |  293 ++++++++
 arch/arm/configs/am335x_beaglebone_defconfig       |   58 ++
 .../configs/am335x_beaglebone_mlo_large_defconfig  |   50 ++
 .../configs/am335x_beaglebone_mlo_small_defconfig  |   32 +
 arch/arm/cpu/start.c                               |   14 +-
 arch/arm/mach-omap/Kconfig                         |   11 +-
 arch/arm/mach-omap/omap3_generic.c                 |    2 +
 arch/arm/mach-omap/s32k_clksource.c                |    5 +-
 arch/arm/mach-omap/xload.c                         |    5 +-
 common/startup.c                                   |    5 +
 27 files changed, 3348 insertions(+), 4 deletions(-)
 create mode 100644 arch/arm/boards/beaglebone/Makefile
 create mode 100644 arch/arm/boards/beaglebone/board.c
 create mode 100644 arch/arm/boards/beaglebone/clock.h
 create mode 100644 arch/arm/boards/beaglebone/clocks_am335x.h
 create mode 100644 arch/arm/boards/beaglebone/clocks_ti814x.h
 create mode 100644 arch/arm/boards/beaglebone/clocks_ti816x.h
 create mode 100644 arch/arm/boards/beaglebone/common_def.h
 create mode 100644 arch/arm/boards/beaglebone/config.h
 create mode 100644 arch/arm/boards/beaglebone/cpu.h
 create mode 100644 arch/arm/boards/beaglebone/ddr_defs.h
 create mode 100644 arch/arm/boards/beaglebone/env/boot/sd
 create mode 100644 arch/arm/boards/beaglebone/env/init/bootargs-base
 create mode 100644 arch/arm/boards/beaglebone/env/init/general
 create mode 100644 arch/arm/boards/beaglebone/hardware.h
 create mode 100644 arch/arm/boards/beaglebone/mux.c
 create mode 100644 arch/arm/boards/beaglebone/pll.c
 create mode 100644 arch/arm/configs/am335x_beaglebone_defconfig
 create mode 100644 arch/arm/configs/am335x_beaglebone_mlo_large_defconfig
 create mode 100644 arch/arm/configs/am335x_beaglebone_mlo_small_defconfig

diff --git a/Makefile b/Makefile
index ebcf9bf..8355da3 100644
--- a/Makefile
+++ b/Makefile
@@ -672,6 +672,11 @@ barebox.bin: barebox FORCE
 	$(call if_changed,objcopy)
 	$(call cmd,check_file_size,$(CONFIG_BAREBOX_MAX_IMAGE_SIZE))
 
+barebox.img: barebox.bin
+	$(srctree)/scripts/mkimage -A $(ARCH) -T firmware -C none \
+	-O barebox -a $(CONFIG_TEXT_BASE) -e $(CONFIG_TEXT_BASE) \
+	-n "barebox $(KERNELRELEASE)" -d $< $@
+
 ifdef CONFIG_X86
 barebox.S: barebox
 ifdef CONFIG_X86_HDBOOT
diff --git a/arch/arm/Makefile b/arch/arm/Makefile
index 1225df7..92f5ef7 100644
--- a/arch/arm/Makefile
+++ b/arch/arm/Makefile
@@ -99,6 +99,7 @@ board-$(CONFIG_MACH_NOMADIK_8815NHK)		:= nhk8815
 board-$(CONFIG_MACH_NXDB500)			:= netx
 board-$(CONFIG_MACH_OMAP343xSDP)		:= omap343xdsp
 board-$(CONFIG_MACH_BEAGLE)			:= beagle
+board-$(CONFIG_MACH_BEAGLEBONE)			:= beaglebone
 board-$(CONFIG_MACH_OMAP3EVM)			:= omap3evm
 board-$(CONFIG_MACH_PANDA)			:= panda
 board-$(CONFIG_MACH_PCM049)			:= pcm049
diff --git a/arch/arm/boards/beaglebone/Makefile b/arch/arm/boards/beaglebone/Makefile
new file mode 100644
index 0000000..529eb26
--- /dev/null
+++ b/arch/arm/boards/beaglebone/Makefile
@@ -0,0 +1 @@
+obj-y += board.o mux.o pll.o
diff --git a/arch/arm/boards/beaglebone/board.c b/arch/arm/boards/beaglebone/board.c
new file mode 100644
index 0000000..ca94060
--- /dev/null
+++ b/arch/arm/boards/beaglebone/board.c
@@ -0,0 +1,509 @@
+/*
+ * (C) Copyright 2008
+ * Texas Instruments, <www.ti.com>
+ * Raghavendra KH <r-khandenahally@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/**
+ * @file
+ * @brief Beagle Specific Board Initialization routines
+ */
+
+/**
+ * @page ti_beagle Texas Instruments Beagle Board
+ *
+ * FileName: arch/arm/boards/omap/board-beagle.c
+ *
+ * Beagle Board from Texas Instruments as described here:
+ * http://www.beagleboard.org
+ *
+ * This board is based on OMAP3530.
+ * More on OMAP3530 (including documentation can be found here):
+ * http://focus.ti.com/docs/prod/folders/print/omap3530.html
+ *
+ * This file provides initialization in two stages:
+ * @li boot time initialization - do basics required to get SDRAM working.
+ * This is run from SRAM - so no case constructs and global vars can be used.
+ * @li run time initialization - this is for the rest of the initializations
+ * such as flash, uart etc.
+ *
+ * Boot time initialization includes:
+ * @li SDRAM initialization.
+ * @li Pin Muxing relevant for Beagle.
+ *
+ * Run time initialization includes
+ * @li serial @ref serial_ns16550.c driver device definition
+ *
+ * Originally from arch/arm/boards/omap/board-sdp343x.c
+ */
+
+#include <common.h>
+#include <console.h>
+#include <init.h>
+#include <driver.h>
+#include <fs.h>
+#include <linux/stat.h>
+#include <environment.h>
+#include <sizes.h>
+#include <io.h>
+#include <ns16550.h>
+#include <asm/armlinux.h>
+#include <generated/mach-types.h>
+#include <mach/silicon.h>
+#include <mach/sdrc.h>
+#include <mach/sys_info.h>
+#include <mach/syslib.h>
+#include <mach/control.h>
+#include <mach/omap3-mux.h>
+#include <mach/gpmc.h>
+#include <mach/ehci.h>
+#include <i2c/i2c.h>
+#include <linux/err.h>
+#include <usb/ehci.h>
+#include <mach/xload.h>
+
+#include "config.h"
+#include "common_def.h"
+#include "cpu.h"
+#include "ddr_defs.h"
+
+/* from U-Boot's board/ti/am335x/evm.c */
+
+/* UART Defines */
+#define UART_SYSCFG_OFFSET  (0x54)
+#define UART_SYSSTS_OFFSET  (0x58)
+
+#define UART_RESET      (0x1 << 1)
+#define UART_CLK_RUNNING_MASK   0x1
+#define UART_SMART_IDLE_EN  (0x1 << 0x3)
+
+static void Data_Macro_Config(int dataMacroNum)
+{
+    u32 BaseAddrOffset = 0x00;;
+
+    if (dataMacroNum == 1)
+        BaseAddrOffset = 0xA4;
+
+    __raw_writel(((DDR2_RD_DQS<<30)|(DDR2_RD_DQS<<20)
+            |(DDR2_RD_DQS<<10)|(DDR2_RD_DQS<<0)),
+            (DATA0_RD_DQS_SLAVE_RATIO_0 + BaseAddrOffset));
+    __raw_writel(DDR2_RD_DQS>>2,
+            (DATA0_RD_DQS_SLAVE_RATIO_1 + BaseAddrOffset));
+    __raw_writel(((DDR2_WR_DQS<<30)|(DDR2_WR_DQS<<20)
+            |(DDR2_WR_DQS<<10)|(DDR2_WR_DQS<<0)),
+            (DATA0_WR_DQS_SLAVE_RATIO_0 + BaseAddrOffset));
+    __raw_writel(DDR2_WR_DQS>>2,
+            (DATA0_WR_DQS_SLAVE_RATIO_1 + BaseAddrOffset));
+    __raw_writel(((DDR2_PHY_WRLVL<<30)|(DDR2_PHY_WRLVL<<20)
+            |(DDR2_PHY_WRLVL<<10)|(DDR2_PHY_WRLVL<<0)),
+            (DATA0_WRLVL_INIT_RATIO_0 + BaseAddrOffset));
+    __raw_writel(DDR2_PHY_WRLVL>>2,
+            (DATA0_WRLVL_INIT_RATIO_1 + BaseAddrOffset));
+    __raw_writel(((DDR2_PHY_GATELVL<<30)|(DDR2_PHY_GATELVL<<20)
+            |(DDR2_PHY_GATELVL<<10)|(DDR2_PHY_GATELVL<<0)),
+            (DATA0_GATELVL_INIT_RATIO_0 + BaseAddrOffset));
+    __raw_writel(DDR2_PHY_GATELVL>>2,
+            (DATA0_GATELVL_INIT_RATIO_1 + BaseAddrOffset));
+    __raw_writel(((DDR2_PHY_FIFO_WE<<30)|(DDR2_PHY_FIFO_WE<<20)
+            |(DDR2_PHY_FIFO_WE<<10)|(DDR2_PHY_FIFO_WE<<0)),
+            (DATA0_FIFO_WE_SLAVE_RATIO_0 + BaseAddrOffset));
+    __raw_writel(DDR2_PHY_FIFO_WE>>2,
+            (DATA0_FIFO_WE_SLAVE_RATIO_1 + BaseAddrOffset));
+    __raw_writel(((DDR2_PHY_WR_DATA<<30)|(DDR2_PHY_WR_DATA<<20)
+            |(DDR2_PHY_WR_DATA<<10)|(DDR2_PHY_WR_DATA<<0)),
+            (DATA0_WR_DATA_SLAVE_RATIO_0 + BaseAddrOffset));
+    __raw_writel(DDR2_PHY_WR_DATA>>2,
+            (DATA0_WR_DATA_SLAVE_RATIO_1 + BaseAddrOffset));
+    __raw_writel(PHY_DLL_LOCK_DIFF,
+            (DATA0_DLL_LOCK_DIFF_0 + BaseAddrOffset));
+}
+
+static void Cmd_Macro_Config(void)
+{
+    __raw_writel(DDR2_RATIO, CMD0_CTRL_SLAVE_RATIO_0);
+    __raw_writel(CMD_FORCE, CMD0_CTRL_SLAVE_FORCE_0);
+    __raw_writel(CMD_DELAY, CMD0_CTRL_SLAVE_DELAY_0);
+    __raw_writel(DDR2_DLL_LOCK_DIFF, CMD0_DLL_LOCK_DIFF_0);
+    __raw_writel(DDR2_INVERT_CLKOUT, CMD0_INVERT_CLKOUT_0);
+
+    __raw_writel(DDR2_RATIO, CMD1_CTRL_SLAVE_RATIO_0);
+    __raw_writel(CMD_FORCE, CMD1_CTRL_SLAVE_FORCE_0);
+    __raw_writel(CMD_DELAY, CMD1_CTRL_SLAVE_DELAY_0);
+    __raw_writel(DDR2_DLL_LOCK_DIFF, CMD1_DLL_LOCK_DIFF_0);
+    __raw_writel(DDR2_INVERT_CLKOUT, CMD1_INVERT_CLKOUT_0);
+
+    __raw_writel(DDR2_RATIO, CMD2_CTRL_SLAVE_RATIO_0);
+    __raw_writel(CMD_FORCE, CMD2_CTRL_SLAVE_FORCE_0);
+    __raw_writel(CMD_DELAY, CMD2_CTRL_SLAVE_DELAY_0);
+    __raw_writel(DDR2_DLL_LOCK_DIFF, CMD2_DLL_LOCK_DIFF_0);
+    __raw_writel(DDR2_INVERT_CLKOUT, CMD2_INVERT_CLKOUT_0);
+}
+
+static void config_vtp(void)
+{
+    __raw_writel(__raw_readl(VTP0_CTRL_REG) | VTP_CTRL_ENABLE,
+            VTP0_CTRL_REG);
+    __raw_writel(__raw_readl(VTP0_CTRL_REG) & (~VTP_CTRL_START_EN),
+            VTP0_CTRL_REG);
+    __raw_writel(__raw_readl(VTP0_CTRL_REG) | VTP_CTRL_START_EN,
+            VTP0_CTRL_REG);
+
+    /* Poll for READY */
+    while ((__raw_readl(VTP0_CTRL_REG) & VTP_CTRL_READY) != VTP_CTRL_READY);
+}
+
+static void config_emif_ddr2(void)
+{
+    u32 i;
+
+    /*Program EMIF0 CFG Registers*/
+    __raw_writel(EMIF_READ_LATENCY, EMIF4_0_DDR_PHY_CTRL_1);
+    __raw_writel(EMIF_READ_LATENCY, EMIF4_0_DDR_PHY_CTRL_1_SHADOW);
+    __raw_writel(EMIF_READ_LATENCY, EMIF4_0_DDR_PHY_CTRL_2);
+    __raw_writel(EMIF_TIM1, EMIF4_0_SDRAM_TIM_1);
+    __raw_writel(EMIF_TIM1, EMIF4_0_SDRAM_TIM_1_SHADOW);
+    __raw_writel(EMIF_TIM2, EMIF4_0_SDRAM_TIM_2);
+    __raw_writel(EMIF_TIM2, EMIF4_0_SDRAM_TIM_2_SHADOW);
+    __raw_writel(EMIF_TIM3, EMIF4_0_SDRAM_TIM_3);
+    __raw_writel(EMIF_TIM3, EMIF4_0_SDRAM_TIM_3_SHADOW);
+
+    __raw_writel(EMIF_SDCFG, EMIF4_0_SDRAM_CONFIG);
+    __raw_writel(EMIF_SDCFG, EMIF4_0_SDRAM_CONFIG2);
+
+    /* __raw_writel(EMIF_SDMGT, EMIF0_0_SDRAM_MGMT_CTRL);
+    __raw_writel(EMIF_SDMGT, EMIF0_0_SDRAM_MGMT_CTRL_SHD); */
+    __raw_writel(0x00004650, EMIF4_0_SDRAM_REF_CTRL);
+    __raw_writel(0x00004650, EMIF4_0_SDRAM_REF_CTRL_SHADOW);
+
+    for (i = 0; i < 5000; i++) {
+
+    }
+
+    /* __raw_writel(EMIF_SDMGT, EMIF0_0_SDRAM_MGMT_CTRL);
+    __raw_writel(EMIF_SDMGT, EMIF0_0_SDRAM_MGMT_CTRL_SHD); */
+    __raw_writel(EMIF_SDREF, EMIF4_0_SDRAM_REF_CTRL);
+    __raw_writel(EMIF_SDREF, EMIF4_0_SDRAM_REF_CTRL_SHADOW);
+
+    __raw_writel(EMIF_SDCFG, EMIF4_0_SDRAM_CONFIG);
+    __raw_writel(EMIF_SDCFG, EMIF4_0_SDRAM_CONFIG2);
+}
+
+/*  void DDR2_EMIF_Config(void); */
+static void config_am335x_ddr(void)
+{
+    int data_macro_0 = 0;
+    int data_macro_1 = 1;
+
+    enable_ddr_clocks();
+
+    config_vtp();
+
+    Cmd_Macro_Config();
+
+    Data_Macro_Config(data_macro_0);
+    Data_Macro_Config(data_macro_1);
+
+    __raw_writel(PHY_RANK0_DELAY, DATA0_RANK0_DELAYS_0);
+    __raw_writel(PHY_RANK0_DELAY, DATA1_RANK0_DELAYS_0);
+
+    __raw_writel(DDR_IOCTRL_VALUE, DDR_CMD0_IOCTRL);
+    __raw_writel(DDR_IOCTRL_VALUE, DDR_CMD1_IOCTRL);
+    __raw_writel(DDR_IOCTRL_VALUE, DDR_CMD2_IOCTRL);
+    __raw_writel(DDR_IOCTRL_VALUE, DDR_DATA0_IOCTRL);
+    __raw_writel(DDR_IOCTRL_VALUE, DDR_DATA1_IOCTRL);
+
+    __raw_writel(__raw_readl(DDR_IO_CTRL) & 0xefffffff, DDR_IO_CTRL);
+    __raw_writel(__raw_readl(DDR_CKE_CTRL) | 0x00000001, DDR_CKE_CTRL);
+
+    config_emif_ddr2();
+}
+
+/**
+ * @brief Do the pin muxing required for Board operation.
+ * We enable ONLY the pins we require to set. OMAP provides pins which do not
+ * have alternate modes. Such pins done need to be set.
+ *
+ * See @ref MUX_VAL for description of the muxing mode.
+ *
+ * @return void
+ */
+static void mux_config(void)
+{
+	/* SDRC_D0 - SDRC_D31 default mux mode is mode0 */
+
+	/* GPMC */
+	MUX_VAL(CP(GPMC_A1), (IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_A2), (IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_A3), (IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_A4), (IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_A5), (IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_A6), (IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_A7), (IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_A8), (IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_A9), (IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_A10), (IDIS | PTD | DIS | M0));
+
+	/* D0-D7 default mux mode is mode0 */
+	MUX_VAL(CP(GPMC_D8), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_D9), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_D10), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_D11), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_D12), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_D13), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_D14), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_D15), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_CLK), (IDIS | PTD | DIS | M0));
+	/* GPMC_NADV_ALE default mux mode is mode0 */
+	/* GPMC_NOE default mux mode is mode0 */
+	/* GPMC_NWE default mux mode is mode0 */
+	/* GPMC_NBE0_CLE default mux mode is mode0 */
+	MUX_VAL(CP(GPMC_NBE0_CLE), (IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_NBE1), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_NWP), (IEN | PTD | DIS | M0));
+	/* GPMC_WAIT0 default mux mode is mode0 */
+	MUX_VAL(CP(GPMC_WAIT1), (IEN | PTU | EN | M0));
+
+	/* SERIAL INTERFACE */
+	MUX_VAL(CP(UART3_CTS_RCTX), (IEN | PTD | EN | M0));
+	MUX_VAL(CP(UART3_RTS_SD), (IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(UART3_RX_IRRX), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(UART3_TX_IRTX), (IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(HSUSB0_CLK), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(HSUSB0_STP), (IDIS | PTU | EN | M0));
+	MUX_VAL(CP(HSUSB0_DIR), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(HSUSB0_NXT), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(HSUSB0_DATA0), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(HSUSB0_DATA1), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(HSUSB0_DATA2), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(HSUSB0_DATA3), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(HSUSB0_DATA4), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(HSUSB0_DATA5), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(HSUSB0_DATA6), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(HSUSB0_DATA7), (IEN | PTD | DIS | M0));
+	/* I2C1_SCL default mux mode is mode0 */
+	/* I2C1_SDA default mux mode is mode0 */
+	/* USB EHCI (port 2) */
+	MUX_VAL(CP(MCSPI1_CS3),		(IEN  | PTU | DIS | M3));
+	MUX_VAL(CP(MCSPI2_CLK),		(IEN  | PTU | DIS | M3));
+	MUX_VAL(CP(MCSPI2_SIMO),	(IEN  | PTU | DIS | M3));
+	MUX_VAL(CP(MCSPI2_SOMI),	(IEN  | PTU | DIS | M3));
+	MUX_VAL(CP(MCSPI2_CS0),		(IEN  | PTU | DIS | M3));
+	MUX_VAL(CP(MCSPI2_CS1),		(IEN  | PTU | DIS | M3));
+	MUX_VAL(CP(ETK_D10_ES2),	(IDIS | PTU | DIS | M3));
+	MUX_VAL(CP(ETK_D11_ES2),	(IDIS | PTU | DIS | M3));
+	MUX_VAL(CP(ETK_D12_ES2),	(IEN  | PTU | DIS | M3));
+	MUX_VAL(CP(ETK_D13_ES2),	(IEN  | PTU | DIS | M3));
+	MUX_VAL(CP(ETK_D14_ES2),	(IEN  | PTU | DIS | M3));
+	MUX_VAL(CP(ETK_D15_ES2),	(IEN  | PTU | DIS | M3));
+	MUX_VAL(CP(UART2_RX),		(IEN  | PTD | DIS | M4)) /*GPIO_147*/;
+}
+
+
+/*
+ * early system init of muxing and clocks.
+ */
+void s_init(void)
+{
+    u32 regVal, uart_base;
+
+    /* Setup the PLLs and the clocks for the peripherals */
+    pll_init();
+
+    /* UART softreset */
+    uart_base = DEFAULT_UART_BASE;
+
+    enable_uart0_pin_mux();
+
+    regVal = __raw_readl(uart_base + UART_SYSCFG_OFFSET);
+    regVal |= UART_RESET;
+    __raw_writel(regVal, (uart_base + UART_SYSCFG_OFFSET) );
+    while ((__raw_readl(uart_base + UART_SYSSTS_OFFSET) &
+            UART_CLK_RUNNING_MASK) != UART_CLK_RUNNING_MASK);
+
+    /* Disable smart idle */
+    regVal = __raw_readl((uart_base + UART_SYSCFG_OFFSET));
+    regVal |= UART_SMART_IDLE_EN;
+    __raw_writel(regVal, (uart_base + UART_SYSCFG_OFFSET));
+
+    /* Initialize the Timer */
+    //init_timer();
+
+    //preloader_console_init();
+
+    config_am335x_ddr();
+}
+
+
+/**
+ * @brief The basic entry point for board initialization.
+ *
+ * This is called as part of machine init (after arch init).
+ * This is again called with stack in SRAM, so not too many
+ * constructs possible here.
+ *
+ * @return void
+ */
+static int beagle_board_init(void)
+{
+	int in_sdram = running_in_sdram();
+
+    /* Can be removed as A8 comes up with L2 enabled */
+    //l2_cache_enable();
+
+    /* WDT1 is already running when the bootloader gets control
+     * Disable it to avoid "random" resets
+     */
+    writel(0xFEED0075, 0x4030b000);
+    __raw_writel(0xAAAA, WDT_WSPR);
+    while(__raw_readl(WDT_WWPS) != 0x0);
+    __raw_writel(0x5555, WDT_WSPR);
+    while(__raw_readl(WDT_WWPS) != 0x0);
+
+	//omap3_core_init();
+    writel(in_sdram, 0x4030b004);
+    writel(0xFEED0080, 0x4030b000);
+
+	//mux_config();
+    enable_uart0_pin_mux();
+	/* Dont reconfigure SDRAM while running in SDRAM! */
+	if (!in_sdram)
+		s_init();
+
+    writel(0xFEED0090, 0x4030b000);
+    //writel(0xFEED03FF, 0x4030b000); while(1);
+	return 0;
+}
+pure_initcall(beagle_board_init);
+
+/******************** Board Run Time *******************/
+
+#ifdef CONFIG_DRIVER_SERIAL_NS16550
+
+static struct NS16550_plat serial_plat = {
+	.clock = 48000000,      /* 48MHz (APLL96/2) */
+	.shift = 2,
+};
+
+/**
+ * @brief UART serial port initialization - remember to enable COM clocks in
+ * arch
+ *
+ * @return result of device registration
+ */
+static int beagle_console_init(void)
+{
+	/* Register the serial port */
+	add_ns16550_device(-1, 0x44e09000, 1024, IORESOURCE_MEM_8BIT,
+			   &serial_plat);
+
+	return 0;
+}
+console_initcall(beagle_console_init);
+#endif /* CONFIG_DRIVER_SERIAL_NS16550 */
+
+#ifdef CONFIG_USB_EHCI_OMAP
+static struct omap_hcd omap_ehci_pdata = {
+	.port_mode[0] = EHCI_HCD_OMAP_MODE_PHY,
+	.port_mode[1] = EHCI_HCD_OMAP_MODE_PHY,
+	.port_mode[2] = EHCI_HCD_OMAP_MODE_UNKNOWN,
+	.phy_reset  = 1,
+	.reset_gpio_port[0]  = -EINVAL,
+	.reset_gpio_port[1]  = 147,
+	.reset_gpio_port[2]  = -EINVAL
+};
+
+static struct ehci_platform_data ehci_pdata = {
+	.flags = 0,
+};
+#endif /* CONFIG_USB_EHCI_OMAP */
+
+static struct i2c_board_info i2c_devices[] = {
+	{
+		I2C_BOARD_INFO("twl4030", 0x48),
+	},
+};
+
+static int beagle_mem_init(void)
+{
+	arm_add_mem_device("ram0", 0x80000000, 256 * 1024 * 1024);
+
+	return 0;
+}
+mem_initcall(beagle_mem_init);
+
+static int beagle_devices_init(void)
+{
+//	i2c_register_board_info(0, i2c_devices, ARRAY_SIZE(i2c_devices));
+//	add_generic_device("i2c-omap", DEVICE_ID_DYNAMIC, NULL, OMAP_I2C1_BASE, SZ_4K,
+//			   IORESOURCE_MEM, NULL);
+
+#ifdef CONFIG_USB_EHCI_OMAP
+//	if (ehci_omap_init(&omap_ehci_pdata) >= 0)
+//		add_usb_ehci_device(DEVICE_ID_DYNAMIC, OMAP_EHCI_BASE,
+//				    OMAP_EHCI_BASE + 0x10, &ehci_pdata);
+#endif /* CONFIG_USB_EHCI_OMAP */
+#ifdef CONFIG_OMAP_GPMC
+	/* WP is made high and WAIT1 active Low */
+	//gpmc_generic_init(0x10);
+#endif
+
+	add_generic_device("omap-hsmmc", DEVICE_ID_DYNAMIC, NULL, 0x48060100, SZ_4K,
+			   IORESOURCE_MEM, NULL);
+
+	armlinux_set_bootparams((void *)0x80000100);
+	//armlinux_set_architecture(MACH_TYPE_OMAP_GENERIC);
+	armlinux_set_architecture(3589);
+
+	return 0;
+}
+device_initcall(beagle_devices_init);
+
+#ifdef CONFIG_DEFAULT_ENVIRONMENT
+static int beaglebone_env_init(void)
+{
+	struct stat s;
+	char *diskdev = "/dev/disk0.0";
+	int ret;
+
+	ret = stat(diskdev, &s);
+	if (ret) {
+		printf("device %s not found. Using default environment\n", diskdev);
+		return 0;
+	}
+
+	mkdir ("/boot", 0666);
+	ret = mount(diskdev, "fat", "/boot");
+	if (ret) {
+		printf("failed to mount %s\n", diskdev);
+		return 0;
+	}
+
+	default_environment_path = "/boot/barebox.env";
+
+	return 0;
+}
+late_initcall(beaglebone_env_init);
+#endif
+
+void __noreturn reset_cpu(unsigned long addr)
+{
+	writel(PRM_RSTCTRL_RESET, PRM_RSTCTRL);
+
+	while (1);
+}
+EXPORT_SYMBOL(reset_cpu);
diff --git a/arch/arm/boards/beaglebone/clock.h b/arch/arm/boards/beaglebone/clock.h
new file mode 100644
index 0000000..0aeaa5f
--- /dev/null
+++ b/arch/arm/boards/beaglebone/clock.h
@@ -0,0 +1,36 @@
+/*
+ * (C) Copyright 2006-2008
+ * Texas Instruments, <www.ti.com>
+ * Richard Woodruff <r-woodruff2@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR /PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _CLOCKS_H_
+#define _CLOCKS_H_
+
+#ifdef CONFIG_TI816X
+#include "clocks_ti816x.h"
+#endif
+
+#ifdef CONFIG_TI814X
+#include "clocks_ti814x.h"
+#endif
+
+#ifdef CONFIG_AM335X
+#include "clocks_am335x.h"
+#endif
+#endif
+
diff --git a/arch/arm/boards/beaglebone/clocks_am335x.h b/arch/arm/boards/beaglebone/clocks_am335x.h
new file mode 100644
index 0000000..b5fbc29
--- /dev/null
+++ b/arch/arm/boards/beaglebone/clocks_am335x.h
@@ -0,0 +1,65 @@
+/*
+ * clocks_am335x.h
+ *
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR /PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _CLOCKS_AM335X_H_
+#define _CLOCKS_AM335X_H_
+
+/* Put the pll config values over here */
+
+#define OSC	24
+
+/* MAIN PLL Fdll = 1 GHZ, */
+#define MPUPLL_M_500	500	/* 125 * n */
+#define MPUPLL_M_550	550	/* 125 * n */
+#define MPUPLL_M_600	600	/* 125 * n */
+#define MPUPLL_M_720	720	/* 125 * n */
+
+#define MPUPLL_N	23	/* (n -1 ) */
+#define MPUPLL_M2	1
+
+/* Core PLL Fdll = 1 GHZ, */
+#define COREPLL_M	1000	/* 125 * n */
+#define COREPLL_N	23	/* (n -1 ) */
+
+#define COREPLL_M4	10	/* CORE_CLKOUTM4 = 200 MHZ */
+#define COREPLL_M5	8	/* CORE_CLKOUTM5 = 250 MHZ */
+#define COREPLL_M6	4	/* CORE_CLKOUTM6 = 500 MHZ */
+
+/*
+ * USB PHY clock is 960 MHZ. Since, this comes directly from Fdll, Fdll
+ * frequency needs to be set to 960 MHZ. Hence,
+ * For clkout = 192 MHZ, Fdll = 960 MHZ, divider values are given below
+ */
+#define PERPLL_M	960
+#define PERPLL_N	23
+#define PERPLL_M2	5
+
+/* DDR Freq is 166 MHZ for now*/
+/* Set Fdll = 400 MHZ , Fdll = M * 2 * CLKINP/ N + 1; clkout = Fdll /(2 * M2) */
+#if	(CONFIG_AM335X_EVM_IS_13x13 == 1)
+#define DDRPLL_M	166	/* M/N + 1 = 25/3 */
+#else
+#define DDRPLL_M	266
+#endif
+
+#define DDRPLL_N	23
+#define DDRPLL_M2	1
+
+#endif	/* endif _CLOCKS_AM335X_H_ */
diff --git a/arch/arm/boards/beaglebone/clocks_ti814x.h b/arch/arm/boards/beaglebone/clocks_ti814x.h
new file mode 100644
index 0000000..1b41c6f
--- /dev/null
+++ b/arch/arm/boards/beaglebone/clocks_ti814x.h
@@ -0,0 +1,72 @@
+/*
+ * (C) Copyright 2006-2008
+ * Texas Instruments, <www.ti.com>
+ * Richard Woodruff <r-woodruff2@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR /PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _CLOCKS_TI814X_H_
+#define _CLOCKS_TI814X_H_
+
+/* CLK_SRC */
+#define OSC_SRC0	0
+#define OSC_SRC1	1
+
+#define L3_OSC_SRC	OSC_SRC0
+#define AUDIO_OSC_SRC	OSC_SRC0
+
+/* Put the pll config values over here */
+#define AUDIO_N		19
+#define AUDIO_M		500
+#define AUDIO_M2	2
+#define AUDIO_CLKCTRL	0x801
+
+#define MODENA_N	0x10001
+#define MODENA_M	0x3C
+#define MODENA_M2	1
+#define MODENA_CLKCTRL	0x1
+
+#define L3_N		19
+#define L3_M		880
+#define L3_M2		4
+#define L3_CLKCTRL	0x801
+
+#define DDR_N		19
+#define DDR_M		666
+#define DDR_M2		2
+#define DDR_CLKCTRL	0x801
+
+#define DSP_N		19
+#define DSP_M		500
+#define DSP_M2		1
+#define DSP_CLKCTRL	0x801
+
+#define IVA_N		19
+#define IVA_M		640
+#define IVA_M2		2
+#define IVA_CLKCTRL	0x801
+
+#define ISS_N		19
+#define ISS_M		800
+#define ISS_M2		2
+#define ISS_CLKCTRL	0x801
+
+#define USB_N		19
+#define USB_M		960
+#define USB_M2		1
+#define USB_CLKCTRL	0x200a0801
+#endif	/* endif _CLOCKS_TI814X_H_ */
+
diff --git a/arch/arm/boards/beaglebone/clocks_ti816x.h b/arch/arm/boards/beaglebone/clocks_ti816x.h
new file mode 100644
index 0000000..8590c2f
--- /dev/null
+++ b/arch/arm/boards/beaglebone/clocks_ti816x.h
@@ -0,0 +1,162 @@
+/*
+ * (C) Copyright 2006-2008
+ * Texas Instruments, <www.ti.com>
+ * Richard Woodruff <r-woodruff2@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR /PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _CLOCKS_TI816X_H_
+#define _CLOCKS_TI816X_H_
+
+/*
+ * In TI816x the 27MHz crystal generates various root clks (main pll, audio pll, video pll and ddr pll)
+ * From these root clks the SYSCLKs are generated by making use of dividers and multipliers
+ */
+
+#define FAPLL_K			8
+#define SYSCLK_2_DIV		1
+#define OSC_FREQ		27
+#define DDR_PLL_400	/* Values supported 400,531,675,796 */
+
+/* Main PLL */
+#define MAIN_N			64
+#define MAIN_P			0x1
+#define MAIN_INTFREQ1		0x8
+#define MAIN_FRACFREQ1		0x800000
+#define MAIN_MDIV1		0x2
+#define MAIN_INTFREQ2		0xE
+#define MAIN_FRACFREQ2		0x0
+#define MAIN_MDIV2		0x1
+#define MAIN_INTFREQ3		0x8
+#define MAIN_FRACFREQ3		0xAAAAB0
+#define MAIN_MDIV3		0x3
+#define MAIN_INTFREQ4		0x9
+#define MAIN_FRACFREQ4		0x55554F
+#define MAIN_MDIV4		0x3
+#define MAIN_INTFREQ5		0x9
+#define MAIN_FRACFREQ5		0x374BC6
+#define MAIN_MDIV5		0xC
+#define MAIN_MDIV6		0x48
+#define MAIN_MDIV7		0x4
+
+/* DDR PLL */
+/* For 400 MHz */
+#if defined(DDR_PLL_400)
+#define DDR_N			59
+#define DDR_P			0x1
+#define DDR_MDIV1		0x4
+#define DDR_INTFREQ2		0x8
+#define DDR_FRACFREQ2		0xD99999
+#define DDR_MDIV2		0x1E
+#define DDR_INTFREQ3		0x8
+#define DDR_FRACFREQ3		0x0
+#define DDR_MDIV3		0x4
+#define DDR_INTFREQ4		0xE /* Expansion DDR clk */
+#define DDR_FRACFREQ4		0x0
+#define DDR_MDIV4		0x4
+#define DDR_INTFREQ5		0xE /* Expansion DDR clk */
+#define DDR_FRACFREQ5		0x0
+#define DDR_MDIV5		0x4
+#endif
+
+/* For 531 MHz */
+#if defined(DDR_PLL_531)
+#define DDR_N			59
+#define DDR_P			0x1
+#define DDR_MDIV1		0x3
+#define DDR_INTFREQ2		0x8
+#define DDR_FRACFREQ2		0xD99999
+#define DDR_MDIV2		0x1E
+#define DDR_INTFREQ3		0x8
+#define DDR_FRACFREQ3		0x0
+#define DDR_MDIV3		0x4
+#define DDR_INTFREQ4		0xE /* Expansion DDR clk */
+#define DDR_FRACFREQ4		0x0
+#define DDR_MDIV4		0x4
+#define DDR_INTFREQ5		0xE /* Expansion DDR clk */
+#define DDR_FRACFREQ5		0x0
+#define DDR_MDIV5		0x4
+#endif
+
+/* For 675 MHz */
+#if defined(DDR_PLL_675)
+#define DDR_N			50
+#define DDR_P			0x1
+#define DDR_MDIV1		0x2
+#define DDR_INTFREQ2		0x9
+#define DDR_FRACFREQ2		0x0
+#define DDR_MDIV2		0x19
+#define DDR_INTFREQ3		0x13
+#define DDR_FRACFREQ3		0x800000
+#define DDR_MDIV3		0x2
+#define DDR_INTFREQ4		0xE /* Expansion DDR clk */
+#define DDR_FRACFREQ4		0x0
+#define DDR_MDIV4		0x4
+#define DDR_INTFREQ5		0xE /* Expansion DDR clk */
+#define DDR_FRACFREQ5		0x0
+#define DDR_MDIV5		0x4
+#endif
+
+/* For 796 MHz */
+#if defined(DDR_PLL_796)
+#define DDR_N			59
+#define DDR_P			0x1
+#define DDR_MDIV1		0x2
+#define DDR_INTFREQ2		0x8
+#define DDR_FRACFREQ2		0xD99999
+#define DDR_MDIV2		0x1E
+#define DDR_INTFREQ3		0x8
+#define DDR_FRACFREQ3		0x0
+#define DDR_MDIV3		0x4
+#define DDR_INTFREQ4		0xE /* Expansion DDR clk */
+#define DDR_FRACFREQ4		0x0
+#define DDR_MDIV4		0x4
+#define DDR_INTFREQ5		0xE /* Expansion DDR clk */
+#define DDR_FRACFREQ5		0x0
+#define DDR_MDIV5		0x4
+#endif
+
+/* Video PLL */
+#define VIDEO_N			110
+#define VIDEO_P			0x2
+#define VIDEO_INTFREQ1		0xB
+#define VIDEO_FRACFREQ1		0x0
+#define VIDEO_MDIV1		0x5
+#define VIDEO_INTFREQ2		0xA
+#define VIDEO_FRACFREQ2		0x0
+#define VIDEO_MDIV2		0x2
+#define VIDEO_INTFREQ3		0xA
+#define VIDEO_FRACFREQ3		0x0
+#define VIDEO_MDIV3		0x2
+
+/* Audio PLL */
+#define AUDIO_N			64
+#define AUDIO_P			0x19
+#define AUDIO_INTFREQ2		0xE
+#define AUDIO_FRACFREQ2		0x0
+#define AUDIO_MDIV2		0x4
+#define AUDIO_INTFREQ3		0x9
+#define AUDIO_FRACFREQ3		0x0
+#define AUDIO_MDIV3		0x5
+#define AUDIO_INTFREQ4		0x9
+#define AUDIO_FRACFREQ4		0xCBC148
+#define AUDIO_MDIV4		0x14
+#define AUDIO_INTFREQ5		0xD
+#define AUDIO_FRACFREQ5		0x800000
+#define AUDIO_MDIV5		0x14
+
+#endif	/* endif _CLOCKS_TI816X_H_ */
+
diff --git a/arch/arm/boards/beaglebone/common_def.h b/arch/arm/boards/beaglebone/common_def.h
new file mode 100644
index 0000000..21a50dd
--- /dev/null
+++ b/arch/arm/boards/beaglebone/common_def.h
@@ -0,0 +1,48 @@
+/*
+ * common_def.h
+ *
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+#ifndef __COMMON_DEF_H__
+#define __COMMON_DEF_H__
+
+/* AM335X type */
+#define BONE_BOARD	0
+#define GP_BOARD	1
+#define IA_BOARD	2
+#define IPP_BOARD	3
+#define BASE_BOARD	4
+
+/* Profiles */
+#define PROFILE_NONE	0x0
+#define PROFILE_0	(1 << 0)
+#define PROFILE_1	(1 << 1)
+#define PROFILE_2	(1 << 2)
+#define PROFILE_3	(1 << 3)
+#define PROFILE_4	(1 << 4)
+#define PROFILE_5	(1 << 5)
+#define PROFILE_6	(1 << 6)
+#define PROFILE_7	(1 << 7)
+#define PROFILE_ALL	0xFF
+
+extern void pll_init(void);
+extern void mpu_pll_config(int mpupll_M);
+extern void enable_ddr_clocks(void);
+
+extern void enable_i2c0_pin_mux(void);
+extern void enable_uart0_pin_mux(void);
+extern void configure_evm_pin_mux(unsigned char daughter_board_id,
+					char daughter_board_version[],
+					unsigned short daughter_board_profile,
+					unsigned int daughter_board_flag);
+
+#endif/*__COMMON_DEF_H__ */
diff --git a/arch/arm/boards/beaglebone/config.h b/arch/arm/boards/beaglebone/config.h
new file mode 100644
index 0000000..80be07a
--- /dev/null
+++ b/arch/arm/boards/beaglebone/config.h
@@ -0,0 +1,24 @@
+/**
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_AM335X
+#define CONFIG_TI81XX
+
+#endif	/* __CONFIG_H */
diff --git a/arch/arm/boards/beaglebone/cpu.h b/arch/arm/boards/beaglebone/cpu.h
new file mode 100644
index 0000000..da22b1d
--- /dev/null
+++ b/arch/arm/boards/beaglebone/cpu.h
@@ -0,0 +1,726 @@
+/*
+ * (C) Copyright 2006
+ * Texas Instruments, <www.ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+#ifndef _TI81XX_CPU_H
+#define _TI81XX_CPU_H
+
+#if !(defined(__KERNEL_STRICT_NAMES) || defined(__ASSEMBLY__))
+#include <asm/types.h>
+#endif /* !(__KERNEL_STRICT_NAMES || __ASSEMBLY__) */
+
+#include "hardware.h"
+
+//#define BIT(x)				(1 << x)
+#define CL_BIT(x)			(0 << x)
+
+/* Timer registers */
+#define TIMER_TCLR			0x38		/* Timer control register */
+#define TIMER_TCRR			0x3C		/* Timer counter register */
+#define TIMER_TLDR			0x40		/* Timer load value register*/
+
+/* Timer 32 bit registers */
+#ifndef __KERNEL_STRICT_NAMES
+#ifndef __ASSEMBLY__
+struct gptimer {
+	u32 tidr;	/* 0x00 r */
+	u8 res1[0xc];
+	u32 tiocp_cfg;	/* 0x10 rw */
+	u8 res2[0xc];
+	u32 tier;	/* 0x20 rw */
+	u32 tistatr;/* 0x24 r */
+	u32 tistat;	/* 0x28 r */
+	u32 tisr;	/* 0x2c rw */
+	u32 tcicr;	/* 0x30 rw */
+	u32 twer;	/* 0x34 rw */
+	u32 tclr;	/* 0x38 rw - control reg */
+	u32 tcrr;	/* 0x3c rw - counter reg */
+	u32 tldr;	/* 0x40 rw - load reg */
+	u32 ttgr;	/* 0x44 rw */
+	u32 twpc;	/* 0x48 r*/
+	u32 tmar;	/* 0x4c rw*/
+	u32 tcar1;	/* 0x50 r */
+	u32 tscir;	/* 0x54 r */
+	u32 tcar2;	/* 0x58 r */
+};
+#endif /* __ASSEMBLY__ */
+#endif /* __KERNEL_STRICT_NAMES */
+
+/* Timer register bits */
+#define TCLR_ST				BIT(0)		/* Start=1 Stop=0 */
+#define TCLR_AR				BIT(1)		/* Auto reload */
+#define TCLR_PRE			BIT(5)		/* Pre-scaler enable */
+#define TCLR_PTV_SHIFT			(2)		/* Pre-scaler shift value */
+#define TCLR_PRE_DISABLE		CL_BIT(5)	/* Pre-scalar disable */
+
+/* Control */
+#define CONTROL_STATUS			(CTRL_BASE + 0x40)
+
+/* device type */
+#define DEVICE_MASK			(BIT(8) | BIT(9) | BIT(10))
+#define TST_DEVICE			0x0
+#define EMU_DEVICE			0x1
+#define HS_DEVICE			0x2
+#define GP_DEVICE			0x3
+
+/* rom boot device/mode id */
+#define BOOT_DEVICE_OFFSET		8
+#define BOOT_DEVICE_MASK		0xff
+
+/* cpu-id for TI81XX family */
+#define TI8168				0xb81e
+#define AM335X				0xB944
+
+#define DEVICE_ID			(CTRL_BASE + 0x0600)
+/* This gives the status of the boot mode pins on the evm */
+#define SYSBOOT_MASK			(BIT(0) | BIT(1) | BIT(2) |BIT(3) |BIT(4))
+
+/* Reset control */
+#ifdef CONFIG_AM335X
+#define PRM_RSTCTRL			(PRCM_BASE + 0x0F00)
+#else
+#define PRM_RSTCTRL			(PRCM_BASE + 0x00A0)
+#endif
+#define PRM_RSTCTRL_RESET		0x01
+
+/* TI816X specific bits for PRM_DEVICE module */
+#define GLOBAL_RST_COLD			BIT(1)
+
+/* PLL related registers */
+#ifdef CONFIG_TI816X
+#define MAINPLL_CTRL			(CTRL_BASE + 0x0400)
+#define MAINPLL_PWD			(CTRL_BASE + 0x0404)
+#define MAINPLL_FREQ1			(CTRL_BASE + 0x0408)
+#define MAINPLL_DIV1			(CTRL_BASE + 0x040C)
+#define MAINPLL_FREQ2			(CTRL_BASE + 0x0410)
+#define MAINPLL_DIV2			(CTRL_BASE + 0x0414)
+#define MAINPLL_FREQ3			(CTRL_BASE + 0x0418)
+#define MAINPLL_DIV3			(CTRL_BASE + 0x041C)
+#define MAINPLL_FREQ4			(CTRL_BASE + 0x0420)
+#define MAINPLL_DIV4			(CTRL_BASE + 0x0424)
+#define MAINPLL_FREQ5			(CTRL_BASE + 0x0428)
+#define MAINPLL_DIV5			(CTRL_BASE + 0x042C)
+#define MAINPLL_DIV6			(CTRL_BASE + 0x0434)
+#define MAINPLL_DIV7			(CTRL_BASE + 0x043C)
+
+#define DDRPLL_CTRL			(CTRL_BASE + 0x0440)
+#define DDRPLL_PWD			(CTRL_BASE + 0x0444)
+#define DDRPLL_DIV1			(CTRL_BASE + 0x044C)
+#define DDRPLL_FREQ2			(CTRL_BASE + 0x0450)
+#define DDRPLL_DIV2			(CTRL_BASE + 0x0454)
+#define DDRPLL_FREQ3			(CTRL_BASE + 0x0458)
+#define DDRPLL_DIV3			(CTRL_BASE + 0x045C)
+#define DDRPLL_FREQ4			(CTRL_BASE + 0x0460)
+#define DDRPLL_DIV4			(CTRL_BASE + 0x0464)
+#define DDRPLL_FREQ5			(CTRL_BASE + 0x0468)
+#define DDRPLL_DIV5			(CTRL_BASE + 0x046C)
+
+#define DDR_RCD				(CTRL_BASE + 0x070C)
+
+#define VIDEOPLL_CTRL			(CTRL_BASE + 0x0470)
+#define VIDEOPLL_PWD			(CTRL_BASE + 0x0474)
+#define VIDEOPLL_FREQ1			(CTRL_BASE + 0x0478)
+#define VIDEOPLL_DIV1			(CTRL_BASE + 0x047C)
+#define VIDEOPLL_FREQ2			(CTRL_BASE + 0x0480)
+#define VIDEOPLL_DIV2			(CTRL_BASE + 0x0484)
+#define VIDEOPLL_FREQ3			(CTRL_BASE + 0x0488)
+#define VIDEOPLL_DIV3			(CTRL_BASE + 0x048C)
+
+#define AUDIOPLL_CTRL			(CTRL_BASE + 0x04A0)
+#define AUDIOPLL_PWD			(CTRL_BASE + 0x04A4)
+#define AUDIOPLL_FREQ2			(CTRL_BASE + 0x04B0)
+#define AUDIOPLL_DIV2			(CTRL_BASE + 0x04B4)
+#define AUDIOPLL_FREQ3			(CTRL_BASE + 0x04B8)
+#define AUDIOPLL_DIV3			(CTRL_BASE + 0x04BC)
+#define AUDIOPLL_FREQ4			(CTRL_BASE + 0x04C0)
+#define AUDIOPLL_DIV4			(CTRL_BASE + 0x04C4)
+#define AUDIOPLL_FREQ5			(CTRL_BASE + 0x04C8)
+#define AUDIOPLL_DIV5			(CTRL_BASE + 0x04CC)
+
+#endif
+
+#ifdef CONFIG_TI814X
+
+#define GMII_SEL			(CTRL_BASE + 0x650)
+
+#define PCIE_PLLCFG0			(CTRL_BASE + 0x6D8)
+#define PCIE_PLLCFG1			(CTRL_BASE + 0x6DC)
+#define PCIE_PLLCFG2			(CTRL_BASE + 0x6E0)
+#define PCIE_PLLCFG3			(CTRL_BASE + 0x6E4)
+#define PCIE_PLLCFG4			(CTRL_BASE + 0x6E8)
+#define PCIE_PLLSTATUS			(CTRL_BASE + 0x6EC)
+#define PCIE_RXSTATUS			(CTRL_BASE + 0x6F0)
+#define PCIE_TXSTATUS			(CTRL_BASE + 0x6F4)
+#define SERDES_REFCLK_CTRL		(CTRL_BASE + 0xE24)
+
+#define SATA_PLLCFG0			(CTRL_BASE + 0x720)
+#define SATA_PLLCFG1			(CTRL_BASE + 0x724)
+#define SATA_PLLCFG2			(CTRL_BASE + 0x728)
+#define SATA_PLLCFG3			(CTRL_BASE + 0x72C)
+#define SATA_PLLCFG4			(CTRL_BASE + 0x730)
+#define SATA_PLLSTATUS			(CTRL_BASE + 0x734)
+#define SATA_RXSTATUS			(CTRL_BASE + 0x738)
+#define SATA_TXSTATUS			(CTRL_BASE + 0x73C)
+
+/* pin muxing registers */
+#define PIN_CTRL_BASE			(CTRL_BASE + 0x800)
+#define N_PINS				(271) /* PIN1=800, PIN 271=800+270*4=C38) */
+
+/* Clocks are derived from ADPLLJ */
+#define ADPLLJ_CLKCTRL			0x4
+#define ADPLLJ_TENABLE			0x8
+#define ADPLLJ_TENABLEDIV		0xC
+#define ADPLLJ_M2NDIV			0x10
+#define ADPLLJ_MN2DIV			0x14
+#define ADPLLJ_STATUS			0x24
+
+/* ADPLLJ register values */
+#define ADPLLJ_CLKCTRL_HS2		0x00000801 /* HS2 mode, TINT2 = 1 */
+#define ADPLLJ_CLKCTRL_HS1		0x00001001 /* HS1 mode, TINT2 = 1 */
+#define ADPLLJ_CLKCTRL_CLKDCO		0x200A0000 /* Enable CLKDCOEN, CLKLDOEN, CLKDCOPWDNZ */
+
+#define MODENA_PLL_BASE			(PLL_SUBSYS_BASE + 0x048)
+#define DSP_PLL_BASE			(PLL_SUBSYS_BASE + 0x080)
+#define SGX_PLL_BASE			(PLL_SUBSYS_BASE + 0x0B0)
+#define IVA_PLL_BASE			(PLL_SUBSYS_BASE + 0x0E0)
+#define L3_PLL_BASE			(PLL_SUBSYS_BASE + 0x110)
+#define ISS_PLL_BASE			(PLL_SUBSYS_BASE + 0x140)
+#define DSS_PLL_BASE			(PLL_SUBSYS_BASE + 0x170)
+#define VIDEO0_PLL_BASE			(PLL_SUBSYS_BASE + 0x1A0)
+#define VIDEO1_PLL_BASE			(PLL_SUBSYS_BASE + 0x1D0)
+#define HDMI_PLL_BASE			(PLL_SUBSYS_BASE + 0x200)
+#define AUDIO_PLL_BASE			(PLL_SUBSYS_BASE + 0x230)
+#define USB_PLL_BASE			(PLL_SUBSYS_BASE + 0x260)
+#define DDR_PLL_BASE			(PLL_SUBSYS_BASE + 0x290)
+
+#define OSC_SRC_CTRL			(PLL_SUBSYS_BASE + 0x2C0)
+#define ARM_CLKSRC			(PLL_SUBSYS_BASE + 0x2C4)
+#define VIDEO_PLL_CLKSRC		(PLL_SUBSYS_BASE + 0x2C8)
+#define MLB_ATL_CLKSRC			(PLL_SUBSYS_BASE + 0x2CC)
+#define McASP235_AUX_CLKSRC		(PLL_SUBSYS_BASE + 0x2D0)
+#define McASP_AHCLK_CLKSRC		(PLL_SUBSYS_BASE + 0x2D4)
+#define McBSP_UART_CLKSRC		(PLL_SUBSYS_BASE + 0x2D8)
+#define HDMI_I2S_CLKSRC			(PLL_SUBSYS_BASE + 0x2DC)
+#define DMTIMER_CLKSRC			(PLL_SUBSYS_BASE + 0x2E0)
+#define CLKOUT_MUX			(PLL_SUBSYS_BASE + 0x2E4)
+#define RMII_REFCLK_SRC			(PLL_SUBSYS_BASE + 0x2E8)
+#define SECSS_CLKSRC			(PLL_SUBSYS_BASE + 0x2EC)
+#define SYSCLK18_SRC			(PLL_SUBSYS_BASE + 0x2F0)
+#define WDT0_CLKSRC			(PLL_SUBSYS_BASE + 0x2F4)
+
+#endif
+
+#ifdef CONFIG_AM335X
+/* Module Offsets */
+#define CM_PER				(PRCM_BASE + 0x0)
+#define CM_WKUP				(PRCM_BASE + 0x400)
+#define CM_DPLL				(PRCM_BASE + 0x500)
+#define CM_DEVICE			(PRCM_BASE + 0x0700)
+#define CM_CEFUSE			(PRCM_BASE + 0x0A00)
+#define PRM_DEVICE			(PRCM_BASE + 0x0F00)
+
+/* Register Offsets */
+/* Core PLL ADPLLS */
+#define CM_CLKSEL_DPLL_CORE		(CM_WKUP + 0x68)
+#define CM_CLKMODE_DPLL_CORE		(CM_WKUP + 0x90)
+
+/* Core HSDIV */
+#define CM_DIV_M4_DPLL_CORE		(CM_WKUP + 0x80)
+#define CM_DIV_M5_DPLL_CORE		(CM_WKUP + 0x84)
+#define CM_DIV_M6_DPLL_CORE		(CM_WKUP + 0xD8)
+#define CM_IDLEST_DPLL_CORE		(CM_WKUP + 0x5c)
+
+/* Peripheral PLL */
+#define CM_CLKSEL_DPLL_PER		(CM_WKUP + 0x9c)
+#define CM_CLKMODE_DPLL_PER		(CM_WKUP + 0x8c)
+#define CM_DIV_M2_DPLL_PER		(CM_WKUP + 0xAC)
+#define CM_IDLEST_DPLL_PER		(CM_WKUP + 0x70)
+
+/* Display PLL */
+#define CM_CLKSEL_DPLL_DISP		(CM_WKUP + 0x54)
+#define CM_CLKMODE_DPLL_DISP		(CM_WKUP + 0x98)
+#define CM_DIV_M2_DPLL_DISP		(CM_WKUP + 0xA4)
+
+/* DDR PLL */
+#define CM_CLKSEL_DPLL_DDR		(CM_WKUP + 0x40)
+#define CM_CLKMODE_DPLL_DDR		(CM_WKUP + 0x94)
+#define CM_DIV_M2_DPLL_DDR		(CM_WKUP + 0xA0)
+#define CM_IDLEST_DPLL_DDR		(CM_WKUP + 0x34)
+
+/* MPU PLL */
+#define CM_CLKSEL_DPLL_MPU		(CM_WKUP + 0x2c)
+#define CM_CLKMODE_DPLL_MPU		(CM_WKUP + 0x88)
+#define CM_DIV_M2_DPLL_MPU		(CM_WKUP + 0xA8)
+#define CM_IDLEST_DPLL_MPU		(CM_WKUP + 0x20)
+
+/* TIMER Clock Source Select */
+#define CLKSEL_TIMER2_CLK		(CM_DPLL + 0x8)
+
+/* Interconnect clocks */
+#define CM_PER_L4LS_CLKCTRL		(CM_PER + 0x60)	/* EMIF */
+#define CM_PER_L4FW_CLKCTRL		(CM_PER + 0x64)	/* EMIF FW */
+#define CM_PER_L3_CLKCTRL		(CM_PER + 0xE0)	/* OCMC RAM */
+#define CM_PER_L3_INSTR_CLKCTRL		(CM_PER + 0xDC)
+#define CM_PER_L4HS_CLKCTRL		(CM_PER + 0x120)
+#define CM_WKUP_L4WKUP_CLKCTRL		(CM_WKUP + 0x0c)/* UART0 */
+
+/* Domain Wake UP */
+#define CM_WKUP_CLKSTCTRL		(CM_WKUP + 0)	/* UART0 */
+#define CM_PER_L4LS_CLKSTCTRL		(CM_PER + 0x0)	/* TIMER2 */
+#define CM_PER_L3_CLKSTCTRL		(CM_PER + 0x0c)	/* EMIF */
+#define CM_PER_L4FW_CLKSTCTRL		(CM_PER + 0x08)	/* EMIF FW */
+#define CM_PER_L3S_CLKSTCTRL		(CM_PER + 0x4)
+#define CM_PER_L4HS_CLKSTCTRL		(CM_PER + 0x011c)
+#define CM_CEFUSE_CLKSTCTRL		(CM_CEFUSE + 0x0)
+
+/* Module Enable Registers */
+#define CM_PER_TIMER2_CLKCTRL		(CM_PER + 0x80)	/* Timer2 */
+#define CM_WKUP_UART0_CLKCTRL		(CM_WKUP + 0xB4)/* UART0 */
+#define CM_WKUP_CONTROL_CLKCTRL		(CM_WKUP + 0x4)	/* Control Module */
+#define CM_PER_EMIF_CLKCTRL		(CM_PER + 0x28)	/* EMIF */
+#define CM_PER_EMIF_FW_CLKCTRL		(CM_PER + 0xD0)	/* EMIF FW */
+#define CM_PER_GPMC_CLKCTRL		(CM_PER + 0x30)	/* GPMC */
+#define CM_PER_ELM_CLKCTRL		(CM_PER + 0x40)	/* ELM */
+#define CM_PER_SPI0_CLKCTRL		(CM_PER + 0x4c) /* SPI0 */
+#define CM_PER_SPI1_CLKCTRL		(CM_PER + 0x50) /* SPI1 */
+#define CM_WKUP_I2C0_CLKCTRL		(CM_WKUP + 0xB8) /* I2C0 */
+#define CM_PER_CPGMAC0_CLKCTRL		(CM_PER + 0x14)	/* Ethernet */
+#define CM_PER_CPSW_CLKSTCTRL		(CM_PER + 0x144)/* Ethernet */
+#define CM_PER_OCMCRAM_CLKCTRL		(CM_PER	+ 0x2C) /* OCMC RAM */
+#define CM_PER_GPIO2_CLKCTRL		(CM_PER + 0xB0) /* GPIO2 */
+#define CM_PER_UART3_CLKCTRL		(CM_PER + 0x74) /* UART3 */
+#define CM_PER_I2C1_CLKCTRL		(CM_PER + 0x48) /* I2C1 */
+#define CM_PER_I2C2_CLKCTRL		(CM_PER + 0x44) /* I2C2 */
+#define CM_WKUP_GPIO0_CLKCTRL		(CM_WKUP + 0x8) /* GPIO0 */
+
+#define CM_PER_MMC0_CLKCTRL     	(CM_PER + 0x3C)
+#define CM_PER_MMC1_CLKCTRL     	(CM_PER + 0xF4)
+#define CM_PER_MMC2_CLKCTRL     	(CM_PER + 0xF8)
+
+#endif /* CONFIG_AM335X */
+
+/* PRCM */
+#define CM_DPLL_OFFSET			(PRCM_BASE + 0x0300)
+
+#ifdef CONFIG_TI816X
+#define CM_TIMER1_CLKSEL		(CM_DPLL_OFFSET + 0x90)
+
+/* Timers */
+#define CM_ALWON_TIMER_0_CLKCTRL	(PRCM_BASE + 0x156C)
+#define CM_ALWON_TIMER_1_CLKCTRL	(PRCM_BASE + 0x1570)
+#define CM_ALWON_TIMER_2_CLKCTRL	(PRCM_BASE + 0x1574)
+#define CM_ALWON_TIMER_3_CLKCTRL	(PRCM_BASE + 0x1578)
+#define CM_ALWON_TIMER_4_CLKCTRL	(PRCM_BASE + 0x157C)
+#define CM_ALWON_TIMER_5_CLKCTRL	(PRCM_BASE + 0x1580)
+#define CM_ALWON_TIMER_6_CLKCTRL	(PRCM_BASE + 0x1584)
+#define CM_ALWON_TIMER_7_CLKCTRL	(PRCM_BASE + 0x1588)
+#endif
+
+#define CM_ALWON_WDTIMER_CLKCTRL	(PRCM_BASE + 0x158C)
+#define CM_ALWON_SPI_CLKCTRL		(PRCM_BASE + 0x1590)
+#define CM_ALWON_CONTROL_CLKCTRL	(PRCM_BASE + 0x15C4)
+
+#define CM_ALWON_L3_SLOW_CLKSTCTRL	(PRCM_BASE + 0x1400)
+
+#ifdef CONFIG_TI816X
+#define CM_ALWON_CUST_EFUSE_CLKCTRL	(PRCM_BASE + 0x1628)
+#endif
+
+#define CM_ALWON_GPIO_0_CLKCTRL		(PRCM_BASE + 0x155c)
+#define CM_ALWON_GPIO_0_OPTFCLKEN_DBCLK (PRCM_BASE + 0x155c)
+
+/* Ethernet */
+#define CM_ETHERNET_CLKSTCTRL		(PRCM_BASE + 0x1404)
+#define CM_ALWON_ETHERNET_0_CLKCTRL	(PRCM_BASE + 0x15D4)
+#define CM_ALWON_ETHERNET_1_CLKCTRL	(PRCM_BASE + 0x15D8)
+
+/* UARTs */
+#define CM_ALWON_UART_0_CLKCTRL		(PRCM_BASE + 0x1550)
+#define CM_ALWON_UART_1_CLKCTRL		(PRCM_BASE + 0x1554)
+#define CM_ALWON_UART_2_CLKCTRL		(PRCM_BASE + 0x1558)
+
+/* I2C */
+/* Note: In ti814x I2C0 and I2C2 have common clk control */
+#define CM_ALWON_I2C_0_CLKCTRL		(PRCM_BASE + 0x1564)
+
+/* HSMMC */
+#ifdef CONFIG_TI816X
+#define CM_ALWON_HSMMC_CLKCTRL		(PRCM_BASE + 0x15B0)
+#endif
+
+#ifdef CONFIG_TI814X
+#define CM_ALWON_HSMMC_CLKCTRL		(PRCM_BASE + 0x1620)
+#endif
+
+/* UART2 registers */
+#ifdef CONFIG_TI816X
+#define DEFAULT_UART_BASE		UART2_BASE
+#endif
+
+#ifdef CONFIG_TI814X
+#define DEFAULT_UART_BASE		UART0_BASE
+#endif
+
+#ifdef CONFIG_AM335X
+#define DEFAULT_UART_BASE		UART0_BASE
+#endif
+/* UART registers */
+/*TODO:Move to a new file */
+#define UART_SYSCFG			(DEFAULT_UART_BASE + 0x54)
+#define UART_SYSSTS			(DEFAULT_UART_BASE + 0x58)
+#define UART_LCR			(DEFAULT_UART_BASE + 0x0C)
+#define UART_EFR			(DEFAULT_UART_BASE + 0x08)
+#define UART_MCR			(DEFAULT_UART_BASE + 0x10)
+#define UART_SCR			(DEFAULT_UART_BASE + 0x40)
+#define UART_TCR			(DEFAULT_UART_BASE + 0x18)
+#define UART_FCR			(DEFAULT_UART_BASE + 0x08)
+#define UART_DLL			(DEFAULT_UART_BASE + 0x00)
+#define UART_DLH			(DEFAULT_UART_BASE + 0x04)
+#define UART_MDR			(DEFAULT_UART_BASE + 0x20)
+
+/*DMM & EMIF4 MMR Declaration*/
+/*TODO: Move to a new file */
+#define DMM_LISA_MAP__0			(DMM_BASE + 0x40)
+#define DMM_LISA_MAP__1			(DMM_BASE + 0x44)
+#define DMM_LISA_MAP__2			(DMM_BASE + 0x48)
+#define DMM_LISA_MAP__3			(DMM_BASE + 0x4C)
+#define DMM_PAT_BASE_ADDR		(DMM_BASE + 0x460)
+
+#ifdef CONFIG_AM335X
+#define EMIF_MOD_ID_REV			(EMIF4_0_CFG_BASE + 0x0)
+#define EMIF4_0_SDRAM_STATUS            (EMIF4_0_CFG_BASE + 0x04)
+#define EMIF4_0_SDRAM_CONFIG            (EMIF4_0_CFG_BASE + 0x08)
+#define EMIF4_0_SDRAM_CONFIG2           (EMIF4_0_CFG_BASE + 0x0C)
+#define EMIF4_0_SDRAM_REF_CTRL          (EMIF4_0_CFG_BASE + 0x10)
+#define EMIF4_0_SDRAM_REF_CTRL_SHADOW   (EMIF4_0_CFG_BASE + 0x14)
+#define EMIF4_0_SDRAM_TIM_1             (EMIF4_0_CFG_BASE + 0x18)
+#define EMIF4_0_SDRAM_TIM_1_SHADOW      (EMIF4_0_CFG_BASE + 0x1C)
+#define EMIF4_0_SDRAM_TIM_2             (EMIF4_0_CFG_BASE + 0x20)
+#define EMIF4_0_SDRAM_TIM_2_SHADOW      (EMIF4_0_CFG_BASE + 0x24)
+#define EMIF4_0_SDRAM_TIM_3             (EMIF4_0_CFG_BASE + 0x28)
+#define EMIF4_0_SDRAM_TIM_3_SHADOW      (EMIF4_0_CFG_BASE + 0x2C)
+#define EMIF0_0_SDRAM_MGMT_CTRL         (EMIF4_0_CFG_BASE + 0x38)
+#define EMIF0_0_SDRAM_MGMT_CTRL_SHD     (EMIF4_0_CFG_BASE + 0x3C)
+#define EMIF4_0_DDR_PHY_CTRL_1          (EMIF4_0_CFG_BASE + 0xE4)
+#define EMIF4_0_DDR_PHY_CTRL_1_SHADOW   (EMIF4_0_CFG_BASE + 0xE8)
+#define EMIF4_0_DDR_PHY_CTRL_2          (EMIF4_0_CFG_BASE + 0xEC)
+#define EMIF4_0_IODFT_TLGC              (EMIF4_0_CFG_BASE + 0x60)
+#else
+#define EMIF4_0_SDRAM_CONFIG		(EMIF4_0_CFG_BASE + 0x08)
+#define EMIF4_0_SDRAM_CONFIG2		(EMIF4_0_CFG_BASE + 0x0C)
+#define EMIF4_0_SDRAM_REF_CTRL		(EMIF4_0_CFG_BASE + 0x10)
+#define EMIF4_0_SDRAM_REF_CTRL_SHADOW	(EMIF4_0_CFG_BASE + 0x14)
+#define EMIF4_0_SDRAM_TIM_1		(EMIF4_0_CFG_BASE + 0x18)
+#define EMIF4_0_SDRAM_TIM_1_SHADOW	(EMIF4_0_CFG_BASE + 0x1C)
+#define EMIF4_0_SDRAM_TIM_2		(EMIF4_0_CFG_BASE + 0x20)
+#define EMIF4_0_SDRAM_TIM_2_SHADOW	(EMIF4_0_CFG_BASE + 0x24)
+#define EMIF4_0_SDRAM_TIM_3		(EMIF4_0_CFG_BASE + 0x28)
+#define EMIF4_0_SDRAM_TIM_3_SHADOW	(EMIF4_0_CFG_BASE + 0x2C)
+#define EMIF4_0_DDR_PHY_CTRL_1		(EMIF4_0_CFG_BASE + 0xE4)
+#define EMIF4_0_DDR_PHY_CTRL_1_SHADOW	(EMIF4_0_CFG_BASE + 0xE8)
+#define EMIF4_0_IODFT_TLGC		(EMIF4_0_CFG_BASE + 0x60)
+#endif
+
+#define EMIF4_1_SDRAM_CONFIG		(EMIF4_1_CFG_BASE + 0x08)
+#define EMIF4_1_SDRAM_CONFIG2		(EMIF4_1_CFG_BASE + 0x0C)
+#define EMIF4_1_SDRAM_REF_CTRL		(EMIF4_1_CFG_BASE + 0x10)
+#define EMIF4_1_SDRAM_REF_CTRL_SHADOW	(EMIF4_1_CFG_BASE + 0x14)
+#define EMIF4_1_SDRAM_TIM_1		(EMIF4_1_CFG_BASE + 0x18)
+#define EMIF4_1_SDRAM_TIM_1_SHADOW	(EMIF4_1_CFG_BASE + 0x1C)
+#define EMIF4_1_SDRAM_TIM_2		(EMIF4_1_CFG_BASE + 0x20)
+#define EMIF4_1_SDRAM_TIM_2_SHADOW	(EMIF4_1_CFG_BASE + 0x24)
+#define EMIF4_1_SDRAM_TIM_3		(EMIF4_1_CFG_BASE + 0x28)
+#define EMIF4_1_SDRAM_TIM_3_SHADOW	(EMIF4_1_CFG_BASE + 0x2C)
+#define EMIF4_1_DDR_PHY_CTRL_1		(EMIF4_1_CFG_BASE + 0xE4)
+#define EMIF4_1_DDR_PHY_CTRL_1_SHADOW	(EMIF4_1_CFG_BASE + 0xE8)
+#define EMIF4_1_IODFT_TLGC		(EMIF4_1_CFG_BASE + 0x60)
+
+#ifdef CONFIG_AM335X
+#define VTP0_CTRL_REG			0x44E10E0C
+#else
+#define VTP0_CTRL_REG			0x48140E0C
+#endif
+#define VTP1_CTRL_REG			0x48140E10
+
+/*EMIF4 PRCM Defintion*/
+#define CM_DEFAULT_L3_FAST_CLKSTCTRL	(PRCM_BASE + 0x0508)
+#define CM_DEFAULT_EMIF_0_CLKCTRL	(PRCM_BASE + 0x0520)
+#define CM_DEFAULT_EMIF_1_CLKCTRL	(PRCM_BASE + 0x0524)
+#define CM_DEFAULT_DMM_CLKCTRL		(PRCM_BASE + 0x0528)
+#define CM_DEFAULT_FW_CLKCTRL		(PRCM_BASE + 0x052C)
+
+/* Smartreflex Registers */
+#define TI816X_SMRT_SCALE_ADDR		(CTRL_BASE + 0x06A0)
+#define TI816X_SMRT_OPP_SVT_ADDR	(CTRL_BASE + 0x06A8)
+#define TI816X_SMRT_OPP_HVT_ADDR	(CTRL_BASE + 0x06AC)
+
+
+/* ALWON PRCM */
+#ifdef CONFIG_AM335X
+#define CM_ALWON_OCMC_0_CLKSTCTRL	CM_PER_L3_CLKSTCTRL
+#define CM_ALWON_OCMC_0_CLKCTRL		CM_PER_OCMCRAM_CLKCTRL
+#else
+#define CM_ALWON_OCMC_0_CLKSTCTRL	(PRCM_BASE + 0x1414)
+#define CM_ALWON_OCMC_0_CLKCTRL		(PRCM_BASE + 0x15B4)
+#endif
+
+#ifdef CONFIG_TI816X
+#define CM_ALWON_OCMC_1_CLKSTCTRL	(PRCM_BASE + 0x1418)
+#define CM_ALWON_OCMC_1_CLKCTRL		(PRCM_BASE + 0x15B8)
+#endif
+
+#ifdef CONFIG_AM335X
+#define CM_ALWON_GPMC_CLKCTRL		CM_PER_GPMC_CLKCTRL
+#else
+#define CM_ALWON_GPMC_CLKCTRL		(PRCM_BASE + 0x15D0)
+#endif
+
+/* OCMC */
+#ifdef CONFIG_TI816X
+#define SRAM0_SIZE			(0x40000)
+#define SRAM_GPMC_STACK_SIZE		(0x40)
+#endif
+
+#if defined(CONFIG_AM335X) || defined(CONFIG_TI814X)
+#define SRAM0_SIZE			(0x1B400) /* 109 KB */
+#define SRAM_GPMC_STACK_SIZE		(0x40)
+#endif
+
+#define LOW_LEVEL_SRAM_STACK		(SRAM0_START + SRAM0_SIZE - 4)
+
+/* GPMC related */
+#define GPMC_CONFIG_CS0			(0x60)
+#define GPMC_CONFIG_CS0_BASE		(GPMC_BASE + GPMC_CONFIG_CS0)
+#define GPMC_CONFIG1			(0x00)
+#define GPMC_CONFIG2			(0x04)
+#define GPMC_CONFIG3			(0x08)
+#define GPMC_CONFIG4			(0x0C)
+#define GPMC_CONFIG5			(0x10)
+#define GPMC_CONFIG6			(0x14)
+#define GPMC_CONFIG7			(0x18)
+
+/* PAD configuration register offsets and values for gpmc address
+ * lines a12 - a26
+ */
+#ifdef CONFIG_TI816X
+
+#define TIM7_OUT			(CTRL_BASE + 0xb34)	/* a12 */
+#define UART1_CTSN			(CTRL_BASE + 0xadc)	/* a13 */
+#define UART1_RTSN			(CTRL_BASE + 0xad8)	/* a14 */
+#define UART2_RTSN			(CTRL_BASE + 0xae8)	/* a15 */
+#define SC1_RST				(CTRL_BASE + 0xb10)	/* a15 */
+#define UART2_CTSN			(CTRL_BASE + 0xaec)	/* a16 */
+#define UART0_RIN			(CTRL_BASE + 0xacc)	/* a17 */
+#define UART0_DCDN			(CTRL_BASE + 0xac8)	/* a18 */
+#define UART0_DSRN			(CTRL_BASE + 0xac4)	/* a19 */
+#define UART0_DTRN			(CTRL_BASE + 0xac0)	/* a20 */
+#define SPI_SCS3			(CTRL_BASE + 0xaa4)	/* a21 */
+#define SPI_SC2				(CTRL_BASE + 0xaa0)	/* a22 */
+#define GPO_IO6				(CTRL_BASE + 0xca0)	/* a23 */
+#define TIM6_OUT			(CTRL_BASE + 0xb30)	/* a24 */
+#define SC0_DATA			(CTRL_BASE + 0xafc)	/* a25 */
+#define GPMC_A27			(CTRL_BASE + 0xba0)	/* a27 */
+
+/* MMC Pad register offsets */
+#define MMC_POW				(CTRL_BASE + 0xa70)
+#define MMC_CLK				(CTRL_BASE + 0xa74)
+#define MMC_CMD				(CTRL_BASE + 0xa78)
+#define MMC_DAT0			(CTRL_BASE + 0xa7c)
+#define MMC_DAT1_SDIRQ			(CTRL_BASE + 0xa80)
+#define MMC_DAT2_SDRW			(CTRL_BASE + 0xa84)
+#define MMC_DAT3			(CTRL_BASE + 0xa88)
+
+#define GPMC_A12			TIM7_OUT
+#define GPMC_A13			UART1_CTSN
+#define GPMC_A14			UART1_RTSN
+#define GPMC_A15			UART2_RTSN
+#define GPMC_A16			UART2_CTSN
+#define GPMC_A17			UART0_RIN
+#define GPMC_A18			UART0_DCDN
+#define GPMC_A19			UART0_DSRN
+#define GPMC_A20			UART0_DTRN
+#define GPMC_A21			SPI_SCS3
+#define GPMC_A22			SPI_SC2
+#define GPMC_A23			GPO_IO6
+#define GPMC_A24			TIM6_OUT
+#define GPMC_A25			SC0_DATA
+#endif
+
+#ifdef CONFIG_AM335X
+#define GPMC_A12			(CTRL_BASE + 0x8c0) /* LCD_DATA8 */
+#define GPMC_A13			(CTRL_BASE + 0x8c4) /* LCD_DATA9 */
+#define GPMC_A14			(CTRL_BASE + 0x8c8) /* LCD_DATA10 */
+#define GPMC_A15			(CTRL_BASE + 0x8cc) /* LCD_DATA11 */
+#define GPMC_A16			(CTRL_BASE + 0x8d0) /* LCD_DATA12 */
+#define GPMC_A17			(CTRL_BASE + 0x8d4) /* LCD_DATA13 */
+#define GPMC_A18			(CTRL_BASE + 0x8d8) /* LCD_DATA14 */
+#define GPMC_A19			(CTRL_BASE + 0x8dc) /* LCD_DATA15 */
+#define GPMC_A20			(CTRL_BASE + 0x850) /* GPMC_A4 */
+#define GPMC_A21			(CTRL_BASE + 0x854) /* GPMC_A5 */
+#define GPMC_A22			(CTRL_BASE + 0x858) /* GPMC_A6 */
+
+/* DDR offsets */
+#define	DDR_PHY_BASE_ADDR		0x44E12000
+#define	DDR_IO_CTRL			0x44E10E04
+#define	DDR_CKE_CTRL			0x44E1131C
+#define	CONTROL_BASE_ADDR		0x44E10000
+
+#define	DDR_CMD0_IOCTRL			(CONTROL_BASE_ADDR + 0x1404)
+#define	DDR_CMD1_IOCTRL			(CONTROL_BASE_ADDR + 0x1408)
+#define	DDR_CMD2_IOCTRL			(CONTROL_BASE_ADDR + 0x140C)
+#define	DDR_DATA0_IOCTRL		(CONTROL_BASE_ADDR + 0x1440)
+#define	DDR_DATA1_IOCTRL		(CONTROL_BASE_ADDR + 0x1444)
+
+#define	CMD0_CTRL_SLAVE_RATIO_0		(DDR_PHY_BASE_ADDR + 0x01C)
+#define	CMD0_CTRL_SLAVE_FORCE_0		(DDR_PHY_BASE_ADDR + 0x020)
+#define	CMD0_CTRL_SLAVE_DELAY_0		(DDR_PHY_BASE_ADDR + 0x024)
+#define	CMD0_DLL_LOCK_DIFF_0		(DDR_PHY_BASE_ADDR + 0x028)
+#define	CMD0_INVERT_CLKOUT_0		(DDR_PHY_BASE_ADDR + 0x02C)
+
+#define	CMD1_CTRL_SLAVE_RATIO_0		(DDR_PHY_BASE_ADDR + 0x050)
+#define	CMD1_CTRL_SLAVE_FORCE_0		(DDR_PHY_BASE_ADDR + 0x054)
+#define	CMD1_CTRL_SLAVE_DELAY_0		(DDR_PHY_BASE_ADDR + 0x058)
+#define	CMD1_DLL_LOCK_DIFF_0		(DDR_PHY_BASE_ADDR + 0x05C)
+#define	CMD1_INVERT_CLKOUT_0		(DDR_PHY_BASE_ADDR + 0x060)
+
+#define	CMD2_CTRL_SLAVE_RATIO_0		(DDR_PHY_BASE_ADDR + 0x084)
+#define	CMD2_CTRL_SLAVE_FORCE_0		(DDR_PHY_BASE_ADDR + 0x088)
+#define	CMD2_CTRL_SLAVE_DELAY_0		(DDR_PHY_BASE_ADDR + 0x08C)
+#define	CMD2_DLL_LOCK_DIFF_0		(DDR_PHY_BASE_ADDR + 0x090)
+#define	CMD2_INVERT_CLKOUT_0		(DDR_PHY_BASE_ADDR + 0x094)
+
+#define DATA0_RD_DQS_SLAVE_RATIO_0	(DDR_PHY_BASE_ADDR + 0x0C8)
+#define DATA0_RD_DQS_SLAVE_RATIO_1	(DDR_PHY_BASE_ADDR + 0x0CC)
+#define	DATA0_WR_DQS_SLAVE_RATIO_0	(DDR_PHY_BASE_ADDR + 0x0DC)
+
+#define	DATA0_WR_DQS_SLAVE_RATIO_1	(DDR_PHY_BASE_ADDR + 0x0E0)
+#define	DATA0_WRLVL_INIT_RATIO_0	(DDR_PHY_BASE_ADDR + 0x0F0)
+
+#define	DATA0_WRLVL_INIT_RATIO_1	(DDR_PHY_BASE_ADDR + 0x0F4)
+#define	DATA0_GATELVL_INIT_RATIO_0	(DDR_PHY_BASE_ADDR + 0x0FC)
+
+#define	DATA0_GATELVL_INIT_RATIO_1	(DDR_PHY_BASE_ADDR + 0x100)
+#define	DATA0_FIFO_WE_SLAVE_RATIO_0	(DDR_PHY_BASE_ADDR + 0x108)
+
+#define	DATA0_FIFO_WE_SLAVE_RATIO_1	(DDR_PHY_BASE_ADDR + 0x10C)
+#define	DATA0_WR_DATA_SLAVE_RATIO_0	(DDR_PHY_BASE_ADDR + 0x120)
+
+#define	DATA0_WR_DATA_SLAVE_RATIO_1	(DDR_PHY_BASE_ADDR + 0x124)
+#define DATA0_DLL_LOCK_DIFF_0		(DDR_PHY_BASE_ADDR + 0x138)
+
+#define DATA0_RANK0_DELAYS_0		(DDR_PHY_BASE_ADDR + 0x134)
+#define	DATA1_RANK0_DELAYS_0		(DDR_PHY_BASE_ADDR + 0x1D8)
+
+#endif
+
+#ifndef __KERNEL_STRICT_NAMES
+#ifndef __ASSEMBLY__
+struct gpmc_cs {
+	u32 config1;		/* 0x00 */
+	u32 config2;		/* 0x04 */
+	u32 config3;		/* 0x08 */
+	u32 config4;		/* 0x0C */
+	u32 config5;		/* 0x10 */
+	u32 config6;		/* 0x14 */
+	u32 config7;		/* 0x18 */
+	u32 nand_cmd;		/* 0x1C */
+	u32 nand_adr;		/* 0x20 */
+	u32 nand_dat;		/* 0x24 */
+	u8 res[8];		/* blow up to 0x30 byte */
+};
+
+struct bch_res_0_3 {
+	u32 bch_result_x[4];
+};
+
+
+
+struct gpmc {
+	u8 res1[0x10];
+	u32 sysconfig;		/* 0x10 */
+	u8 res2[0x4];
+	u32 irqstatus;		/* 0x18 */
+	u32 irqenable;		/* 0x1C */
+	u8 res3[0x20];
+	u32 timeout_control;	/* 0x40 */
+	u8 res4[0xC];
+	u32 config;		/* 0x50 */
+	u32 status;		/* 0x54 */
+	u8 res5[0x8];		/* 0x58 */
+	struct gpmc_cs cs[8];	/* 0x60, 0x90, .. */
+	u8 res6[0x14];		/* 0x1E0 */
+	u32 ecc_config;		/* 0x1F4 */
+	u32 ecc_control;	/* 0x1F8 */
+	u32 ecc_size_config;	/* 0x1FC */
+	u32 ecc1_result;	/* 0x200 */
+	u32 ecc2_result;	/* 0x204 */
+	u32 ecc3_result;	/* 0x208 */
+	u32 ecc4_result;	/* 0x20C */
+	u32 ecc5_result;	/* 0x210 */
+	u32 ecc6_result;	/* 0x214 */
+	u32 ecc7_result;	/* 0x218 */
+	u32 ecc8_result;	/* 0x21C */
+	u32 ecc9_result;	/* 0x220 */
+	u8 res7[12];		/* 0x224 */
+	u32 testmomde_ctrl;	/* 0x230 */
+	u8 res8[12];		/* 0x234 */
+	struct bch_res_0_3 bch_result_0_3[2];	/* 0x240 */
+};
+
+/* Used for board specific gpmc initialization */
+extern struct gpmc *gpmc_cfg;
+
+#endif /* __ASSEMBLY__ */
+#endif /* __KERNEL_STRICT_NAMES */
+
+/* Ethernet MAC ID from EFuse */
+#define MAC_ID0_LO	(CTRL_BASE + 0x630)
+#define MAC_ID0_HI	(CTRL_BASE + 0x634)
+#define MAC_ID1_LO	(CTRL_BASE + 0x638)
+#define MAC_ID1_HI	(CTRL_BASE + 0x63c)
+#define MAC_MII_SEL	(CTRL_BASE + 0x650)
+
+/* WDT related */
+/* TODO: Move to a new file */
+#define WDT_WDSC	(WDT_BASE + 0x010)
+#define WDT_WDST	(WDT_BASE + 0x014)
+#define WDT_WISR	(WDT_BASE + 0x018)
+#define WDT_WIER	(WDT_BASE + 0x01C)
+#define WDT_WWER	(WDT_BASE + 0x020)
+#define WDT_WCLR	(WDT_BASE + 0x024)
+#define WDT_WCRR	(WDT_BASE + 0x028)
+#define WDT_WLDR	(WDT_BASE + 0x02C)
+#define WDT_WTGR	(WDT_BASE + 0x030)
+#define WDT_WWPS	(WDT_BASE + 0x034)
+#define WDT_WDLY	(WDT_BASE + 0x044)
+#define WDT_WSPR	(WDT_BASE + 0x048)
+#define WDT_WIRQEOI	(WDT_BASE + 0x050)
+#define WDT_WIRQSTATRAW	(WDT_BASE + 0x054)
+#define WDT_WIRQSTAT	(WDT_BASE + 0x058)
+#define WDT_WIRQENSET	(WDT_BASE + 0x05C)
+#define WDT_WIRQENCLR	(WDT_BASE + 0x060)
+
+#define WDT_UNFREEZE	(CTRL_BASE + 0x100)
+
+#endif /* _TI816X_CPU_H */
+
diff --git a/arch/arm/boards/beaglebone/ddr_defs.h b/arch/arm/boards/beaglebone/ddr_defs.h
new file mode 100644
index 0000000..4ae1e10
--- /dev/null
+++ b/arch/arm/boards/beaglebone/ddr_defs.h
@@ -0,0 +1,362 @@
+/*
+ * Copyright (C) 2010 Texas Instruments
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+ *
+ */
+
+#ifndef _DDR_DEFS_H
+#define _DDR_DEFS_H
+
+#include "hardware.h"
+
+#ifdef CONFIG_TI816X_EVM_DDR3
+
+#define CONFIG_TI816X_DDR3_400 /* Values supported 400,531,675,796 */
+#define CONFIG_TI816X_DDR3_SW_LEVELING	/* Enable software leveling as part of DDR3 init*/
+
+
+/*
+ * DDR3 force values.  These are board dependent
+ */
+
+/* EVM 400 MHz clock Settings
+ * EVM has only a single RANK (chip select) */
+#define N_RANK			1
+
+/*
+ * Invert clock adds an additional half cycle delay on the command
+ * interface.  The additional half cycle, is usually meant to enable
+ * leveling in the situation that DQS is later than CK on the board.  It
+ * also helps provide some additional margin for leveling.
+ *
+ * For the EVM this is helping us with additional room for the write
+ * leveling.  Since the dqs delays are very small.
+ */
+#define INVERT_CLOCK		1
+
+/*
+ * CMD_SLAVE_RATIO determines where is the command placed with respect
+ * to the clock edge.  This is a ratio, implying 0x100 is one cycle.
+ * Ideally the command is centered so - this should be half cycle
+ * delay (0x80).  But if invert clock is in use, an additional half
+ * cycle must be added
+ */
+#define CMD_SLAVE_FROM_INV_CLOCK(i) (((i)==0) ? 0x80 : 0x100)
+#define CMD_SLAVE_RATIO		CMD_SLAVE_FROM_INV_CLOCK(INVERT_CLOCK)
+
+#ifdef TI816X_DDR3_PG_1_0
+/*
+ * EMIF PHY allows for controlling write DQS delay w.r.t. clock.  The
+ * value may be forced or use values determined from the leveling
+ * process.  Since we are doing the leveling - these are actually
+ * don't care and are not used.  The force is in delay units
+ */
+#define WR_DQS_FORCE_3	0x00000010
+#define WR_DQS_FORCE_2	0x00000010
+#define WR_DQS_FORCE_1	0x00000010
+#define WR_DQS_FORCE_0	0x00000010
+
+/*
+ * EMIF PHY allows for controlling how much the read DQS must be
+ * delayed to sample the data correctly.  Ideally this is about half a
+ * cycle.  The force here is delay units.  The value here is in use -
+ * as the current leveling process may not obtain this reliably.  The
+ * value has been determined via various tests on the EVM and changing
+ * this setting is no recomended.
+ */
+#define RD_DQS_FORCE_0		0x00000028
+#define RD_DQS_FORCE_1		0x00000028
+#define RD_DQS_FORCE_2		0x00000028
+#define RD_DQS_FORCE_3		0x00000028
+
+/*
+ * read gate represents the round trip delay from command to read data
+ * on the board + some package delay.  This is the period for which
+ * the bust may be tristated between a write and a read command and
+ * hence must not be sampled (gated off).  This is actually determined
+ * via the read leveling process and hence this value is a don't care
+ * for the EVM
+ */
+#define RD_GATE_FORCE_3	0x44
+#define RD_GATE_FORCE_2	0x44
+#define RD_GATE_FORCE_1	0x44
+#define RD_GATE_FORCE_0	0x44
+
+#endif
+
+/*
+ * This represents the initial value for the leveling process.  The
+ * value is a ratio - so 0x100 represents one cycle.  The real delay
+ * is determined through the leveling process.
+ *
+ * During the leveling process, 0x20 is subtracted from the value, so
+ * we have added that to the value we want to set.  We also set the
+ * values such that byte3 completes leveling after byte2 and byte1
+ * after byte0.
+ */
+#define WR_DQS_RATIO_0		0x20
+#define WR_DQS_RATIO_1		0x20
+#define WR_DQS_RATIO_2		0x20
+#define WR_DQS_RATIO_3		0x20
+
+#ifdef TI816X_DDR3_PG_1_0
+/*
+ * read dqs ratio is only used in DDR2
+ */
+#define RD_DQS_RATIO_0		0x40
+#define RD_DQS_RATIO_1		0x40
+#define RD_DQS_RATIO_2		0x40
+#define RD_DQS_RATIO_3		0x40
+#endif
+
+/*
+ * This represents the initial value for the leveling process.  The
+ * value is a ratio - so 0x100 represents one cycle.  The real delay
+ * is determined through the leveling process.
+ *
+ * During the leveling process, 0x20 is subtracted from the value, so
+ * we have added that to the value we want to set.  We also set the
+ * values such that byte3 completes leveling after byte2 and byte1
+ * after byte0.
+ */
+#define RD_GATE_RATIO_0	0x20
+#define RD_GATE_RATIO_1	0x20
+#define RD_GATE_RATIO_2	0x20
+#define RD_GATE_RATIO_3	0x20
+
+#ifdef TI816X_DDR3_PG_1_0
+/*
+ * currently there is an issue with the automatic training process for
+ * DDR3 by setting the initial leveling ratios appropriately we are
+ * able to work arround write leveling and read gate leveling.  How
+ * ever the automatic process may not work well for the read eye
+ * training (determining rd dqs delay).  To work arround this - we
+ * leverage the pre-knowledge of a working RD DQS delay and make the
+ * leveling process complete by forcing good and bad values
+ * This is enabled via HACK_EYE_TRAINING
+ */
+#define HACK_EYE_TRAINING	0
+
+/*
+ * only the rd dqs delay needs to be forced.  Others are determined via the leveling process
+ */
+#define USE_WR_DQS_FORCE	0
+#define USE_RD_DQS_FORCE	HACK_EYE_TRAINING
+#define USE_RD_GATE_FORCE	0
+
+#endif
+/*
+ * data rate in MHz.  The DDR clock will be 1/2 of this value
+ */
+#define DDR_DATA_RATE		800
+
+#define USE_EMIF0		1
+#define USE_EMIF1		1
+
+/*
+ * EMIF Paramters.  Refer the EMIF register documentation and the
+ * memory datasheet for details
+ */
+/* For 400 MHz */
+#if defined(CONFIG_TI816X_DDR3_400)
+#define EMIF_TIM1    0x0CCCE524
+#define EMIF_TIM2    0x30308023
+#define EMIF_TIM3    0x009F82CF
+#define EMIF_SDREF   0x10000C30
+#define EMIF_SDCFG   0x62A41032
+#define EMIF_PHYCFG  0x0000010B
+
+#if defined(CONFIG_TI816X_DDR3_SW_LEVELING)
+/* These values are obtained from the CCS app */
+#define RD_DQS_GATE	0x12A
+#define RD_DQS		0x3B
+#define WR_DQS		0xA6
+#endif
+
+#endif	/* CONFIG_TI816X_DDR3_400 */
+
+/* For 531 MHz */
+#if defined(CONFIG_TI816X_DDR3_531)
+#define EMIF_TIM1    0x0EF136AC
+#define EMIF_TIM2    0x30408063
+#define EMIF_TIM3    0x009F83AF
+#define EMIF_SDREF   0x1000102E
+#define EMIF_SDCFG   0x62A51832
+#define EMIF_PHYCFG  0x0000010C
+
+#if defined(CONFIG_TI816X_DDR3_SW_LEVELING)
+/* These values are obtained from the CCS app */
+#define RD_DQS_GATE	0x13D
+#define RD_DQS		0x39
+#define WR_DQS		0xB4
+#endif
+
+#endif /* CONFIG_TI816X_DDR_531 */
+
+/* For 675 MHz */
+#if defined(CONFIG_TI816X_DDR3_675)
+#define EMIF_TIM1    0x13358875
+#define EMIF_TIM2    0x5051806C
+#define EMIF_TIM3    0x009F84AF
+#define EMIF_SDREF   0x10001491
+#define EMIF_SDCFG   0x62A63032
+#define EMIF_PHYCFG  0x0000010F
+
+#if defined(CONFIG_TI816X_DDR3_SW_LEVELING)
+/* These values are obtained from the CCS app */
+#define RD_DQS_GATE	0x196
+#define RD_DQS		0x39
+#define WR_DQS		0x91
+
+#endif
+
+#endif /* CONFIG_TI816X_DDR3_675 */
+
+/* For 796 MHz */
+#if defined(CONFIG_TI816X_DDR3_796)
+#define EMIF_TIM1   0x1779C9FE
+#define EMIF_TIM2   0x50608074
+#define EMIF_TIM3   0x009F857F
+#define EMIF_SDREF  0x10001841
+#define EMIF_SDCFG  0x62A73832
+#define EMIF_PHYCFG 0x00000110
+
+#if defined(CONFIG_TI816X_DDR3_SW_LEVELING)
+/* These values are obtained from the CCS app */
+#define RD_DQS_GATE	0x1B3
+#define RD_DQS		0x35
+#define WR_DQS		0x93
+
+#endif
+
+#endif /* CONFIG_TI816X_DDR_796 */
+
+
+#if defined(CONFIG_TI816X_DDR3_SW_LEVELING)
+#define WR_DQS_RATIO_BYTE_LANE3	((WR_DQS << 10) | WR_DQS)
+#define WR_DQS_RATIO_BYTE_LANE2	((WR_DQS << 10) | WR_DQS)
+#define WR_DQS_RATIO_BYTE_LANE1	((WR_DQS << 10) | WR_DQS)
+#define WR_DQS_RATIO_BYTE_LANE0	((WR_DQS << 10) | WR_DQS)
+
+#define WR_DATA_RATIO_BYTE_LANE3	(((WR_DQS + 0x40) << 10) | (WR_DQS + 0x40))
+#define WR_DATA_RATIO_BYTE_LANE2	(((WR_DQS + 0x40) << 10) | (WR_DQS + 0x40))
+#define WR_DATA_RATIO_BYTE_LANE1	(((WR_DQS + 0x40) << 10) | (WR_DQS + 0x40))
+#define WR_DATA_RATIO_BYTE_LANE0	(((WR_DQS + 0x40) << 10) | (WR_DQS + 0x40))
+
+#define RD_DQS_RATIO			((RD_DQS << 10) | RD_DQS)
+
+#define DQS_GATE_BYTE_LANE0		((RD_DQS_GATE << 10) | RD_DQS_GATE)
+#define DQS_GATE_BYTE_LANE1		((RD_DQS_GATE << 10) | RD_DQS_GATE)
+#define DQS_GATE_BYTE_LANE2		((RD_DQS_GATE << 10) | RD_DQS_GATE)
+#define DQS_GATE_BYTE_LANE3		((RD_DQS_GATE << 10) | RD_DQS_GATE)
+
+#endif	/* CONFIG_TI816X_DDR3_SW_LEVELING */
+
+#endif	/* CONFIG_TI816X_EVM_DDR3 */
+
+#ifdef CONFIG_TI816X_EVM_DDR2
+
+#define INVERT_CLK_OUT		0x0
+#define CMD_SLAVE_RATIO		0x80
+/*
+ * DDR2 ratio values.  These are board dependent
+ * obtained from sweep experiments
+ */
+
+/* EVM 400 MHz clock Settings */
+
+#define WR_DQS_RATIO_BYTE_LANE3	((0x4a << 10) | 0x4a)
+#define WR_DQS_RATIO_BYTE_LANE2	((0x4a << 10) | 0x4a)
+#define WR_DQS_RATIO_BYTE_LANE1	((0x4a << 10) | 0x4a)
+#define WR_DQS_RATIO_BYTE_LANE0	((0x4a << 10) | 0x4a)
+
+#define WR_DATA_RATIO_BYTE_LANE3	(((0x4a + 0x40) << 10) | (0x4a + 0x40))
+#define WR_DATA_RATIO_BYTE_LANE2	(((0x4a + 0x40) << 10) | (0x4a + 0x40))
+#define WR_DATA_RATIO_BYTE_LANE1	(((0x4a + 0x40) << 10) | (0x4a + 0x40))
+#define WR_DATA_RATIO_BYTE_LANE0	(((0x4a + 0x40) << 10) | (0x4a + 0x40))
+
+#define RD_DQS_RATIO			((0x40 << 10) | 0x40)
+
+#define DQS_GATE_BYTE_LANE0		((0x13a << 10) | 0x13a)
+#define DQS_GATE_BYTE_LANE1		((0x13a << 10) | 0x13a)
+#define DQS_GATE_BYTE_LANE2		((0x13a << 10) | 0x13a)
+#define DQS_GATE_BYTE_LANE3		((0x13a << 10) | 0x13a)
+
+/*
+ * EMIF Paramters
+ */
+#define EMIF_TIM1    0xAAB15E2
+#define EMIF_TIM2    0x423631D2
+#define EMIF_TIM3    0x80032F
+#define EMIF_SDREF   0x10000C30
+#define EMIF_SDCFG   0x43801A3A  /* 32 bit ddr2, CL=6, CWL=5, 13 rows, 8 banks, 10 bit column, 2 CS */
+#define EMIF_PHYCFG  0x0000010B  /* local odt = 1, read latency = 11 (max = 12, min=6) */
+
+#endif	/* CONFIG_TI816X_EVM_DDR2 */
+
+#ifdef CONFIG_TI814X_EVM_DDR2
+/* ti814x specific settings to be added */
+#endif
+
+/* AM335X EMIF Register values */
+#ifdef CONFIG_AM335X
+#define EMIF_SDMGT		0x80000000
+#define EMIF_SDRAM		0x00004650
+#define EMIF_PHYCFG		0x2
+#define DDR_PHY_RESET		(0x1 << 10)
+#define DDR_FUNCTIONAL_MODE_EN	0x1
+#define DDR_PHY_READY		(0x1 << 2)
+#define	VTP_CTRL_READY		(0x1 << 5)
+#define VTP_CTRL_ENABLE		(0x1 << 6)
+#define VTP_CTRL_LOCK_EN	(0x1 << 4)
+#define VTP_CTRL_START_EN	(0x1)
+#define DDR2_RATIO		0x80	/* for mDDR */
+#define CMD_FORCE		0x00	/* common #def */
+#define CMD_DELAY		0x00
+#if	(CONFIG_AM335X_EVM_IS_13x13 == 1)
+#define EMIF_READ_LATENCY	0x05
+#define EMIF_TIM1		0x04446249
+#define EMIF_TIM2		0x101731C0
+#define EMIF_TIM3		0x137
+#define EMIF_SDCFG		0x20004EA3
+#define EMIF_SDREF		0x57c
+#define	DDR2_DLL_LOCK_DIFF	0x4
+#define DDR2_RD_DQS		0x40
+#define DDR2_PHY_FIFO_WE	0x56
+#else
+#define EMIF_READ_LATENCY	0x05
+#define EMIF_TIM1		0x0666B3D6
+#define EMIF_TIM2		0x143731DA
+#define	EMIF_TIM3		0x00000347
+#define EMIF_SDCFG		0x43805332
+#define EMIF_SDREF		0x0000081a
+#define DDR2_DLL_LOCK_DIFF	0x0
+#define DDR2_RD_DQS		0x12
+#define DDR2_PHY_FIFO_WE	0x80
+#endif
+#define	DDR2_INVERT_CLKOUT	0x00
+#define	DDR2_WR_DQS		0x00
+#define	DDR2_PHY_WRLVL		0x00
+#define	DDR2_PHY_GATELVL	0x00
+#define	DDR2_PHY_WR_DATA	0x40
+#define	PHY_RANK0_DELAY		0x01
+#define PHY_DLL_LOCK_DIFF	0x0
+#define DDR_IOCTRL_VALUE	0x18B
+#endif
+
+#endif  /* _DDR_DEFS_H */
+
diff --git a/arch/arm/boards/beaglebone/env/boot/sd b/arch/arm/boards/beaglebone/env/boot/sd
new file mode 100644
index 0000000..f3f276c
--- /dev/null
+++ b/arch/arm/boards/beaglebone/env/boot/sd
@@ -0,0 +1,16 @@
+#!/bin/sh
+
+if [ "$1" = menu ]; then
+	boot-menu-add-entry "$0" "kernel & rootfs on SD card"
+	exit
+fi
+
+global.bootm.image=/boot/uImage
+#global.bootm.oftree=<path to oftree>
+#global.bootm.initrd=<path to initrd>
+
+#bootargs-root-nfs -n "<path on server>" -s <serverip>
+#bootargs-root-jffs2 -m <mtdname>
+#bootargs-root-ubi -r <volume> -m <mtdname>
+
+global.linux.bootargs.root="root=/dev/mmcblk0p2 rootfstype=ext4 rootwait ro"
diff --git a/arch/arm/boards/beaglebone/env/init/bootargs-base b/arch/arm/boards/beaglebone/env/init/bootargs-base
new file mode 100644
index 0000000..333856e
--- /dev/null
+++ b/arch/arm/boards/beaglebone/env/init/bootargs-base
@@ -0,0 +1,8 @@
+#!/bin/sh
+
+if [ "$1" = menu ]; then
+	init-menu-add-entry "$0" "Base bootargs"
+	exit
+fi
+
+global.linux.bootargs.base="console=ttyO0,115200n8"
diff --git a/arch/arm/boards/beaglebone/env/init/general b/arch/arm/boards/beaglebone/env/init/general
new file mode 100644
index 0000000..bbd7ee3
--- /dev/null
+++ b/arch/arm/boards/beaglebone/env/init/general
@@ -0,0 +1,18 @@
+#!/bin/sh
+
+if [ "$1" = menu ]; then
+	init-menu-add-entry "$0" "general config settings"
+	exit
+fi
+
+# user (used for network filenames)
+global.user=jlu
+
+# timeout in seconds before the default boot entry is started
+global.autoboot_timeout=3
+
+# default boot entry (one of /env/boot/*)
+global.boot.default=sd
+
+# default tftp path
+global.tftp.path=/mnt/tftp-dhcp
diff --git a/arch/arm/boards/beaglebone/hardware.h b/arch/arm/boards/beaglebone/hardware.h
new file mode 100644
index 0000000..ee4256a
--- /dev/null
+++ b/arch/arm/boards/beaglebone/hardware.h
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) 2009, Texas Instruments, Incorporated
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __TI81XX_HARDWARE_H
+#define __TI81XX_HARDWARE_H
+
+/* The objective is to keep only the overall memory map here
+ * The break-up of the memory map for individual modules registers should
+ * be in a different file like cpu.h so that this is the only place
+ * where change is needed for new SoCs when the IP is otherwise the same
+ */
+#ifdef CONFIG_AM335X
+#define SRAM0_START			0x402F0400
+#else
+#define SRAM0_START			0x40300000
+#endif
+#ifdef CONFIG_AM335X
+#define UART0_BASE			0x44E09000
+#else
+#define UART0_BASE			0x48020000
+#endif
+#define UART1_BASE			0x48022000
+#define UART2_BASE			0x48024000
+#define UART3_BASE			0x481A6000
+
+/* DM Timer base addresses */
+#define DM_TIMER0_BASE			0x4802C000
+#define DM_TIMER1_BASE			0x4802E000
+#define DM_TIMER2_BASE			0x48040000
+#define DM_TIMER3_BASE			0x48042000
+#define DM_TIMER4_BASE			0x48044000
+#define DM_TIMER5_BASE			0x48046000
+#define DM_TIMER6_BASE			0x48048000
+#define DM_TIMER7_BASE			0x4804A000
+
+/* GPIO Base address */
+#define GPIO0_BASE			0x48032000
+#define GPIO1_BASE			0x4804C000
+#ifdef CONFIG_AM335X
+#define GPIO2_BASE			0x481AC000
+#endif
+/* BCH Error Location Module */
+#define ELM_BASE			0x48080000
+
+/* Watchdog Timer */
+#ifdef CONFIG_AM335X
+#define WDT_BASE			0x44E35000
+#else
+#define WDT_BASE			0x480C2000
+#endif
+
+/* Control Module Base Address */
+#ifdef CONFIG_AM335X
+#define CTRL_BASE			0x44E10000
+#else
+#define CTRL_BASE			0x48140000
+#endif
+
+/* PRCM Base Address */
+#ifdef CONFIG_AM335X
+#define PRCM_BASE			0x44E00000
+#else
+#define PRCM_BASE			0x48180000
+#endif
+
+/* PLL Subsystem Base Address */
+#ifdef CONFIG_TI814X
+#define PLL_SUBSYS_BASE			0x481C5000
+#endif
+
+/* EMIF Base address */
+#define EMIF4_0_CFG_BASE		0x4C000000
+#define EMIF4_1_CFG_BASE		0x4D000000
+#define DMM_BASE			0x4E000000
+
+#ifdef CONFIG_TI816X
+#define DDRPHY_0_CONFIG_BASE		0x48198000
+#define DDRPHY_1_CONFIG_BASE		0x4819a000
+#define DDRPHY_CONFIG_BASE 		((emif == 0) ? DDRPHY_0_CONFIG_BASE:DDRPHY_1_CONFIG_BASE)
+#endif
+
+#ifdef CONFIG_TI814X
+#define DDRPHY_0_CONFIG_BASE		(CTRL_BASE + 0x1400)
+#define DDRPHY_1_CONFIG_BASE		(CTRL_BASE + 0x1500)
+#define DDRPHY_CONFIG_BASE 		((emif == 0) ? DDRPHY_0_CONFIG_BASE:DDRPHY_1_CONFIG_BASE)
+#endif
+
+#ifdef CONFIG_AM335X
+#define DDRPHY_0_CONFIG_BASE		(CTRL_BASE + 0x1400)
+#define DDRPHY_CONFIG_BASE		DDRPHY_0_CONFIG_BASE
+#endif
+
+/* GPMC Base address */
+#define GPMC_BASE			0x50000000
+
+/* CPSW Config space */
+#define TI814X_CPSW_BASE               0x4A100000
+#define TI814X_CPSW_MDIO_BASE          0x4A100800
+
+#define AM335X_CPSW_BASE               0x4A100000
+#define AM335X_CPSW_MDIO_BASE          0x4A101000
+
+#endif /* __TI81XX_HARDWARE_H */
+
diff --git a/arch/arm/boards/beaglebone/mux.c b/arch/arm/boards/beaglebone/mux.c
new file mode 100644
index 0000000..7fac302
--- /dev/null
+++ b/arch/arm/boards/beaglebone/mux.c
@@ -0,0 +1,707 @@
+/*
+ * mux.c
+ *
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+#include <common.h>
+#include <config.h>
+#include <asm/io.h>
+#include "config.h"
+#include "common_def.h"
+#include "hardware.h"
+
+#define MUX_CFG(value, offset)	\
+	__raw_writel(value, (CTRL_BASE + offset));
+
+/* PAD Control Fields */
+#define SLEWCTRL	(0x1 << 6)
+#define	RXACTIVE	(0x1 << 5)
+#define	PULLUP_EN	(0x1 << 4) /* Pull UP Selection */
+#define PULLUDEN	(0x0 << 3) /* Pull up enabled */
+#define PULLUDDIS	(0x1 << 3) /* Pull up disabled */
+#define MODE(val)	val
+
+/*
+ * PAD CONTROL OFFSETS
+ * Field names corresponds to the pad signal name
+ */
+struct pad_signals {
+	int gpmc_ad0;
+	int gpmc_ad1;
+	int gpmc_ad2;
+	int gpmc_ad3;
+	int gpmc_ad4;
+	int gpmc_ad5;
+	int gpmc_ad6;
+	int gpmc_ad7;
+	int gpmc_ad8;
+	int gpmc_ad9;
+	int gpmc_ad10;
+	int gpmc_ad11;
+	int gpmc_ad12;
+	int gpmc_ad13;
+	int gpmc_ad14;
+	int gpmc_ad15;
+	int gpmc_a0;
+	int gpmc_a1;
+	int gpmc_a2;
+	int gpmc_a3;
+	int gpmc_a4;
+	int gpmc_a5;
+	int gpmc_a6;
+	int gpmc_a7;
+	int gpmc_a8;
+	int gpmc_a9;
+	int gpmc_a10;
+	int gpmc_a11;
+	int gpmc_wait0;
+	int gpmc_wpn;
+	int gpmc_be1n;
+	int gpmc_csn0;
+	int gpmc_csn1;
+	int gpmc_csn2;
+	int gpmc_csn3;
+	int gpmc_clk;
+	int gpmc_advn_ale;
+	int gpmc_oen_ren;
+	int gpmc_wen;
+	int gpmc_be0n_cle;
+	int lcd_data0;
+	int lcd_data1;
+	int lcd_data2;
+	int lcd_data3;
+	int lcd_data4;
+	int lcd_data5;
+	int lcd_data6;
+	int lcd_data7;
+	int lcd_data8;
+	int lcd_data9;
+	int lcd_data10;
+	int lcd_data11;
+	int lcd_data12;
+	int lcd_data13;
+	int lcd_data14;
+	int lcd_data15;
+	int lcd_vsync;
+	int lcd_hsync;
+	int lcd_pclk;
+	int lcd_ac_bias_en;
+	int mmc0_dat3;
+	int mmc0_dat2;
+	int mmc0_dat1;
+	int mmc0_dat0;
+	int mmc0_clk;
+	int mmc0_cmd;
+	int mii1_col;
+	int mii1_crs;
+	int mii1_rxerr;
+	int mii1_txen;
+	int mii1_rxdv;
+	int mii1_txd3;
+	int mii1_txd2;
+	int mii1_txd1;
+	int mii1_txd0;
+	int mii1_txclk;
+	int mii1_rxclk;
+	int mii1_rxd3;
+	int mii1_rxd2;
+	int mii1_rxd1;
+	int mii1_rxd0;
+	int rmii1_refclk;
+	int mdio_data;
+	int mdio_clk;
+	int spi0_sclk;
+	int spi0_d0;
+	int spi0_d1;
+	int spi0_cs0;
+	int spi0_cs1;
+	int ecap0_in_pwm0_out;
+	int uart0_ctsn;
+	int uart0_rtsn;
+	int uart0_rxd;
+	int uart0_txd;
+	int uart1_ctsn;
+	int uart1_rtsn;
+	int uart1_rxd;
+	int uart1_txd;
+	int i2c0_sda;
+	int i2c0_scl;
+	int mcasp0_aclkx;
+	int mcasp0_fsx;
+	int mcasp0_axr0;
+	int mcasp0_ahclkr;
+	int mcasp0_aclkr;
+	int mcasp0_fsr;
+	int mcasp0_axr1;
+	int mcasp0_ahclkx;
+	int xdma_event_intr0;
+	int xdma_event_intr1;
+	int nresetin_out;
+	int porz;
+	int nnmi;
+	int osc0_in;
+	int osc0_out;
+	int rsvd1;
+	int tms;
+	int tdi;
+	int tdo;
+	int tck;
+	int ntrst;
+	int emu0;
+	int emu1;
+	int osc1_in;
+	int osc1_out;
+	int pmic_power_en;
+	int rtc_porz;
+	int rsvd2;
+	int ext_wakeup;
+	int enz_kaldo_1p8v;
+	int usb0_dm;
+	int usb0_dp;
+	int usb0_ce;
+	int usb0_id;
+	int usb0_vbus;
+	int usb0_drvvbus;
+	int usb1_dm;
+	int usb1_dp;
+	int usb1_ce;
+	int usb1_id;
+	int usb1_vbus;
+	int usb1_drvvbus;
+	int ddr_resetn;
+	int ddr_csn0;
+	int ddr_cke;
+	int ddr_ck;
+	int ddr_nck;
+	int ddr_casn;
+	int ddr_rasn;
+	int ddr_wen;
+	int ddr_ba0;
+	int ddr_ba1;
+	int ddr_ba2;
+	int ddr_a0;
+	int ddr_a1;
+	int ddr_a2;
+	int ddr_a3;
+	int ddr_a4;
+	int ddr_a5;
+	int ddr_a6;
+	int ddr_a7;
+	int ddr_a8;
+	int ddr_a9;
+	int ddr_a10;
+	int ddr_a11;
+	int ddr_a12;
+	int ddr_a13;
+	int ddr_a14;
+	int ddr_a15;
+	int ddr_odt;
+	int ddr_d0;
+	int ddr_d1;
+	int ddr_d2;
+	int ddr_d3;
+	int ddr_d4;
+	int ddr_d5;
+	int ddr_d6;
+	int ddr_d7;
+	int ddr_d8;
+	int ddr_d9;
+	int ddr_d10;
+	int ddr_d11;
+	int ddr_d12;
+	int ddr_d13;
+	int ddr_d14;
+	int ddr_d15;
+	int ddr_dqm0;
+	int ddr_dqm1;
+	int ddr_dqs0;
+	int ddr_dqsn0;
+	int ddr_dqs1;
+	int ddr_dqsn1;
+	int ddr_vref;
+	int ddr_vtp;
+	int ddr_strben0;
+	int ddr_strben1;
+	int ain7;
+	int ain6;
+	int ain5;
+	int ain4;
+	int ain3;
+	int ain2;
+	int ain1;
+	int ain0;
+	int vrefp;
+	int vrefn;
+};
+
+struct module_pin_mux {
+	short reg_offset;
+	unsigned char val;
+};
+
+struct evm_pin_mux {
+	struct module_pin_mux *mod_pin_mux;
+	unsigned short profile;
+/*
+* If the device is required on both baseboard & daughter board (ex i2c),
+* specify DEV_ON_BASEBOARD
+*/
+#define DEV_ON_BASEBOARD       0
+#define DEV_ON_DGHTR_BRD       1
+	unsigned short device_on;
+};
+
+#define PAD_CTRL_BASE	0x800
+#define OFFSET(x)	(unsigned int) (&((struct pad_signals *) \
+				(PAD_CTRL_BASE))->x)
+
+static struct module_pin_mux uart0_pin_mux[] = {
+	{OFFSET(uart0_rxd), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* UART0_RXD */
+	{OFFSET(uart0_txd), (MODE(0) | PULLUDEN)},		/* UART0_TXD */
+	{-1},
+};
+
+static struct module_pin_mux uart3_pin_mux[] = {
+	{OFFSET(spi0_cs1), (MODE(1) | PULLUDEN | RXACTIVE)},	/* UART3_RXD */
+	{OFFSET(ecap0_in_pwm0_out), (MODE(1) | PULLUDEN)},	/* UART3_TXD */
+	{-1},
+};
+
+
+#ifdef CONFIG_NAND
+static struct module_pin_mux nand_pin_mux[] = {
+	{OFFSET(gpmc_ad0), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD0 */
+	{OFFSET(gpmc_ad1), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD1 */
+	{OFFSET(gpmc_ad2), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD2 */
+	{OFFSET(gpmc_ad3), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD3 */
+	{OFFSET(gpmc_ad4), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD4 */
+	{OFFSET(gpmc_ad5), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD5 */
+	{OFFSET(gpmc_ad6), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD6 */
+	{OFFSET(gpmc_ad7), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD7 */
+	{OFFSET(gpmc_wait0), (MODE(0) | RXACTIVE | PULLUP_EN)}, /* NAND WAIT */
+	{OFFSET(gpmc_wpn), (MODE(7) | PULLUP_EN | RXACTIVE)},	/* NAND_WPN */
+	{OFFSET(gpmc_csn0), (MODE(0) | PULLUDEN)},	/* NAND_CS0 */
+	{OFFSET(gpmc_advn_ale), (MODE(0) | PULLUDEN)}, /* NAND_ADV_ALE */
+	{OFFSET(gpmc_oen_ren), (MODE(0) | PULLUDEN)},	/* NAND_OE */
+	{OFFSET(gpmc_wen), (MODE(0) | PULLUDEN)},	/* NAND_WEN */
+	{OFFSET(gpmc_be0n_cle), (MODE(0) | PULLUDEN)},	/* NAND_BE_CLE */
+	{-1},
+};
+#endif
+
+static struct module_pin_mux i2c0_pin_mux[] = {
+	{OFFSET(i2c0_sda), (MODE(0) | RXACTIVE | PULLUDEN | SLEWCTRL)},	/* I2C_DATA */
+	{OFFSET(i2c0_scl), (MODE(0) | RXACTIVE | PULLUDEN | SLEWCTRL)},	/* I2C_SCLK */
+	{-1},
+};
+
+static struct module_pin_mux i2c1_pin_mux[] = {
+	{OFFSET(spi0_d1), (MODE(2) | RXACTIVE | PULLUDEN | SLEWCTRL)},	/* I2C_DATA */
+	{OFFSET(spi0_cs0), (MODE(2) | RXACTIVE | PULLUDEN | SLEWCTRL)},	/* I2C_SCLK */
+	{-1},
+};
+
+static struct module_pin_mux i2c2_pin_mux[] = {
+	{OFFSET(uart1_ctsn), (MODE(3) | RXACTIVE | PULLUDEN | SLEWCTRL)},  /* I2C_DATA */
+	{OFFSET(uart1_rtsn), (MODE(3) | RXACTIVE | PULLUDEN | SLEWCTRL)}, /* I2C_SCLK */
+	{-1},
+};
+
+#ifndef CONFIG_NO_ETH
+static struct module_pin_mux rgmii1_pin_mux[] = {
+	{OFFSET(mii1_txen), MODE(2)},			/* RGMII1_TCTL */
+	{OFFSET(mii1_rxdv), MODE(2) | RXACTIVE},	/* RGMII1_RCTL */
+	{OFFSET(mii1_txd3), MODE(2)},			/* RGMII1_TD3 */
+	{OFFSET(mii1_txd2), MODE(2)},			/* RGMII1_TD2 */
+	{OFFSET(mii1_txd1), MODE(2)},			/* RGMII1_TD1 */
+	{OFFSET(mii1_txd0), MODE(2)},			/* RGMII1_TD0 */
+	{OFFSET(mii1_txclk), MODE(2)},			/* RGMII1_TCLK */
+	{OFFSET(mii1_rxclk), MODE(2) | RXACTIVE},	/* RGMII1_RCLK */
+	{OFFSET(mii1_rxd3), MODE(2) | RXACTIVE},	/* RGMII1_RD3 */
+	{OFFSET(mii1_rxd2), MODE(2) | RXACTIVE},	/* RGMII1_RD2 */
+	{OFFSET(mii1_rxd1), MODE(2) | RXACTIVE},	/* RGMII1_RD1 */
+	{OFFSET(mii1_rxd0), MODE(2) | RXACTIVE},	/* RGMII1_RD0 */
+	{OFFSET(mdio_data), MODE(0) | RXACTIVE | PULLUP_EN}, /* MDIO_DATA */
+	{OFFSET(mdio_clk), MODE(0) | PULLUP_EN},	/* MDIO_CLK */
+	{-1},
+};
+
+static struct module_pin_mux rgmii2_pin_mux[] = {
+	{OFFSET(gpmc_a0), MODE(2)},			/* RGMII2_TCTL */
+	{OFFSET(gpmc_a1), MODE(2) | RXACTIVE},		/* RGMII2_RCTL */
+	{OFFSET(gpmc_a2), MODE(2)},			/* RGMII2_TD3 */
+	{OFFSET(gpmc_a3), MODE(2)},			/* RGMII2_TD2 */
+	{OFFSET(gpmc_a4), MODE(2)},			/* RGMII2_TD1 */
+	{OFFSET(gpmc_a5), MODE(2)},			/* RGMII2_TD0 */
+	{OFFSET(gpmc_a6), MODE(2)},			/* RGMII2_TCLK */
+	{OFFSET(gpmc_a7), MODE(2) | RXACTIVE},		/* RGMII2_RCLK */
+	{OFFSET(gpmc_a8), MODE(2) | RXACTIVE},		/* RGMII2_RD3 */
+	{OFFSET(gpmc_a9), MODE(2) | RXACTIVE},		/* RGMII2_RD2 */
+	{OFFSET(gpmc_a10), MODE(2) | RXACTIVE},		/* RGMII2_RD1 */
+	{OFFSET(gpmc_a11), MODE(2) | RXACTIVE},		/* RGMII2_RD0 */
+	{OFFSET(mdio_data), MODE(0) | RXACTIVE | PULLUP_EN}, /* MDIO_DATA */
+	{OFFSET(mdio_clk), MODE(0) | PULLUP_EN},	/* MDIO_CLK */
+	{-1},
+};
+
+static struct module_pin_mux mii1_pin_mux[] = {
+	{OFFSET(mii1_rxerr), MODE(0) | RXACTIVE},	/* MII1_RXERR */
+	{OFFSET(mii1_txen), MODE(0)},			/* MII1_TXEN */
+	{OFFSET(mii1_rxdv), MODE(0) | RXACTIVE},	/* MII1_RXDV */
+	{OFFSET(mii1_txd3), MODE(0)},			/* MII1_TXD3 */
+	{OFFSET(mii1_txd2), MODE(0)},			/* MII1_TXD2 */
+	{OFFSET(mii1_txd1), MODE(0)},			/* MII1_TXD1 */
+	{OFFSET(mii1_txd0), MODE(0)},			/* MII1_TXD0 */
+	{OFFSET(mii1_txclk), MODE(0) | RXACTIVE},	/* MII1_TXCLK */
+	{OFFSET(mii1_rxclk), MODE(0) | RXACTIVE},	/* MII1_RXCLK */
+	{OFFSET(mii1_rxd3), MODE(0) | RXACTIVE},	/* MII1_RXD3 */
+	{OFFSET(mii1_rxd2), MODE(0) | RXACTIVE},	/* MII1_RXD2 */
+	{OFFSET(mii1_rxd1), MODE(0) | RXACTIVE},	/* MII1_RXD1 */
+	{OFFSET(mii1_rxd0), MODE(0) | RXACTIVE},	/* MII1_RXD0 */
+	{OFFSET(mdio_data), MODE(0) | RXACTIVE | PULLUP_EN}, /* MDIO_DATA */
+	{OFFSET(mdio_clk), MODE(0) | PULLUP_EN},	/* MDIO_CLK */
+	{-1},
+};
+
+static struct module_pin_mux rmii1_pin_mux[] = {
+   {OFFSET(mii1_crs), MODE(1) | RXACTIVE},     /* RMII1_CRS */
+   {OFFSET(mii1_rxerr), MODE(1) | RXACTIVE},   /* RMII1_RXERR */
+   {OFFSET(mii1_txen), MODE(1)},           /* RMII1_TXEN */
+   {OFFSET(mii1_txd1), MODE(1)},           /* RMII1_TXD1 */
+   {OFFSET(mii1_txd0), MODE(1)},           /* RMII1_TXD0 */
+   {OFFSET(mii1_rxd1), MODE(1) | RXACTIVE},    /* RMII1_RXD1 */
+   {OFFSET(mii1_rxd0), MODE(1) | RXACTIVE},    /* RMII1_RXD0 */
+   {OFFSET(mdio_data), MODE(0) | RXACTIVE | PULLUP_EN}, /* MDIO_DATA */
+   {OFFSET(mdio_clk), MODE(0) | PULLUP_EN},    /* MDIO_CLK */
+   {OFFSET(rmii1_refclk), MODE(0) | RXACTIVE}, /* RMII1_REFCLK */
+   {-1},
+};
+#endif
+
+#ifdef CONFIG_NOR
+static struct module_pin_mux nor_pin_mux[] = {
+	{OFFSET(lcd_data0), MODE(1) | PULLUDEN},	/* NOR_A0 */
+	{OFFSET(lcd_data1), MODE(1) | PULLUDEN},	/* NOR_A1 */
+	{OFFSET(lcd_data2), MODE(1) | PULLUDEN},	/* NOR_A2 */
+	{OFFSET(lcd_data3), MODE(1) | PULLUDEN},	/* NOR_A3 */
+	{OFFSET(lcd_data4), MODE(1) | PULLUDEN},	/* NOR_A4 */
+	{OFFSET(lcd_data5), MODE(1) | PULLUDEN},	/* NOR_A5 */
+	{OFFSET(lcd_data6), MODE(1) | PULLUDEN},	/* NOR_A6 */
+	{OFFSET(lcd_data7), MODE(1) | PULLUDEN},	/* NOR_A7 */
+	{OFFSET(gpmc_a8), MODE(0)},			/* NOR_A8 */
+	{OFFSET(gpmc_a9), MODE(0)},			/* NOR_A9 */
+	{OFFSET(gpmc_a10), MODE(0)},			/* NOR_A10 */
+	{OFFSET(gpmc_a11), MODE(0)},			/* NOR_A11 */
+	{OFFSET(lcd_data8), MODE(1) | PULLUDEN},	/* NOR_A12 */
+	{OFFSET(lcd_data9), MODE(1) | PULLUDEN},	/* NOR_A13 */
+	{OFFSET(lcd_data10), MODE(1) | PULLUDEN},	/* NOR_A14 */
+	{OFFSET(lcd_data11), MODE(1) | PULLUDEN},	/* NOR_A15 */
+	{OFFSET(lcd_data12), MODE(1) | PULLUDEN},	/* NOR_A16 */
+	{OFFSET(lcd_data13), MODE(1) | PULLUDEN},	/* NOR_A17 */
+	{OFFSET(lcd_data14), MODE(1) | PULLUDEN},	/* NOR_A18 */
+	{OFFSET(lcd_data15), MODE(1) | PULLUDEN},	/* NOR_A19 */
+	{OFFSET(gpmc_a4), MODE(4)},			/* NOR_A20 */
+	{OFFSET(gpmc_a5), MODE(4)},			/* NOR_A21 */
+	{OFFSET(gpmc_a6), MODE(4)},			/* NOR_A22 */
+	{OFFSET(gpmc_ad0), MODE(0) | RXACTIVE},		/* NOR_AD0 */
+	{OFFSET(gpmc_ad1), MODE(0) | RXACTIVE},		/* NOR_AD1 */
+	{OFFSET(gpmc_ad2), MODE(0) | RXACTIVE},		/* NOR_AD2 */
+	{OFFSET(gpmc_ad3), MODE(0) | RXACTIVE},		/* NOR_AD3 */
+	{OFFSET(gpmc_ad4), MODE(0) | RXACTIVE},		/* NOR_AD4 */
+	{OFFSET(gpmc_ad5), MODE(0) | RXACTIVE},		/* NOR_AD5 */
+	{OFFSET(gpmc_ad6), MODE(0) | RXACTIVE},		/* NOR_AD6 */
+	{OFFSET(gpmc_ad7), MODE(0) | RXACTIVE},		/* NOR_AD7 */
+	{OFFSET(gpmc_ad8), MODE(0) | RXACTIVE},		/* NOR_AD8 */
+	{OFFSET(gpmc_ad9), MODE(0) | RXACTIVE},		/* NOR_AD9 */
+	{OFFSET(gpmc_ad10), MODE(0) | RXACTIVE},	/* NOR_AD10 */
+	{OFFSET(gpmc_ad11), MODE(0) | RXACTIVE},	/* NOR_AD11 */
+	{OFFSET(gpmc_ad12), MODE(0) | RXACTIVE},	/* NOR_AD12 */
+	{OFFSET(gpmc_ad13), MODE(0) | RXACTIVE},	/* NOR_AD13 */
+	{OFFSET(gpmc_ad14), MODE(0) | RXACTIVE},	/* NOR_AD14 */
+	{OFFSET(gpmc_ad15), MODE(0) | RXACTIVE},	/* NOR_AD15 */
+	{OFFSET(gpmc_csn0), (MODE(0) | PULLUP_EN)},	/* NOR_CE */
+	{OFFSET(gpmc_oen_ren), (MODE(0) | PULLUP_EN)},	/* NOR_OE */
+	{OFFSET(gpmc_wen), (MODE(0) | PULLUP_EN)},	/* NOR_WEN */
+	{OFFSET(gpmc_wait0), (MODE(0) | RXACTIVE | PULLUP_EN)}, /* NOR WAIT */
+	{OFFSET(lcd_ac_bias_en), MODE(7) | RXACTIVE | PULLUDEN}, /* NOR RESET */
+	{-1},
+};
+#endif
+
+#ifdef CONFIG_MMC
+static struct module_pin_mux mmc0_pin_mux[] = {
+	{OFFSET(mmc0_dat3), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT3 */
+	{OFFSET(mmc0_dat2), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT2 */
+	{OFFSET(mmc0_dat1), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT1 */
+	{OFFSET(mmc0_dat0), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT0 */
+	{OFFSET(mmc0_clk), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CLK */
+	{OFFSET(mmc0_cmd), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CMD */
+	{OFFSET(mcasp0_aclkr), (MODE(4) | RXACTIVE)},		/* MMC0_WP */
+	{OFFSET(spi0_cs1), (MODE(5) | RXACTIVE | PULLUP_EN)},	/* MMC0_CD */
+	{-1},
+};
+
+static struct module_pin_mux mmc1_pin_mux[] = {
+	{OFFSET(gpmc_ad3), (MODE(1) | RXACTIVE)},	/* MMC1_DAT3 */
+	{OFFSET(gpmc_ad2), (MODE(1) | RXACTIVE)},	/* MMC1_DAT2 */
+	{OFFSET(gpmc_ad1), (MODE(1) | RXACTIVE)},	/* MMC1_DAT1 */
+	{OFFSET(gpmc_ad0), (MODE(1) | RXACTIVE)},	/* MMC1_DAT0 */
+	{OFFSET(gpmc_csn1), (MODE(2) | RXACTIVE | PULLUP_EN)},	/* MMC1_CLK */
+	{OFFSET(gpmc_csn2), (MODE(2) | RXACTIVE | PULLUP_EN)},	/* MMC1_CMD */
+	{OFFSET(uart1_rxd), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_WP */
+	{OFFSET(mcasp0_fsx), (MODE(4) | RXACTIVE)},	/* MMC1_CD */
+	{-1},
+};
+#endif
+
+#ifdef CONFIG_SPI
+static struct module_pin_mux spi0_pin_mux[] = {
+	{OFFSET(spi0_sclk), MODE(0) | PULLUDEN | RXACTIVE},	/*SPI0_SCLK */
+	{OFFSET(spi0_d0), MODE(0) | PULLUDEN | PULLUP_EN |
+							RXACTIVE}, /*SPI0_D0 */
+	{OFFSET(spi0_d1), MODE(0) | PULLUDEN |
+							RXACTIVE}, /*SPI0_D1 */
+	{OFFSET(spi0_cs0), MODE(0) | PULLUDEN | PULLUP_EN | RXACTIVE},	/*SPI0_CS0 */
+	{-1},
+};
+
+static struct module_pin_mux spi1_pin_mux[] = {
+	{OFFSET(mcasp0_aclkx), MODE(3) | PULLUDEN | RXACTIVE},	/*SPI0_SCLK */
+	{OFFSET(mcasp0_fsx), MODE(3) | PULLUDEN | PULLUP_EN |
+							RXACTIVE}, /*SPI0_D0 */
+	{OFFSET(mcasp0_axr0), MODE(3) | PULLUDEN | RXACTIVE}, /*SPI0_D1 */
+	{OFFSET(mcasp0_ahclkr), MODE(3) | PULLUDEN | PULLUP_EN |
+							RXACTIVE}, /*SPI0_CS0 */
+	{-1},
+};
+#endif
+
+/*
+ * Update the structure with the modules present in the general purpose
+ * board and the profiles in which the modules are present.
+ * If the module is physically present but if it is not available
+ * in any of the profile, then do not update it.
+ * For eg, nand is avialable only in the profiles 0 and 1, whereas
+ * UART0  is available in all the profiles.
+ */
+static struct evm_pin_mux general_purpose_evm_pin_mux[] = {
+	{uart0_pin_mux, PROFILE_ALL, DEV_ON_BASEBOARD},
+	{i2c1_pin_mux, PROFILE_ALL & ~PROFILE_2 & ~PROFILE_4, DEV_ON_BASEBOARD},
+#ifdef CONFIG_NAND
+	{nand_pin_mux, PROFILE_ALL & ~PROFILE_2 & ~PROFILE_3, DEV_ON_DGHTR_BRD},
+#endif
+#ifndef CONFIG_NO_ETH
+	{rgmii1_pin_mux, PROFILE_ALL, DEV_ON_BASEBOARD},
+	{rgmii2_pin_mux, PROFILE_1 | PROFILE_2 | PROFILE_4 | PROFILE_6,
+							DEV_ON_DGHTR_BRD},
+#endif
+#ifdef CONFIG_NOR
+	{nor_pin_mux, PROFILE_3, DEV_ON_DGHTR_BRD},
+#endif
+#ifdef CONFIG_MMC
+	{mmc0_pin_mux, PROFILE_ALL, DEV_ON_BASEBOARD},
+	{mmc1_pin_mux, PROFILE_2, DEV_ON_DGHTR_BRD},
+#endif
+#ifdef CONFIG_SPI
+	{spi0_pin_mux, PROFILE_2, DEV_ON_DGHTR_BRD},
+#endif
+	{0},
+};
+
+/*
+ * Update the structure with the modules present in the ia daughter board and
+ * the profiles in which the modules are present. If the module is physically
+ * present but if it is not available in any of the profile, then do not update
+ */
+static struct evm_pin_mux ia_motor_control_evm_pin_mux[] = {
+#ifdef CONFIG_NAND
+	{nand_pin_mux, PROFILE_ALL, DEV_ON_DGHTR_BRD},
+#endif
+#ifdef CONFIG_MMC
+	{mmc0_pin_mux, PROFILE_ALL, DEV_ON_BASEBOARD},
+#endif
+#ifdef CONFIG_SPI
+	{spi1_pin_mux, PROFILE_ALL, DEV_ON_DGHTR_BRD},
+#endif
+#ifndef CONFIG_NO_ETH
+	{mii1_pin_mux, PROFILE_ALL, DEV_ON_BASEBOARD},
+#endif
+	{uart3_pin_mux, PROFILE_ALL, DEV_ON_DGHTR_BRD},
+	{0},
+};
+
+/* IP Phone EVM has single profile */
+static struct evm_pin_mux ip_phone_evm_pin_mux[] = {
+	{uart0_pin_mux,	PROFILE_NONE, DEV_ON_BASEBOARD},
+	{i2c1_pin_mux, PROFILE_NONE, DEV_ON_BASEBOARD},
+#ifdef CONFIG_NAND
+	{nand_pin_mux, PROFILE_0, DEV_ON_BASEBOARD},
+#endif
+#ifndef CONFIG_NO_ETH
+	{rgmii1_pin_mux, PROFILE_0, DEV_ON_BASEBOARD},
+	{rgmii2_pin_mux, PROFILE_0, DEV_ON_DGHTR_BRD},
+#endif
+#ifdef CONFIG_MMC
+	{mmc0_pin_mux, PROFILE_0, DEV_ON_BASEBOARD},
+#endif
+	{0},
+};
+
+/* Base board has single profile */
+static struct evm_pin_mux low_cost_evm_pin_mux[] = {
+	{uart0_pin_mux,	PROFILE_NONE, DEV_ON_BASEBOARD},
+	{i2c1_pin_mux, PROFILE_NONE, DEV_ON_BASEBOARD},
+#ifdef CONFIG_NAND
+	{nand_pin_mux, PROFILE_NONE, DEV_ON_BASEBOARD},
+#endif
+#ifndef CONFIG_NO_ETH
+	{rgmii1_pin_mux, PROFILE_NONE, DEV_ON_BASEBOARD},
+#endif
+#ifdef CONFIG_MMC
+	{mmc0_pin_mux, PROFILE_NONE, DEV_ON_BASEBOARD},
+#endif
+	{0},
+};
+
+static struct evm_pin_mux beaglebone_pin_mux[] = {
+	{uart0_pin_mux, PROFILE_ALL, DEV_ON_BASEBOARD},
+	{i2c1_pin_mux, PROFILE_ALL & ~PROFILE_2 & ~PROFILE_4, DEV_ON_BASEBOARD},
+	{i2c2_pin_mux, PROFILE_ALL, DEV_ON_BASEBOARD},
+#ifdef CONFIG_NAND
+	{nand_pin_mux, PROFILE_ALL & ~PROFILE_2 & ~PROFILE_3, DEV_ON_DGHTR_BRD},
+#endif
+#ifndef CONFIG_NO_ETH
+	{mii1_pin_mux, PROFILE_ALL, DEV_ON_BASEBOARD},
+#endif
+#ifdef CONFIG_MMC
+	{mmc0_pin_mux, PROFILE_ALL, DEV_ON_BASEBOARD},
+	{mmc1_pin_mux, PROFILE_2, DEV_ON_DGHTR_BRD},
+#endif
+#ifdef CONFIG_SPI
+	{spi0_pin_mux, PROFILE_2, DEV_ON_DGHTR_BRD},
+#endif
+	{0},
+};
+
+static struct evm_pin_mux beaglebone_old_pin_mux[] = {
+	{uart0_pin_mux, PROFILE_ALL, DEV_ON_BASEBOARD},
+	{i2c1_pin_mux, PROFILE_ALL & ~PROFILE_2 & ~PROFILE_4, DEV_ON_BASEBOARD},
+	{i2c2_pin_mux, PROFILE_ALL, DEV_ON_BASEBOARD},
+#ifdef CONFIG_NAND
+	{nand_pin_mux, PROFILE_ALL & ~PROFILE_2 & ~PROFILE_3, DEV_ON_DGHTR_BRD},
+#endif
+#ifndef CONFIG_NO_ETH
+	{rmii1_pin_mux, PROFILE_ALL, DEV_ON_BASEBOARD},
+#endif
+#ifdef CONFIG_MMC
+	{mmc0_pin_mux, PROFILE_ALL, DEV_ON_BASEBOARD},
+	{mmc1_pin_mux, PROFILE_2, DEV_ON_DGHTR_BRD},
+#endif
+#ifdef CONFIG_SPI
+	{spi0_pin_mux, PROFILE_2, DEV_ON_DGHTR_BRD},
+#endif
+	{0},
+};
+
+static struct evm_pin_mux *am335x_evm_pin_mux[] = {
+	beaglebone_pin_mux,
+	general_purpose_evm_pin_mux,
+	ia_motor_control_evm_pin_mux,
+	ip_phone_evm_pin_mux,
+	low_cost_evm_pin_mux,
+};
+
+/*
+ * Configure the pin mux for the module
+ */
+static void configure_module_pin_mux(struct module_pin_mux *mod_pin_mux)
+{
+	int i;
+
+	if (!mod_pin_mux)
+		return;
+
+	for (i = 0; mod_pin_mux[i].reg_offset != -1; i++)
+		MUX_CFG(mod_pin_mux[i].val, mod_pin_mux[i].reg_offset);
+}
+
+/*
+ * Check each module in the daughter board(first argument) whether it is
+ * available in the selected profile(second argument). If the module is not
+ * available in the selected profile, skip the corresponding configuration.
+ */
+static void set_evm_pin_mux(struct evm_pin_mux *pin_mux,
+			int prof, unsigned int dghtr_brd_flg)
+{
+	int i;
+
+	if (!pin_mux)
+		return;
+
+	/*
+	* Only General Purpose & Industrial Auto Motro Control
+	* EVM has profiles. So check if this evm has profile.
+	* If not, ignore the profile comparison
+	*/
+
+	/*
+	* If the device is on baseboard, directly configure it. Else (device on
+	* Daughter board), check if the daughter card is detected.
+	*/
+
+	for (i = 0; pin_mux[i].mod_pin_mux != 0; i++)  {
+		if ((pin_mux[i].profile & prof) ||
+					(prof == PROFILE_NONE)) {
+			if (pin_mux->device_on == DEV_ON_BASEBOARD)
+				configure_module_pin_mux(pin_mux[i].
+								mod_pin_mux);
+			else if (dghtr_brd_flg)
+					configure_module_pin_mux(pin_mux[i].
+								mod_pin_mux);
+		}
+	}
+}
+
+void configure_evm_pin_mux(unsigned char dghtr_brd_id, char version[4], unsigned short
+		profile, unsigned int daughter_board_flag)
+{
+	if (dghtr_brd_id > BASE_BOARD)
+		return;
+
+	/* Setup correct evm pinmux for older bone boards (Rev < A2) */
+	if (dghtr_brd_id == BONE_BOARD &&
+	   (!strncmp(version, "00A2", 4) || !strncmp(version, "00A1", 4)))
+		am335x_evm_pin_mux[dghtr_brd_id] = beaglebone_old_pin_mux;
+
+	set_evm_pin_mux(am335x_evm_pin_mux[dghtr_brd_id], profile,
+							daughter_board_flag);
+}
+
+void enable_i2c0_pin_mux(void)
+{
+	configure_module_pin_mux(i2c0_pin_mux);
+}
+
+void enable_i2c1_pin_mux(void)
+{
+	configure_module_pin_mux(i2c1_pin_mux);
+}
+
+void enable_i2c2_pin_mux(void)
+{
+	configure_module_pin_mux(i2c2_pin_mux);
+}
+
+void enable_uart0_pin_mux(void)
+{
+	configure_module_pin_mux(uart0_pin_mux);
+}
diff --git a/arch/arm/boards/beaglebone/pll.c b/arch/arm/boards/beaglebone/pll.c
new file mode 100644
index 0000000..bc09fea
--- /dev/null
+++ b/arch/arm/boards/beaglebone/pll.c
@@ -0,0 +1,293 @@
+/*
+ * pll.c
+ *
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+#include <common.h>
+#include <asm/io.h>
+#include "config.h"
+#include "common_def.h"
+#include "cpu.h"
+#include "clock.h"
+#include "hardware.h"
+
+#define PRCM_MOD_EN		0x2
+#define	PRCM_FORCE_WAKEUP	0x2
+
+#define PRCM_EMIF_CLK_ACTIVITY	(0x1 << 2)
+#define PRCM_L3_GCLK_ACTIVITY	(0x1 << 4)
+
+#define PLL_BYPASS_MODE	0x4
+#define PLL_LOCK_MODE	0x7
+#define PLL_MULTIPLIER_SHIFT	 8
+
+static void interface_clocks_enable(void)
+{
+	/* Enable all the Interconnect Modules */
+	__raw_writel(PRCM_MOD_EN, CM_PER_L3_CLKCTRL);
+	while (__raw_readl(CM_PER_L3_CLKCTRL) != PRCM_MOD_EN);
+
+	__raw_writel(PRCM_MOD_EN, CM_PER_L4LS_CLKCTRL);
+	while (__raw_readl(CM_PER_L4LS_CLKCTRL) != PRCM_MOD_EN);
+
+	__raw_writel(PRCM_MOD_EN, CM_PER_L4FW_CLKCTRL);
+	while (__raw_readl(CM_PER_L4FW_CLKCTRL) != PRCM_MOD_EN);
+
+	__raw_writel(PRCM_MOD_EN, CM_WKUP_L4WKUP_CLKCTRL);
+	while (__raw_readl(CM_WKUP_L4WKUP_CLKCTRL) != PRCM_MOD_EN);
+
+	__raw_writel(PRCM_MOD_EN, CM_PER_L3_INSTR_CLKCTRL);
+	while (__raw_readl(CM_PER_L3_INSTR_CLKCTRL) != PRCM_MOD_EN);
+
+	__raw_writel(PRCM_MOD_EN, CM_PER_L4HS_CLKCTRL);
+	while (__raw_readl(CM_PER_L4HS_CLKCTRL) != PRCM_MOD_EN);
+
+	__raw_writel(PRCM_MOD_EN, CM_PER_SPI1_CLKCTRL);
+	while (__raw_readl(CM_PER_SPI1_CLKCTRL) != PRCM_MOD_EN);
+
+	/* GPIO0 */
+	__raw_writel(PRCM_MOD_EN, CM_WKUP_GPIO0_CLKCTRL);
+	while (__raw_readl(CM_WKUP_GPIO0_CLKCTRL) != PRCM_MOD_EN);
+}
+
+static void power_domain_transition_enable(void)
+{
+	/*
+	 * Force power domain wake up transition
+	 * Ensure that the corresponding interface clock is active before
+	 * using the peripheral
+	 */
+	__raw_writel(PRCM_FORCE_WAKEUP, CM_PER_L3_CLKSTCTRL);
+
+	__raw_writel(PRCM_FORCE_WAKEUP, CM_PER_L4LS_CLKSTCTRL);
+
+	__raw_writel(PRCM_FORCE_WAKEUP, CM_WKUP_CLKSTCTRL);
+
+	__raw_writel(PRCM_FORCE_WAKEUP, CM_PER_L4FW_CLKSTCTRL);
+
+	__raw_writel(PRCM_FORCE_WAKEUP, CM_PER_L3S_CLKSTCTRL);
+}
+
+/*
+ * Enable the module clock and the power domain for required peripherals
+ */
+static void per_clocks_enable(void)
+{
+	/* Enable the module clock */
+	__raw_writel(PRCM_MOD_EN, CM_PER_TIMER2_CLKCTRL);
+	while (__raw_readl(CM_PER_TIMER2_CLKCTRL) != PRCM_MOD_EN);
+
+	/* Select the Master osc 24 MHZ as Timer2 clock source */
+	__raw_writel(0x1, CLKSEL_TIMER2_CLK);
+
+	/* UART0 */
+	__raw_writel(PRCM_MOD_EN, CM_WKUP_UART0_CLKCTRL);
+	while (__raw_readl(CM_WKUP_UART0_CLKCTRL) != PRCM_MOD_EN);
+
+	/* UART3 */
+	__raw_writel(PRCM_MOD_EN, CM_PER_UART3_CLKCTRL);
+	while (__raw_readl(CM_PER_UART3_CLKCTRL) != PRCM_MOD_EN);
+
+	/* GPMC */
+	__raw_writel(PRCM_MOD_EN, CM_PER_GPMC_CLKCTRL);
+	while (__raw_readl(CM_PER_GPMC_CLKCTRL) != PRCM_MOD_EN);
+
+	/* ELM */
+	__raw_writel(PRCM_MOD_EN, CM_PER_ELM_CLKCTRL);
+	while (__raw_readl(CM_PER_ELM_CLKCTRL) != PRCM_MOD_EN);
+
+	/* i2c0 */
+	__raw_writel(PRCM_MOD_EN, CM_WKUP_I2C0_CLKCTRL);
+	while (__raw_readl(CM_WKUP_I2C0_CLKCTRL) != PRCM_MOD_EN);
+
+	/* i2c1 */
+	__raw_writel(PRCM_MOD_EN, CM_PER_I2C1_CLKCTRL);
+	while (__raw_readl(CM_PER_I2C1_CLKCTRL) != PRCM_MOD_EN);
+
+	/* i2c2 */
+	__raw_writel(PRCM_MOD_EN, CM_PER_I2C2_CLKCTRL);
+	while (__raw_readl(CM_PER_I2C2_CLKCTRL) != PRCM_MOD_EN);
+
+	/* Ethernet */
+	__raw_writel(PRCM_MOD_EN, CM_PER_CPGMAC0_CLKCTRL);
+	__raw_writel(PRCM_MOD_EN, CM_PER_CPSW_CLKSTCTRL);
+	while ((__raw_readl(CM_PER_CPGMAC0_CLKCTRL) & 0x30000) != 0x0);
+
+	/* MMC 0 & 1 */
+	__raw_writel(PRCM_MOD_EN, CM_PER_MMC0_CLKCTRL);
+	while (__raw_readl(CM_PER_MMC0_CLKCTRL) != PRCM_MOD_EN);
+	__raw_writel(PRCM_MOD_EN, CM_PER_MMC1_CLKCTRL);
+	while (__raw_readl(CM_PER_MMC1_CLKCTRL) != PRCM_MOD_EN);
+
+	/* Enable the control module though RBL would have done it*/
+	__raw_writel(PRCM_MOD_EN, CM_WKUP_CONTROL_CLKCTRL);
+	while (__raw_readl(CM_WKUP_CONTROL_CLKCTRL) != PRCM_MOD_EN);
+
+	/* SPI 0 & 1 */
+	__raw_writel(PRCM_MOD_EN, CM_PER_SPI0_CLKCTRL);
+	while (__raw_readl(CM_PER_SPI0_CLKCTRL) != PRCM_MOD_EN);
+
+	__raw_writel(PRCM_MOD_EN, CM_PER_SPI1_CLKCTRL);
+	while (__raw_readl(CM_PER_SPI1_CLKCTRL) != PRCM_MOD_EN);
+}
+
+void mpu_pll_config(int mpupll_M)
+{
+	u32 clkmode, clksel, div_m2;
+
+	clkmode = __raw_readl(CM_CLKMODE_DPLL_MPU);
+	clksel = __raw_readl(CM_CLKSEL_DPLL_MPU);
+	div_m2 = __raw_readl(CM_DIV_M2_DPLL_MPU);
+
+	/* Set the PLL to bypass Mode */
+	__raw_writel(PLL_BYPASS_MODE, CM_CLKMODE_DPLL_MPU);
+
+	while(__raw_readl(CM_IDLEST_DPLL_MPU) != 0x00000100);
+
+	clksel = clksel & (~0x7ffff);
+	clksel = clksel | ((mpupll_M << 0x8) | MPUPLL_N);
+	__raw_writel(clksel, CM_CLKSEL_DPLL_MPU);
+
+	div_m2 = div_m2 & ~0x1f;
+	div_m2 = div_m2 | MPUPLL_M2;
+	__raw_writel(div_m2, CM_DIV_M2_DPLL_MPU);
+
+	clkmode = clkmode | 0x7;
+	__raw_writel(clkmode, CM_CLKMODE_DPLL_MPU);
+
+	while(__raw_readl(CM_IDLEST_DPLL_MPU) != 0x1);
+}
+
+static void core_pll_config(void)
+{
+	u32 clkmode, clksel, div_m4, div_m5, div_m6;
+
+	clkmode = __raw_readl(CM_CLKMODE_DPLL_CORE);
+	clksel = __raw_readl(CM_CLKSEL_DPLL_CORE);
+	div_m4 = __raw_readl(CM_DIV_M4_DPLL_CORE);
+	div_m5 = __raw_readl(CM_DIV_M5_DPLL_CORE);
+	div_m6 = __raw_readl(CM_DIV_M6_DPLL_CORE);
+
+	/* Set the PLL to bypass Mode */
+	__raw_writel(PLL_BYPASS_MODE, CM_CLKMODE_DPLL_CORE);
+
+	while(__raw_readl(CM_IDLEST_DPLL_CORE) != 0x00000100);
+
+	clksel = clksel & (~0x7ffff);
+	clksel = clksel | ((COREPLL_M << 0x8) | COREPLL_N);
+	__raw_writel(clksel, CM_CLKSEL_DPLL_CORE);
+
+	div_m4 = div_m4 & ~0x1f;
+	div_m4 = div_m4 | COREPLL_M4;
+	__raw_writel(div_m4, CM_DIV_M4_DPLL_CORE);
+
+	div_m5 = div_m5 & ~0x1f;
+	div_m5 = div_m5 | COREPLL_M5;
+	__raw_writel(div_m5, CM_DIV_M5_DPLL_CORE);
+
+	div_m6 = div_m6 & ~0x1f;
+	div_m6 = div_m6 | COREPLL_M6;
+	__raw_writel(div_m6, CM_DIV_M6_DPLL_CORE);
+
+
+	clkmode = clkmode | 0x7;
+	__raw_writel(clkmode, CM_CLKMODE_DPLL_CORE);
+
+	while(__raw_readl(CM_IDLEST_DPLL_CORE) != 0x1);
+}
+
+static void per_pll_config(void)
+{
+	u32 clkmode, clksel, div_m2;
+
+	clkmode = __raw_readl(CM_CLKMODE_DPLL_PER);
+	clksel = __raw_readl(CM_CLKSEL_DPLL_PER);
+	div_m2 = __raw_readl(CM_DIV_M2_DPLL_PER);
+
+	/* Set the PLL to bypass Mode */
+	__raw_writel(PLL_BYPASS_MODE, CM_CLKMODE_DPLL_PER);
+
+	while(__raw_readl(CM_IDLEST_DPLL_PER) != 0x00000100);
+
+	clksel = clksel & (~0x7ffff);
+	clksel = clksel | ((PERPLL_M << 0x8) | PERPLL_N);
+	__raw_writel(clksel, CM_CLKSEL_DPLL_PER);
+
+	div_m2 = div_m2 & ~0x7f;
+	div_m2 = div_m2 | PERPLL_M2;
+	__raw_writel(div_m2, CM_DIV_M2_DPLL_PER);
+
+	clkmode = clkmode | 0x7;
+	__raw_writel(clkmode, CM_CLKMODE_DPLL_PER);
+
+	while(__raw_readl(CM_IDLEST_DPLL_PER) != 0x1);
+}
+
+static void ddr_pll_config(void)
+{
+	u32 clkmode, clksel, div_m2;
+
+	clkmode = __raw_readl(CM_CLKMODE_DPLL_DDR);
+	clksel = __raw_readl(CM_CLKSEL_DPLL_DDR);
+	div_m2 = __raw_readl(CM_DIV_M2_DPLL_DDR);
+
+	/* Set the PLL to bypass Mode */
+	clkmode = (clkmode & 0xfffffff8) | 0x00000004;
+	__raw_writel(clkmode, CM_CLKMODE_DPLL_DDR);
+
+	while ((__raw_readl(CM_IDLEST_DPLL_DDR) & 0x00000100) != 0x00000100);
+
+	clksel = clksel & (~0x7ffff);
+	clksel = clksel | ((DDRPLL_M << 0x8) | DDRPLL_N);
+	__raw_writel(clksel, CM_CLKSEL_DPLL_DDR);
+
+	div_m2 = div_m2 & 0xFFFFFFE0;
+	div_m2 = div_m2 | DDRPLL_M2;
+	__raw_writel(div_m2, CM_DIV_M2_DPLL_DDR);
+
+	clkmode = (clkmode & 0xfffffff8) | 0x7;
+	__raw_writel(clkmode, CM_CLKMODE_DPLL_DDR);
+
+	while ((__raw_readl(CM_IDLEST_DPLL_DDR) & 0x00000001) != 0x1);
+}
+
+void enable_ddr_clocks(void)
+{
+	/* Enable the  EMIF_FW Functional clock */
+	__raw_writel(PRCM_MOD_EN, CM_PER_EMIF_FW_CLKCTRL);
+	/* Enable EMIF0 Clock */
+	__raw_writel(PRCM_MOD_EN, CM_PER_EMIF_CLKCTRL);
+	/* Poll for emif_gclk  & L3_G clock  are active */
+	while ((__raw_readl(CM_PER_L3_CLKSTCTRL) & (PRCM_EMIF_CLK_ACTIVITY |
+		PRCM_L3_GCLK_ACTIVITY)) != (PRCM_EMIF_CLK_ACTIVITY |
+		PRCM_L3_GCLK_ACTIVITY));
+	/* Poll if module is functional */
+	while ((__raw_readl(CM_PER_EMIF_CLKCTRL)) != PRCM_MOD_EN);
+
+}
+
+/*
+ * Configure the PLL/PRCM for necessary peripherals
+ */
+void pll_init()
+{
+	mpu_pll_config(MPUPLL_M_500);
+	core_pll_config();
+	per_pll_config();
+	ddr_pll_config();
+	/* Enable the required interconnect clocks */
+	interface_clocks_enable();
+	/* Enable power domain transition */
+	power_domain_transition_enable();
+	/* Enable the required peripherals */
+	per_clocks_enable();
+}
diff --git a/arch/arm/configs/am335x_beaglebone_defconfig b/arch/arm/configs/am335x_beaglebone_defconfig
new file mode 100644
index 0000000..a4279f1
--- /dev/null
+++ b/arch/arm/configs/am335x_beaglebone_defconfig
@@ -0,0 +1,58 @@
+CONFIG_ARCH_OMAP=y
+# CONFIG_OMAP3_CLOCK_CONFIG is not set
+# CONFIG_OMAP_GPMC is not set
+CONFIG_MACH_BEAGLEBONE=y
+CONFIG_AEABI=y
+CONFIG_ARM_OPTIMZED_STRING_FUNCTIONS=y
+CONFIG_ARM_UNWIND=y
+CONFIG_MMU=y
+CONFIG_TEXT_BASE=0x81000000
+CONFIG_KALLSYMS=y
+CONFIG_PROMPT="barebox> "
+CONFIG_LONGHELP=y
+CONFIG_HUSH_FANCY_PROMPT=y
+CONFIG_CMDLINE_EDITING=y
+CONFIG_AUTO_COMPLETE=y
+CONFIG_MENU=y
+# CONFIG_TIMESTAMP is not set
+CONFIG_DEFAULT_ENVIRONMENT_GENERIC_NEW=y
+CONFIG_DEFAULT_ENVIRONMENT_PATH="arch/arm/boards/beaglebone/env"
+CONFIG_CMD_EDIT=y
+CONFIG_CMD_SLEEP=y
+CONFIG_CMD_SAVEENV=y
+CONFIG_CMD_EXPORT=y
+CONFIG_CMD_PRINTENV=y
+CONFIG_CMD_READLINE=y
+CONFIG_CMD_MENU=y
+CONFIG_CMD_MENU_MANAGEMENT=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_BASENAME=y
+CONFIG_CMD_DIRNAME=y
+CONFIG_CMD_ECHO_E=y
+CONFIG_CMD_MEMINFO=y
+CONFIG_CMD_CRC=y
+CONFIG_CMD_CRC_CMP=y
+CONFIG_CMD_BOOTM_SHOW_TYPE=y
+CONFIG_CMD_BOOTM_VERBOSE=y
+CONFIG_CMD_BOOTM_INITRD=y
+CONFIG_CMD_BOOTM_OFTREE=y
+CONFIG_CMD_BOOTM_OFTREE_UIMAGE=y
+CONFIG_CMD_UIMAGE=y
+CONFIG_CMD_RESET=y
+CONFIG_CMD_GO=y
+CONFIG_CMD_OFTREE=y
+CONFIG_CMD_TIMEOUT=y
+CONFIG_CMD_PARTITION=y
+CONFIG_CMD_MAGICVAR=y
+CONFIG_CMD_MAGICVAR_HELP=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_UNCOMPRESS=y
+CONFIG_DRIVER_SERIAL_NS16550=y
+CONFIG_DRIVER_SERIAL_NS16550_OMAP_EXTENSIONS=y
+# CONFIG_SPI is not set
+CONFIG_MCI=y
+CONFIG_MCI_STARTUP=y
+CONFIG_MCI_OMAP_HSMMC=y
+CONFIG_FS_FAT=y
+CONFIG_FS_FAT_WRITE=y
+CONFIG_FS_FAT_LFN=y
diff --git a/arch/arm/configs/am335x_beaglebone_mlo_large_defconfig b/arch/arm/configs/am335x_beaglebone_mlo_large_defconfig
new file mode 100644
index 0000000..0a2d3a8
--- /dev/null
+++ b/arch/arm/configs/am335x_beaglebone_mlo_large_defconfig
@@ -0,0 +1,50 @@
+CONFIG_ARCH_OMAP=y
+# CONFIG_OMAP3_CLOCK_CONFIG is not set
+# CONFIG_OMAP_GPMC is not set
+CONFIG_OMAP_BUILD_IFT=y
+CONFIG_MACH_BEAGLEBONE=y
+CONFIG_AEABI=y
+CONFIG_THUMB2_BAREBOX=y
+CONFIG_MMU=y
+CONFIG_TEXT_BASE=0x402F0400
+CONFIG_MEMORY_LAYOUT_FIXED=y
+CONFIG_STACK_BASE=0x4030B800
+CONFIG_STACK_SIZE=0x1600
+CONFIG_MALLOC_BASE=0x8F000000
+CONFIG_MALLOC_SIZE=0x1000000
+CONFIG_PROMPT="MLO>"
+CONFIG_LONGHELP=y
+# CONFIG_ERRNO_MESSAGES is not set
+# CONFIG_TIMESTAMP is not set
+CONFIG_DEFAULT_ENVIRONMENT_GENERIC=y
+CONFIG_DEFAULT_ENVIRONMENT_PATH="arch/arm/boards/beaglebone/env"
+CONFIG_CMD_EXPORT=y
+# CONFIG_CMD_RM is not set
+# CONFIG_CMD_CAT is not set
+# CONFIG_CMD_RMDIR is not set
+# CONFIG_CMD_CP is not set
+# CONFIG_CMD_PWD is not set
+# CONFIG_CMD_CD is not set
+# CONFIG_CMD_UMOUNT is not set
+# CONFIG_CMD_CLEAR is not set
+CONFIG_CMD_LOADB=y
+CONFIG_CMD_LOADY=y
+CONFIG_CMD_BOOTM_SHOW_TYPE=y
+CONFIG_CMD_BOOTM_VERBOSE=y
+CONFIG_CMD_BOOTM_INITRD=y
+CONFIG_CMD_BOOTM_OFTREE=y
+CONFIG_CMD_BOOTM_OFTREE_UIMAGE=y
+# CONFIG_CMD_BOOTZ is not set
+# CONFIG_CMD_BOOTU is not set
+CONFIG_CMD_GO=y
+CONFIG_CMD_TIMEOUT=y
+# CONFIG_CMD_VERSION is not set
+# CONFIG_CMD_HELP is not set
+CONFIG_DRIVER_SERIAL_NS16550=y
+CONFIG_DRIVER_SERIAL_NS16550_OMAP_EXTENSIONS=y
+# CONFIG_SPI is not set
+CONFIG_MCI=y
+CONFIG_MCI_STARTUP=y
+CONFIG_MCI_OMAP_HSMMC=y
+CONFIG_FS_FAT=y
+CONFIG_FS_FAT_LFN=y
diff --git a/arch/arm/configs/am335x_beaglebone_mlo_small_defconfig b/arch/arm/configs/am335x_beaglebone_mlo_small_defconfig
new file mode 100644
index 0000000..162e893
--- /dev/null
+++ b/arch/arm/configs/am335x_beaglebone_mlo_small_defconfig
@@ -0,0 +1,32 @@
+CONFIG_ARCH_OMAP=y
+# CONFIG_OMAP3_CLOCK_CONFIG is not set
+# CONFIG_OMAP_GPMC is not set
+CONFIG_OMAP_BUILD_IFT=y
+CONFIG_MACH_BEAGLEBONE=y
+CONFIG_AEABI=y
+CONFIG_THUMB2_BAREBOX=y
+# CONFIG_CMD_ARM_CPUINFO is not set
+CONFIG_ENVIRONMENT_VARIABLES=y
+CONFIG_MMU=y
+CONFIG_TEXT_BASE=0x402F0400
+CONFIG_MEMORY_LAYOUT_FIXED=y
+CONFIG_STACK_BASE=0x4030B800
+CONFIG_STACK_SIZE=0x1600
+CONFIG_MALLOC_BASE=0x8F000000
+CONFIG_MALLOC_SIZE=0x1000000
+CONFIG_PROMPT="MLO>"
+CONFIG_LONGHELP=y
+CONFIG_SHELL_NONE=y
+# CONFIG_ERRNO_MESSAGES is not set
+# CONFIG_TIMESTAMP is not set
+# CONFIG_DEFAULT_ENVIRONMENT is not set
+CONFIG_DRIVER_SERIAL_NS16550=y
+CONFIG_DRIVER_SERIAL_NS16550_OMAP_EXTENSIONS=y
+# CONFIG_SPI is not set
+CONFIG_MCI=y
+CONFIG_MCI_STARTUP=y
+CONFIG_MCI_OMAP_HSMMC=y
+# CONFIG_FS_RAMFS is not set
+# CONFIG_FS_DEVFS is not set
+CONFIG_FS_FAT=y
+CONFIG_FS_FAT_LFN=y
diff --git a/arch/arm/cpu/start.c b/arch/arm/cpu/start.c
index 523179d..5505ed3 100644
--- a/arch/arm/cpu/start.c
+++ b/arch/arm/cpu/start.c
@@ -22,6 +22,7 @@
 
 #include <common.h>
 #include <init.h>
+#include <io.h>
 #include <asm/barebox-arm.h>
 #include <asm/barebox-arm-head.h>
 #include <asm/system.h>
@@ -66,16 +67,22 @@ void __naked __bare_init reset(void)
 {
 	uint32_t r;
 
+    writel(0xFEED, 0x4030b000);
 	/* set the cpu to SVC32 mode */
 	__asm__ __volatile__("mrs %0, cpsr":"=r"(r));
 	r &= ~0x1f;
 	r |= 0xd3;
 	__asm__ __volatile__("msr cpsr, %0" : : "r"(r));
 
+    writel(0xFEED0000, 0x4030b000);
+    //writel(0x59, 0x44e09000);
+    writel(0xFEED0001, 0x4030b000);
+
 #ifdef CONFIG_ARCH_HAS_LOWLEVEL_INIT
-	arch_init_lowlevel();
+//arch_init_lowlevel();
 #endif
 
+    writel(0xFEED0010, 0x4030b000);
 	/* disable MMU stuff and caches */
 	r = get_cr();
 	r &= ~(CR_M | CR_C | CR_B | CR_S | CR_R | CR_V);
@@ -87,13 +94,16 @@ void __naked __bare_init reset(void)
 	r |= CR_A;
 #endif
 
+    writel(0xFEED0020, 0x4030b000);
 #ifdef __ARMEB__
 	r |= CR_B;
 #endif
 	set_cr(r);
+    writel(0xFEED0030, 0x4030b000);
 
 #ifdef CONFIG_MACH_DO_LOWLEVEL_INIT
 	board_init_lowlevel();
+    writel(0xFEED0040, 0x4030b000);
 #endif
 	board_init_lowlevel_return();
 }
@@ -112,6 +122,7 @@ void __naked __section(.text_ll_return) board_init_lowlevel_return(void)
 	 */
 	__asm__ __volatile__("1: adr %0, 1b":"=r"(addr));
 
+    writel(0xFEED0050, 0x4030b000);
 	/* Setup the stack */
 	r = STACK_BASE + STACK_SIZE - 16;
 	__asm__ __volatile__("mov sp, %0" : : "r"(r));
@@ -131,6 +142,7 @@ void __naked __section(.text_ll_return) board_init_lowlevel_return(void)
 	__asm__ __volatile__("mcr p15, 0, %0, c7, c5, 0" : : "r" (0));
 
 	/* call start_barebox with its absolute address */
+    writel(0xFEED0060, 0x4030b000);
 	r = (unsigned int)&start_barebox;
 	__asm__ __volatile__("mov pc, %0" : : "r"(r));
 }
diff --git a/arch/arm/mach-omap/Kconfig b/arch/arm/mach-omap/Kconfig
index 386c484..117b1cf 100644
--- a/arch/arm/mach-omap/Kconfig
+++ b/arch/arm/mach-omap/Kconfig
@@ -98,7 +98,8 @@ config ARCH_TEXT_BASE
 
 config BOARDINFO
 	default "Texas Instrument's SDP343x" if MACH_OMAP343xSDP
-	default "Texas Instrument's Beagle" if MACH_BEAGLE
+	default "Texas Instrument's Beagle Board" if MACH_BEAGLE
+	default "Texas Instrument's Beagle Bone" if MACH_BEAGLEBONE
 	default "Texas Instrument's OMAP3EVM" if MACH_OMAP3EVM
 	default "Texas Instrument's Panda" if MACH_PANDA
 	default "Phytec phyCORE pcm049" if MACH_PCM049
@@ -123,6 +124,14 @@ config MACH_BEAGLE
 	  help
 	  Say Y here if you are using Beagle Board
 
+config MACH_BEAGLEBONE
+	bool "Texas Instrument's Beagle Bone"
+	select OMAP_CLOCK_ALL
+	select HAVE_NOSHELL
+	depends on ARCH_OMAP3
+	  help
+	  Say Y here if you are using Beagle Bone
+
 config MACH_OMAP3EVM
 	bool "Texas Instrument's OMAP3 EVM"
 	select OMAP_CLOCK_ALL
diff --git a/arch/arm/mach-omap/omap3_generic.c b/arch/arm/mach-omap/omap3_generic.c
index 4ab265a..ccc4bdd 100644
--- a/arch/arm/mach-omap/omap3_generic.c
+++ b/arch/arm/mach-omap/omap3_generic.c
@@ -57,6 +57,7 @@
  *
  * @return void
  */
+#if 0
 void __noreturn reset_cpu(unsigned long addr)
 {
 	writel(PRM_RSTCTRL_RESET, PRM_REG(RSTCTRL));
@@ -64,6 +65,7 @@ void __noreturn reset_cpu(unsigned long addr)
 	while (1);
 }
 EXPORT_SYMBOL(reset_cpu);
+#endif
 
 /**
  * @brief Low level CPU type
diff --git a/arch/arm/mach-omap/s32k_clksource.c b/arch/arm/mach-omap/s32k_clksource.c
index 3ed9448..2c21fe7 100644
--- a/arch/arm/mach-omap/s32k_clksource.c
+++ b/arch/arm/mach-omap/s32k_clksource.c
@@ -50,7 +50,8 @@
  */
 static uint64_t s32k_clocksource_read(void)
 {
-	return readl(S32K_CR);
+//	return readl(S32K_CR);
+    return readl(0x44e0503c);
 }
 
 /* A bit obvious isn't it? */
@@ -73,6 +74,8 @@ static int s32k_clocksource_init(void)
 {
 	s32k_cs.mult = clocksource_hz2mult(S32K_FREQUENCY, s32k_cs.shift);
 
+    writel(0x00000003, 0x44e05038);
+
 	return init_clock(&s32k_cs);
 }
 
diff --git a/arch/arm/mach-omap/xload.c b/arch/arm/mach-omap/xload.c
index 13024ab..29daaaf 100644
--- a/arch/arm/mach-omap/xload.c
+++ b/arch/arm/mach-omap/xload.c
@@ -56,7 +56,10 @@ void *omap_xload_boot_mmc(void)
 
 enum omap_boot_src omap_bootsrc(void)
 {
-#if defined(CONFIG_ARCH_OMAP3)
+#if defined(CONFIG_MACH_BEAGLEBONE)
+    /* only support for MMC */
+    return OMAP_BOOTSRC_MMC1;
+#elif defined(CONFIG_ARCH_OMAP3)
 	return omap3_bootsrc();
 #elif defined(CONFIG_ARCH_OMAP4)
 	return omap4_bootsrc();
diff --git a/common/startup.c b/common/startup.c
index abd1b77..4a2ef49 100644
--- a/common/startup.c
+++ b/common/startup.c
@@ -31,6 +31,7 @@
  */
 #include <common.h>
 #include <init.h>
+#include <io.h>
 #include <command.h>
 #include <malloc.h>
 #include <memory.h>
@@ -122,10 +123,14 @@ void start_barebox (void)
 	for (initcall = __barebox_initcalls_start;
 			initcall < __barebox_initcalls_end; initcall++) {
 		debug("initcall-> %pS\n", *initcall);
+        writel(initcall, 0x4030b004);
+        writel(0xFEED0070, 0x4030b000);
 		result = (*initcall)();
 		debug("initcall<- %pS (%d)\n", *initcall, result);
 	}
 
+    //writel(r, 0x4030b004);
+    //writel(0xFEED02FF, 0x4030b000); while(1);
 	debug("initcalls done\n");
 
 	display_meminfo();
-- 
1.7.10.4

