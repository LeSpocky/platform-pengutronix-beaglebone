From 7796108c5baab0bf854fed60348598bd3b6eef9f Mon Sep 17 00:00:00 2001
From: Jan Luebbe <jlu@pengutronix.de>
Date: Thu, 13 Dec 2012 17:30:48 +0100
Subject: [PATCH] arm: beaglebone: add first-stage support for AM335x and
 board

Signed-off-by: Jan Luebbe <jlu@pengutronix.de>
Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
---
 arch/arm/Makefile                                  |    1 +
 arch/arm/boards/beaglebone/Makefile                |    1 +
 arch/arm/boards/beaglebone/board.c                 |  358 ++++++++++++++
 arch/arm/boards/beaglebone/config.h                |   17 +
 arch/arm/boards/beaglebone/env/boot/sd             |   11 +
 arch/arm/boards/beaglebone/env/config              |   21 +
 arch/arm/configs/am335x_beaglebone_defconfig       |   54 +++
 .../configs/am335x_beaglebone_mlo_large_defconfig  |   55 +++
 .../configs/am335x_beaglebone_mlo_small_defconfig  |   31 ++
 arch/arm/mach-omap/Kconfig                         |   11 +-
 arch/arm/mach-omap/Makefile                        |    2 +-
 arch/arm/mach-omap/am33xx_clock.c                  |  289 +++++++++++
 arch/arm/mach-omap/am33xx_generic.c                |   68 +++
 arch/arm/mach-omap/am33xx_mux.c                    |  506 ++++++++++++++++++++
 arch/arm/mach-omap/gpmc.c                          |    3 +
 arch/arm/mach-omap/include/mach/am33xx-clock.h     |  171 +++++++
 arch/arm/mach-omap/include/mach/am33xx-devices.h   |   32 ++
 arch/arm/mach-omap/include/mach/am33xx-mux.h       |   22 +
 arch/arm/mach-omap/include/mach/am33xx-silicon.h   |  115 +++++
 arch/arm/mach-omap/include/mach/wdt.h              |    2 +
 arch/arm/mach-omap/include/mach/xload.h            |    1 +
 arch/arm/mach-omap/xload.c                         |    2 +
 22 files changed, 1771 insertions(+), 2 deletions(-)
 create mode 100644 arch/arm/boards/beaglebone/Makefile
 create mode 100644 arch/arm/boards/beaglebone/board.c
 create mode 100644 arch/arm/boards/beaglebone/config.h
 create mode 100644 arch/arm/boards/beaglebone/env/boot/sd
 create mode 100644 arch/arm/boards/beaglebone/env/config
 create mode 100644 arch/arm/configs/am335x_beaglebone_defconfig
 create mode 100644 arch/arm/configs/am335x_beaglebone_mlo_large_defconfig
 create mode 100644 arch/arm/configs/am335x_beaglebone_mlo_small_defconfig
 create mode 100644 arch/arm/mach-omap/am33xx_clock.c
 create mode 100644 arch/arm/mach-omap/am33xx_mux.c
 create mode 100644 arch/arm/mach-omap/include/mach/am33xx-devices.h
 create mode 100644 arch/arm/mach-omap/include/mach/am33xx-mux.h

diff --git a/arch/arm/Makefile b/arch/arm/Makefile
index 3bd645f..5082a13 100644
--- a/arch/arm/Makefile
+++ b/arch/arm/Makefile
@@ -103,6 +103,7 @@ board-$(CONFIG_MACH_NOMADIK_8815NHK)		:= nhk8815
 board-$(CONFIG_MACH_NXDB500)			:= netx
 board-$(CONFIG_MACH_OMAP343xSDP)		:= omap343xdsp
 board-$(CONFIG_MACH_BEAGLE)			:= beagle
+board-$(CONFIG_MACH_BEAGLEBONE)			:= beaglebone
 board-$(CONFIG_MACH_OMAP3EVM)			:= omap3evm
 board-$(CONFIG_MACH_PANDA)			:= panda
 board-$(CONFIG_MACH_ARCHOSG9)			:= archosg9
diff --git a/arch/arm/boards/beaglebone/Makefile b/arch/arm/boards/beaglebone/Makefile
new file mode 100644
index 0000000..dcfc293
--- /dev/null
+++ b/arch/arm/boards/beaglebone/Makefile
@@ -0,0 +1 @@
+obj-y += board.o
diff --git a/arch/arm/boards/beaglebone/board.c b/arch/arm/boards/beaglebone/board.c
new file mode 100644
index 0000000..d139e94
--- /dev/null
+++ b/arch/arm/boards/beaglebone/board.c
@@ -0,0 +1,358 @@
+/*
+ * (C) Copyright 2008
+ * Texas Instruments, <www.ti.com>
+ * Raghavendra KH <r-khandenahally@ti.com>
+ *
+ * Copyright (C) 2012 Jan Luebbe <j.luebbe@pengutronix.de>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/**
+ * @file
+ * @brief BeagleBone Specific Board Initialization routines
+ */
+
+#include <common.h>
+#include <console.h>
+#include <init.h>
+#include <driver.h>
+#include <fs.h>
+#include <linux/stat.h>
+#include <environment.h>
+#include <sizes.h>
+#include <io.h>
+#include <ns16550.h>
+#include <asm/armlinux.h>
+#include <generated/mach-types.h>
+#include <mach/am33xx-silicon.h>
+#include <mach/am33xx-clock.h>
+#include <mach/sdrc.h>
+#include <mach/sys_info.h>
+#include <mach/syslib.h>
+#include <mach/gpmc.h>
+#include <mach/ehci.h>
+#include <i2c/i2c.h>
+#include <linux/err.h>
+#include <usb/ehci.h>
+#include <mach/xload.h>
+#include <mach/am33xx-devices.h>
+#include <mach/am33xx-mux.h>
+#include <mach/cpsw.h>
+#include <mach/wdt.h>
+
+/* UART Defines */
+#define UART_SYSCFG_OFFSET  (0x54)
+#define UART_SYSSTS_OFFSET  (0x58)
+
+#define UART_RESET      (0x1 << 1)
+#define UART_CLK_RUNNING_MASK   0x1
+#define UART_SMART_IDLE_EN  (0x1 << 0x3)
+
+/* AM335X EMIF Register values */
+#define EMIF_SDMGT		0x80000000
+#define EMIF_SDRAM		0x00004650
+#define EMIF_PHYCFG		0x2
+#define DDR_PHY_RESET		(0x1 << 10)
+#define DDR_FUNCTIONAL_MODE_EN	0x1
+#define DDR_PHY_READY		(0x1 << 2)
+#define	VTP_CTRL_READY		(0x1 << 5)
+#define VTP_CTRL_ENABLE		(0x1 << 6)
+#define VTP_CTRL_LOCK_EN	(0x1 << 4)
+#define VTP_CTRL_START_EN	(0x1)
+#define DDR2_RATIO		0x80	/* for mDDR */
+#define CMD_FORCE		0x00	/* common #def */
+#define CMD_DELAY		0x00
+
+#define EMIF_READ_LATENCY	0x05
+#define EMIF_TIM1		0x0666B3D6
+#define EMIF_TIM2		0x143731DA
+#define	EMIF_TIM3		0x00000347
+#define EMIF_SDCFG		0x43805332
+#define EMIF_SDREF		0x0000081a
+#define DDR2_DLL_LOCK_DIFF	0x0
+#define DDR2_RD_DQS		0x12
+#define DDR2_PHY_FIFO_WE	0x80
+
+#define	DDR2_INVERT_CLKOUT	0x00
+#define	DDR2_WR_DQS		0x00
+#define	DDR2_PHY_WRLVL		0x00
+#define	DDR2_PHY_GATELVL	0x00
+#define	DDR2_PHY_WR_DATA	0x40
+#define	PHY_RANK0_DELAY		0x01
+#define PHY_DLL_LOCK_DIFF	0x0
+#define DDR_IOCTRL_VALUE	0x18B
+
+static void beaglebone_data_macro_config(int dataMacroNum)
+{
+	u32 BaseAddrOffset = 0x00;;
+
+	if (dataMacroNum == 1)
+		BaseAddrOffset = 0xA4;
+
+	__raw_writel(((DDR2_RD_DQS<<30)|(DDR2_RD_DQS<<20)
+		|(DDR2_RD_DQS<<10)|(DDR2_RD_DQS<<0)),
+		(AM33XX_DATA0_RD_DQS_SLAVE_RATIO_0 + BaseAddrOffset));
+	__raw_writel(DDR2_RD_DQS>>2,
+		(AM33XX_DATA0_RD_DQS_SLAVE_RATIO_1 + BaseAddrOffset));
+	__raw_writel(((DDR2_WR_DQS<<30)|(DDR2_WR_DQS<<20)
+		|(DDR2_WR_DQS<<10)|(DDR2_WR_DQS<<0)),
+		(AM33XX_DATA0_WR_DQS_SLAVE_RATIO_0 + BaseAddrOffset));
+	__raw_writel(DDR2_WR_DQS>>2,
+		(AM33XX_DATA0_WR_DQS_SLAVE_RATIO_1 + BaseAddrOffset));
+	__raw_writel(((DDR2_PHY_WRLVL<<30)|(DDR2_PHY_WRLVL<<20)
+		|(DDR2_PHY_WRLVL<<10)|(DDR2_PHY_WRLVL<<0)),
+		(AM33XX_DATA0_WRLVL_INIT_RATIO_0 + BaseAddrOffset));
+	__raw_writel(DDR2_PHY_WRLVL>>2,
+		(AM33XX_DATA0_WRLVL_INIT_RATIO_1 + BaseAddrOffset));
+	__raw_writel(((DDR2_PHY_GATELVL<<30)|(DDR2_PHY_GATELVL<<20)
+		|(DDR2_PHY_GATELVL<<10)|(DDR2_PHY_GATELVL<<0)),
+		(AM33XX_DATA0_GATELVL_INIT_RATIO_0 + BaseAddrOffset));
+	__raw_writel(DDR2_PHY_GATELVL>>2,
+		(AM33XX_DATA0_GATELVL_INIT_RATIO_1 + BaseAddrOffset));
+	__raw_writel(((DDR2_PHY_FIFO_WE<<30)|(DDR2_PHY_FIFO_WE<<20)
+		|(DDR2_PHY_FIFO_WE<<10)|(DDR2_PHY_FIFO_WE<<0)),
+		(AM33XX_DATA0_FIFO_WE_SLAVE_RATIO_0 + BaseAddrOffset));
+	__raw_writel(DDR2_PHY_FIFO_WE>>2,
+		(AM33XX_DATA0_FIFO_WE_SLAVE_RATIO_1 + BaseAddrOffset));
+	__raw_writel(((DDR2_PHY_WR_DATA<<30)|(DDR2_PHY_WR_DATA<<20)
+		|(DDR2_PHY_WR_DATA<<10)|(DDR2_PHY_WR_DATA<<0)),
+		(AM33XX_DATA0_WR_DATA_SLAVE_RATIO_0 + BaseAddrOffset));
+	__raw_writel(DDR2_PHY_WR_DATA>>2,
+		(AM33XX_DATA0_WR_DATA_SLAVE_RATIO_1 + BaseAddrOffset));
+	__raw_writel(PHY_DLL_LOCK_DIFF,
+		(AM33XX_DATA0_DLL_LOCK_DIFF_0 + BaseAddrOffset));
+}
+
+static void beaglebone_cmd_macro_config(void)
+{
+	__raw_writel(DDR2_RATIO, AM33XX_CMD0_CTRL_SLAVE_RATIO_0);
+	__raw_writel(CMD_FORCE, AM33XX_CMD0_CTRL_SLAVE_FORCE_0);
+	__raw_writel(CMD_DELAY, AM33XX_CMD0_CTRL_SLAVE_DELAY_0);
+	__raw_writel(DDR2_DLL_LOCK_DIFF, AM33XX_CMD0_DLL_LOCK_DIFF_0);
+	__raw_writel(DDR2_INVERT_CLKOUT, AM33XX_CMD0_INVERT_CLKOUT_0);
+
+	__raw_writel(DDR2_RATIO, AM33XX_CMD1_CTRL_SLAVE_RATIO_0);
+	__raw_writel(CMD_FORCE, AM33XX_CMD1_CTRL_SLAVE_FORCE_0);
+	__raw_writel(CMD_DELAY, AM33XX_CMD1_CTRL_SLAVE_DELAY_0);
+	__raw_writel(DDR2_DLL_LOCK_DIFF, AM33XX_CMD1_DLL_LOCK_DIFF_0);
+	__raw_writel(DDR2_INVERT_CLKOUT, AM33XX_CMD1_INVERT_CLKOUT_0);
+
+	__raw_writel(DDR2_RATIO, AM33XX_CMD2_CTRL_SLAVE_RATIO_0);
+	__raw_writel(CMD_FORCE, AM33XX_CMD2_CTRL_SLAVE_FORCE_0);
+	__raw_writel(CMD_DELAY, AM33XX_CMD2_CTRL_SLAVE_DELAY_0);
+	__raw_writel(DDR2_DLL_LOCK_DIFF, AM33XX_CMD2_DLL_LOCK_DIFF_0);
+	__raw_writel(DDR2_INVERT_CLKOUT, AM33XX_CMD2_INVERT_CLKOUT_0);
+}
+
+static void beaglebone_config_vtp(void)
+{
+	__raw_writel(__raw_readl(AM33XX_VTP0_CTRL_REG) | VTP_CTRL_ENABLE,
+		AM33XX_VTP0_CTRL_REG);
+	__raw_writel(__raw_readl(AM33XX_VTP0_CTRL_REG) & (~VTP_CTRL_START_EN),
+		AM33XX_VTP0_CTRL_REG);
+	__raw_writel(__raw_readl(AM33XX_VTP0_CTRL_REG) | VTP_CTRL_START_EN,
+		AM33XX_VTP0_CTRL_REG);
+
+	/* Poll for READY */
+	while ((__raw_readl(AM33XX_VTP0_CTRL_REG) & VTP_CTRL_READY) != VTP_CTRL_READY);
+}
+
+static void beaglebone_config_emif_ddr2(void)
+{
+	u32 i;
+
+	/*Program EMIF0 CFG Registers*/
+	__raw_writel(EMIF_READ_LATENCY, AM33XX_EMIF4_0_REG(DDR_PHY_CTRL_1));
+	__raw_writel(EMIF_READ_LATENCY, AM33XX_EMIF4_0_REG(DDR_PHY_CTRL_1_SHADOW));
+	__raw_writel(EMIF_READ_LATENCY, AM33XX_EMIF4_0_REG(DDR_PHY_CTRL_2));
+	__raw_writel(EMIF_TIM1, AM33XX_EMIF4_0_REG(SDRAM_TIM_1));
+	__raw_writel(EMIF_TIM1, AM33XX_EMIF4_0_REG(SDRAM_TIM_1_SHADOW));
+	__raw_writel(EMIF_TIM2, AM33XX_EMIF4_0_REG(SDRAM_TIM_2));
+	__raw_writel(EMIF_TIM2, AM33XX_EMIF4_0_REG(SDRAM_TIM_2_SHADOW));
+	__raw_writel(EMIF_TIM3, AM33XX_EMIF4_0_REG(SDRAM_TIM_3));
+	__raw_writel(EMIF_TIM3, AM33XX_EMIF4_0_REG(SDRAM_TIM_3_SHADOW));
+
+	__raw_writel(EMIF_SDCFG, AM33XX_EMIF4_0_REG(SDRAM_CONFIG));
+	__raw_writel(EMIF_SDCFG, AM33XX_EMIF4_0_REG(SDRAM_CONFIG2));
+
+	/* __raw_writel(EMIF_SDMGT, EMIF0_0_SDRAM_MGMT_CTRL);
+	__raw_writel(EMIF_SDMGT, EMIF0_0_SDRAM_MGMT_CTRL_SHD); */
+	__raw_writel(0x00004650, AM33XX_EMIF4_0_REG(SDRAM_REF_CTRL));
+	__raw_writel(0x00004650, AM33XX_EMIF4_0_REG(SDRAM_REF_CTRL_SHADOW));
+
+	for (i = 0; i < 5000; i++) {
+
+	}
+
+	/* __raw_writel(EMIF_SDMGT, EMIF0_0_SDRAM_MGMT_CTRL);
+	__raw_writel(EMIF_SDMGT, EMIF0_0_SDRAM_MGMT_CTRL_SHD); */
+	__raw_writel(EMIF_SDREF, AM33XX_EMIF4_0_REG(SDRAM_REF_CTRL));
+	__raw_writel(EMIF_SDREF, AM33XX_EMIF4_0_REG(SDRAM_REF_CTRL_SHADOW));
+
+	__raw_writel(EMIF_SDCFG, AM33XX_EMIF4_0_REG(SDRAM_CONFIG));
+	__raw_writel(EMIF_SDCFG, AM33XX_EMIF4_0_REG(SDRAM_CONFIG2));
+}
+
+static void beaglebone_config_ddr(void)
+{
+	enable_ddr_clocks();
+
+	beaglebone_config_vtp();
+
+	beaglebone_cmd_macro_config();
+	beaglebone_data_macro_config(0);
+	beaglebone_data_macro_config(1);
+
+	__raw_writel(PHY_RANK0_DELAY, AM33XX_DATA0_RANK0_DELAYS_0);
+	__raw_writel(PHY_RANK0_DELAY, AM33XX_DATA1_RANK0_DELAYS_0);
+
+	__raw_writel(DDR_IOCTRL_VALUE, AM33XX_DDR_CMD0_IOCTRL);
+	__raw_writel(DDR_IOCTRL_VALUE, AM33XX_DDR_CMD1_IOCTRL);
+	__raw_writel(DDR_IOCTRL_VALUE, AM33XX_DDR_CMD2_IOCTRL);
+	__raw_writel(DDR_IOCTRL_VALUE, AM33XX_DDR_DATA0_IOCTRL);
+	__raw_writel(DDR_IOCTRL_VALUE, AM33XX_DDR_DATA1_IOCTRL);
+
+	__raw_writel(__raw_readl(AM33XX_DDR_IO_CTRL) & 0xefffffff, AM33XX_DDR_IO_CTRL);
+	__raw_writel(__raw_readl(AM33XX_DDR_CKE_CTRL) | 0x00000001, AM33XX_DDR_CKE_CTRL);
+
+	beaglebone_config_emif_ddr2();
+}
+
+/*
+ * early system init of muxing and clocks.
+ */
+void beaglebone_sram_init(void)
+{
+	u32 regVal, uart_base;
+
+	/* Setup the PLLs and the clocks for the peripherals */
+	pll_init();
+
+	beaglebone_config_ddr();
+
+	/* UART softreset */
+	uart_base = AM33XX_UART0_BASE;
+
+	regVal = __raw_readl(uart_base + UART_SYSCFG_OFFSET);
+	regVal |= UART_RESET;
+	__raw_writel(regVal, (uart_base + UART_SYSCFG_OFFSET) );
+	while ((__raw_readl(uart_base + UART_SYSSTS_OFFSET) &
+		UART_CLK_RUNNING_MASK) != UART_CLK_RUNNING_MASK);
+
+	/* Disable smart idle */
+	regVal = __raw_readl((uart_base + UART_SYSCFG_OFFSET));
+	regVal |= UART_SMART_IDLE_EN;
+	__raw_writel(regVal, (uart_base + UART_SYSCFG_OFFSET));
+}
+
+
+/**
+ * @brief The basic entry point for board initialization.
+ *
+ * This is called as part of machine init (after arch init).
+ * This is again called with stack in SRAM, so not too many
+ * constructs possible here.
+ *
+ * @return void
+ */
+static int beaglebone_board_init(void)
+{
+	int in_sdram = running_in_sdram();
+
+	/* WDT1 is already running when the bootloader gets control
+	 * Disable it to avoid "random" resets
+	 */
+	__raw_writel(WDT_DISABLE_CODE1, AM33XX_WDT_REG(WSPR));
+	while(__raw_readl(AM33XX_WDT_REG(WWPS)) != 0x0);
+	__raw_writel(WDT_DISABLE_CODE2, AM33XX_WDT_REG(WSPR));
+	while(__raw_readl(AM33XX_WDT_REG(WWPS)) != 0x0);
+
+	/* Dont reconfigure SDRAM while running in SDRAM! */
+	if (!in_sdram)
+		beaglebone_sram_init();
+
+	/* Enable pin mux */
+	enable_uart0_pin_mux();
+
+	return 0;
+}
+pure_initcall(beaglebone_board_init);
+
+/******************** Board Run Time *******************/
+
+#ifdef CONFIG_DRIVER_SERIAL_NS16550
+
+/**
+ * @brief UART serial port initialization - remember to enable COM clocks in
+ * arch
+ *
+ * @return result of device registration
+ */
+static int beaglebone_console_init(void)
+{
+	am33xx_add_uart0();
+
+	return 0;
+}
+console_initcall(beaglebone_console_init);
+#endif /* CONFIG_DRIVER_SERIAL_NS16550 */
+
+static int beaglebone_mem_init(void)
+{
+	arm_add_mem_device("ram0", 0x80000000, 256 * 1024 * 1024);
+
+	return 0;
+}
+mem_initcall(beaglebone_mem_init);
+
+static int beaglebone_devices_init(void)
+{
+	am33xx_add_mmc0(NULL);
+
+	enable_i2c0_pin_mux();
+
+	armlinux_set_bootparams((void *)0x80000100);
+	armlinux_set_architecture(MACH_TYPE_BEAGLEBONE);
+
+	return 0;
+}
+device_initcall(beaglebone_devices_init);
+
+#ifdef CONFIG_DEFAULT_ENVIRONMENT
+static int beaglebone_env_init(void)
+{
+	struct stat s;
+	char *diskdev = "/dev/disk0.0";
+	int ret;
+
+	ret = stat(diskdev, &s);
+	if (ret) {
+		printf("device %s not found. Using default environment\n", diskdev);
+		return 0;
+	}
+
+	mkdir ("/boot", 0666);
+	ret = mount(diskdev, "fat", "/boot");
+	if (ret) {
+		printf("failed to mount %s\n", diskdev);
+		return 0;
+	}
+
+	if (IS_ENABLED(CONFIG_OMAP_BUILD_IFT))
+		default_environment_path = "/dev/defaultenv";
+	else
+		default_environment_path = "/boot/barebox.env";
+
+	return 0;
+}
+late_initcall(beaglebone_env_init);
+#endif
diff --git a/arch/arm/boards/beaglebone/config.h b/arch/arm/boards/beaglebone/config.h
new file mode 100644
index 0000000..252aa79
--- /dev/null
+++ b/arch/arm/boards/beaglebone/config.h
@@ -0,0 +1,17 @@
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _CONFIG_H_
+# define _CONFIG_H_
+
+#endif /* _CONFIG_H_ */
diff --git a/arch/arm/boards/beaglebone/env/boot/sd b/arch/arm/boards/beaglebone/env/boot/sd
new file mode 100644
index 0000000..dce0605
--- /dev/null
+++ b/arch/arm/boards/beaglebone/env/boot/sd
@@ -0,0 +1,11 @@
+#!/bin/sh
+
+if [ "$1" = menu ]; then
+	boot-menu-add-entry "$0" "kernel & rootfs on SD card"
+	exit
+fi
+
+global.bootm.image=/boot/uImage
+global.bootm.oftree=/boot/oftree
+#global.bootm.initrd=<path to initrd>
+global.linux.bootargs.dyn.root="root=/dev/mmcblk0p2 rootfstype=ext4 rootwait"
diff --git a/arch/arm/boards/beaglebone/env/config b/arch/arm/boards/beaglebone/env/config
new file mode 100644
index 0000000..4b7a635
--- /dev/null
+++ b/arch/arm/boards/beaglebone/env/config
@@ -0,0 +1,21 @@
+#!/bin/sh
+
+# change network settings in /env/network/eth0
+# change mtd partition settings and automountpoints in /env/init/*
+
+global.hostname=beaglebone
+
+# set to false if you do not want to have colors
+global.allow_color=true
+
+# user (used for network filenames)
+global.user=none
+
+# timeout in seconds before the default boot entry is started
+global.autoboot_timeout=3
+
+# default boot entry (one of /env/boot/*)
+global.boot.default=sd
+
+# base bootargs
+global.linux.bootargs.base="console=ttyO0,115200n8"
diff --git a/arch/arm/configs/am335x_beaglebone_defconfig b/arch/arm/configs/am335x_beaglebone_defconfig
new file mode 100644
index 0000000..2066d9c
--- /dev/null
+++ b/arch/arm/configs/am335x_beaglebone_defconfig
@@ -0,0 +1,54 @@
+CONFIG_ARCH_OMAP=y
+CONFIG_ARCH_AM33XX=y
+CONFIG_AEABI=y
+CONFIG_ARM_OPTIMZED_STRING_FUNCTIONS=y
+CONFIG_ARM_UNWIND=y
+CONFIG_MMU=y
+CONFIG_TEXT_BASE=0x81000000
+CONFIG_KALLSYMS=y
+CONFIG_PROMPT="barebox> "
+CONFIG_LONGHELP=y
+CONFIG_HUSH_FANCY_PROMPT=y
+CONFIG_CMDLINE_EDITING=y
+CONFIG_AUTO_COMPLETE=y
+CONFIG_MENU=y
+# CONFIG_TIMESTAMP is not set
+CONFIG_DEFAULT_ENVIRONMENT_GENERIC_NEW=y
+CONFIG_DEFAULT_ENVIRONMENT_PATH="arch/arm/boards/beaglebone/env"
+CONFIG_CMD_EDIT=y
+CONFIG_CMD_SLEEP=y
+CONFIG_CMD_SAVEENV=y
+CONFIG_CMD_EXPORT=y
+CONFIG_CMD_PRINTENV=y
+CONFIG_CMD_READLINE=y
+CONFIG_CMD_MENU=y
+CONFIG_CMD_MENU_MANAGEMENT=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_ECHO_E=y
+CONFIG_CMD_MEMINFO=y
+CONFIG_CMD_CRC=y
+CONFIG_CMD_CRC_CMP=y
+CONFIG_CMD_BOOTM_SHOW_TYPE=y
+CONFIG_CMD_BOOTM_VERBOSE=y
+CONFIG_CMD_BOOTM_INITRD=y
+CONFIG_CMD_BOOTM_OFTREE=y
+CONFIG_CMD_BOOTM_OFTREE_UIMAGE=y
+CONFIG_CMD_UIMAGE=y
+CONFIG_CMD_RESET=y
+CONFIG_CMD_GO=y
+CONFIG_CMD_OFTREE=y
+CONFIG_CMD_TIMEOUT=y
+CONFIG_CMD_PARTITION=y
+CONFIG_CMD_MAGICVAR=y
+CONFIG_CMD_MAGICVAR_HELP=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_UNCOMPRESS=y
+CONFIG_DRIVER_SERIAL_NS16550=y
+CONFIG_DRIVER_SERIAL_NS16550_OMAP_EXTENSIONS=y
+# CONFIG_SPI is not set
+CONFIG_MCI=y
+CONFIG_MCI_STARTUP=y
+CONFIG_MCI_OMAP_HSMMC=y
+CONFIG_FS_FAT=y
+CONFIG_FS_FAT_WRITE=y
+CONFIG_FS_FAT_LFN=y
diff --git a/arch/arm/configs/am335x_beaglebone_mlo_large_defconfig b/arch/arm/configs/am335x_beaglebone_mlo_large_defconfig
new file mode 100644
index 0000000..d90f581
--- /dev/null
+++ b/arch/arm/configs/am335x_beaglebone_mlo_large_defconfig
@@ -0,0 +1,55 @@
+CONFIG_ARCH_OMAP=y
+CONFIG_ARCH_AM33XX=y
+# CONFIG_OMAP_GPMC is not set
+CONFIG_OMAP_BUILD_IFT=y
+CONFIG_THUMB2_BAREBOX=y
+# CONFIG_CMD_ARM_CPUINFO is not set
+CONFIG_MMU=y
+CONFIG_TEXT_BASE=0x402F0400
+CONFIG_MEMORY_LAYOUT_FIXED=y
+CONFIG_STACK_BASE=0x4030B800
+CONFIG_STACK_SIZE=0x1600
+CONFIG_MALLOC_BASE=0x8F000000
+CONFIG_MALLOC_SIZE=0x1000000
+CONFIG_PROMPT="barebox> "
+CONFIG_HUSH_FANCY_PROMPT=y
+CONFIG_CMDLINE_EDITING=y
+CONFIG_AUTO_COMPLETE=y
+# CONFIG_TIMESTAMP is not set
+CONFIG_DEFAULT_ENVIRONMENT_GENERIC_NEW=y
+CONFIG_DEFAULT_ENVIRONMENT_PATH="arch/arm/boards/beaglebone/env"
+CONFIG_BAREBOXENV_TARGET=y
+CONFIG_CMD_EDIT=y
+CONFIG_CMD_SLEEP=y
+CONFIG_CMD_EXPORT=y
+CONFIG_CMD_PRINTENV=y
+CONFIG_CMD_READLINE=y
+# CONFIG_CMD_UMOUNT is not set
+# CONFIG_CMD_CLEAR is not set
+CONFIG_CMD_ECHO_E=y
+CONFIG_CMD_IOMEM=y
+CONFIG_CMD_CRC=y
+CONFIG_CMD_CRC_CMP=y
+CONFIG_CMD_BOOTM_SHOW_TYPE=y
+CONFIG_CMD_BOOTM_VERBOSE=y
+CONFIG_CMD_BOOTM_INITRD=y
+CONFIG_CMD_BOOTM_OFTREE=y
+CONFIG_CMD_BOOTM_OFTREE_UIMAGE=y
+# CONFIG_CMD_BOOTU is not set
+CONFIG_CMD_RESET=y
+CONFIG_CMD_GO=y
+CONFIG_CMD_OFTREE=y
+CONFIG_CMD_TIMEOUT=y
+# CONFIG_CMD_VERSION is not set
+CONFIG_CMD_MAGICVAR=y
+CONFIG_CMD_MAGICVAR_HELP=y
+CONFIG_DRIVER_SERIAL_NS16550=y
+CONFIG_DRIVER_SERIAL_NS16550_OMAP_EXTENSIONS=y
+# CONFIG_SPI is not set
+CONFIG_MCI=y
+CONFIG_MCI_STARTUP=y
+# CONFIG_MCI_INFO is not set
+# CONFIG_MCI_WRITE is not set
+CONFIG_MCI_OMAP_HSMMC=y
+CONFIG_FS_FAT=y
+CONFIG_FS_FAT_LFN=y
diff --git a/arch/arm/configs/am335x_beaglebone_mlo_small_defconfig b/arch/arm/configs/am335x_beaglebone_mlo_small_defconfig
new file mode 100644
index 0000000..886dad9
--- /dev/null
+++ b/arch/arm/configs/am335x_beaglebone_mlo_small_defconfig
@@ -0,0 +1,31 @@
+CONFIG_ARCH_OMAP=y
+CONFIG_ARCH_AM33XX=y
+# CONFIG_OMAP_GPMC is not set
+CONFIG_OMAP_BUILD_IFT=y
+CONFIG_THUMB2_BAREBOX=y
+# CONFIG_CMD_ARM_CPUINFO is not set
+# CONFIG_BANNER is not set
+# CONFIG_MEMINFO is not set
+CONFIG_ENVIRONMENT_VARIABLES=y
+CONFIG_MMU=y
+CONFIG_TEXT_BASE=0x402F0400
+CONFIG_MEMORY_LAYOUT_FIXED=y
+CONFIG_STACK_BASE=0x4030B800
+CONFIG_STACK_SIZE=0x1600
+CONFIG_MALLOC_BASE=0x8F000000
+CONFIG_MALLOC_SIZE=0x1000000
+CONFIG_PROMPT="MLO>"
+CONFIG_SHELL_NONE=y
+# CONFIG_ERRNO_MESSAGES is not set
+# CONFIG_TIMESTAMP is not set
+# CONFIG_DEFAULT_ENVIRONMENT is not set
+CONFIG_DRIVER_SERIAL_NS16550=y
+CONFIG_DRIVER_SERIAL_NS16550_OMAP_EXTENSIONS=y
+# CONFIG_SPI is not set
+CONFIG_MCI=y
+CONFIG_MCI_STARTUP=y
+CONFIG_MCI_OMAP_HSMMC=y
+# CONFIG_FS_RAMFS is not set
+# CONFIG_FS_DEVFS is not set
+CONFIG_FS_FAT=y
+CONFIG_FS_FAT_LFN=y
diff --git a/arch/arm/mach-omap/Kconfig b/arch/arm/mach-omap/Kconfig
index b94500a..ae1e07e 100644
--- a/arch/arm/mach-omap/Kconfig
+++ b/arch/arm/mach-omap/Kconfig
@@ -105,7 +105,8 @@ config OMAP4_USBBOOT
 config BOARDINFO
 	default "Archos G9" if MACH_ARCHOSG9
 	default "Texas Instrument's SDP343x" if MACH_OMAP343xSDP
-	default "Texas Instrument's Beagle" if MACH_BEAGLE
+	default "Texas Instrument's Beagle Board" if MACH_BEAGLE
+	default "Texas Instrument's Beagle Bone" if MACH_BEAGLEBONE
 	default "Texas Instrument's OMAP3EVM" if MACH_OMAP3EVM
 	default "Texas Instrument's Panda" if MACH_PANDA
 	default "Phytec phyCORE pcm049" if MACH_PCM049
@@ -129,6 +130,14 @@ config MACH_BEAGLE
 	help
 	  Say Y here if you are using Beagle Board
 
+config MACH_BEAGLEBONE
+	bool "Texas Instrument's Beagle Bone"
+	select OMAP_CLOCK_ALL
+	select HAVE_NOSHELL
+	depends on ARCH_AM33XX
+	  help
+	  Say Y here if you are using Beagle Bone
+
 config MACH_OMAP3EVM
 	bool "Texas Instrument's OMAP3 EVM"
 	select HAVE_NOSHELL
diff --git a/arch/arm/mach-omap/Makefile b/arch/arm/mach-omap/Makefile
index 48a951b..94e42c6 100644
--- a/arch/arm/mach-omap/Makefile
+++ b/arch/arm/mach-omap/Makefile
@@ -23,7 +23,7 @@ obj-$(CONFIG_ARCH_OMAP3) += omap3_core.o omap3_generic.o auxcr.o
 pbl-$(CONFIG_ARCH_OMAP3) += omap3_core.o omap3_generic.o auxcr.o
 obj-$(CONFIG_ARCH_OMAP4) += omap4_generic.o omap4_clock.o
 pbl-$(CONFIG_ARCH_OMAP4) += omap4_generic.o omap4_clock.o
-obj-$(CONFIG_ARCH_AM33XX) += am33xx_generic.o
+obj-$(CONFIG_ARCH_AM33XX) += am33xx_generic.o am33xx_clock.o am33xx_mux.o
 obj-$(CONFIG_OMAP3_CLOCK_CONFIG) += omap3_clock.o
 pbl-$(CONFIG_OMAP3_CLOCK_CONFIG) += omap3_clock.o
 obj-$(CONFIG_OMAP_GPMC) += gpmc.o devices-gpmc-nand.o
diff --git a/arch/arm/mach-omap/am33xx_clock.c b/arch/arm/mach-omap/am33xx_clock.c
new file mode 100644
index 0000000..a28540c
--- /dev/null
+++ b/arch/arm/mach-omap/am33xx_clock.c
@@ -0,0 +1,289 @@
+/*
+ * pll.c
+ *
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+#include <common.h>
+#include <asm/io.h>
+#include <mach/am33xx-clock.h>
+
+#define PRCM_MOD_EN		0x2
+#define	PRCM_FORCE_WAKEUP	0x2
+
+#define PRCM_EMIF_CLK_ACTIVITY	(0x1 << 2)
+#define PRCM_L3_GCLK_ACTIVITY	(0x1 << 4)
+
+#define PLL_BYPASS_MODE	0x4
+#define PLL_LOCK_MODE	0x7
+#define PLL_MULTIPLIER_SHIFT	 8
+
+static void interface_clocks_enable(void)
+{
+	/* Enable all the Interconnect Modules */
+	__raw_writel(PRCM_MOD_EN, CM_PER_L3_CLKCTRL);
+	while (__raw_readl(CM_PER_L3_CLKCTRL) != PRCM_MOD_EN);
+
+	__raw_writel(PRCM_MOD_EN, CM_PER_L4LS_CLKCTRL);
+	while (__raw_readl(CM_PER_L4LS_CLKCTRL) != PRCM_MOD_EN);
+
+	__raw_writel(PRCM_MOD_EN, CM_PER_L4FW_CLKCTRL);
+	while (__raw_readl(CM_PER_L4FW_CLKCTRL) != PRCM_MOD_EN);
+
+	__raw_writel(PRCM_MOD_EN, CM_WKUP_L4WKUP_CLKCTRL);
+	while (__raw_readl(CM_WKUP_L4WKUP_CLKCTRL) != PRCM_MOD_EN);
+
+	__raw_writel(PRCM_MOD_EN, CM_PER_L3_INSTR_CLKCTRL);
+	while (__raw_readl(CM_PER_L3_INSTR_CLKCTRL) != PRCM_MOD_EN);
+
+	__raw_writel(PRCM_MOD_EN, CM_PER_L4HS_CLKCTRL);
+	while (__raw_readl(CM_PER_L4HS_CLKCTRL) != PRCM_MOD_EN);
+
+	__raw_writel(PRCM_MOD_EN, CM_PER_SPI1_CLKCTRL);
+	while (__raw_readl(CM_PER_SPI1_CLKCTRL) != PRCM_MOD_EN);
+
+	/* GPIO0 */
+	__raw_writel(PRCM_MOD_EN, CM_WKUP_GPIO0_CLKCTRL);
+	while (__raw_readl(CM_WKUP_GPIO0_CLKCTRL) != PRCM_MOD_EN);
+}
+
+static void power_domain_transition_enable(void)
+{
+	/*
+	 * Force power domain wake up transition
+	 * Ensure that the corresponding interface clock is active before
+	 * using the peripheral
+	 */
+	__raw_writel(PRCM_FORCE_WAKEUP, CM_PER_L3_CLKSTCTRL);
+
+	__raw_writel(PRCM_FORCE_WAKEUP, CM_PER_L4LS_CLKSTCTRL);
+
+	__raw_writel(PRCM_FORCE_WAKEUP, CM_WKUP_CLKSTCTRL);
+
+	__raw_writel(PRCM_FORCE_WAKEUP, CM_PER_L4FW_CLKSTCTRL);
+
+	__raw_writel(PRCM_FORCE_WAKEUP, CM_PER_L3S_CLKSTCTRL);
+}
+
+/*
+ * Enable the module clock and the power domain for required peripherals
+ */
+static void per_clocks_enable(void)
+{
+	/* Enable the module clock */
+	__raw_writel(PRCM_MOD_EN, CM_PER_TIMER2_CLKCTRL);
+	while (__raw_readl(CM_PER_TIMER2_CLKCTRL) != PRCM_MOD_EN);
+
+	/* Select the Master osc 24 MHZ as Timer2 clock source */
+	__raw_writel(0x1, CLKSEL_TIMER2_CLK);
+
+	/* UART0 */
+	__raw_writel(PRCM_MOD_EN, CM_WKUP_UART0_CLKCTRL);
+	while (__raw_readl(CM_WKUP_UART0_CLKCTRL) != PRCM_MOD_EN);
+
+	/* UART3 */
+	__raw_writel(PRCM_MOD_EN, CM_PER_UART3_CLKCTRL);
+	while (__raw_readl(CM_PER_UART3_CLKCTRL) != PRCM_MOD_EN);
+
+	/* GPMC */
+	__raw_writel(PRCM_MOD_EN, CM_PER_GPMC_CLKCTRL);
+	while (__raw_readl(CM_PER_GPMC_CLKCTRL) != PRCM_MOD_EN);
+
+	/* ELM */
+	__raw_writel(PRCM_MOD_EN, CM_PER_ELM_CLKCTRL);
+	while (__raw_readl(CM_PER_ELM_CLKCTRL) != PRCM_MOD_EN);
+
+	/* i2c0 */
+	__raw_writel(PRCM_MOD_EN, CM_WKUP_I2C0_CLKCTRL);
+	while (__raw_readl(CM_WKUP_I2C0_CLKCTRL) != PRCM_MOD_EN);
+
+	/* i2c1 */
+	__raw_writel(PRCM_MOD_EN, CM_PER_I2C1_CLKCTRL);
+	while (__raw_readl(CM_PER_I2C1_CLKCTRL) != PRCM_MOD_EN);
+
+	/* i2c2 */
+	__raw_writel(PRCM_MOD_EN, CM_PER_I2C2_CLKCTRL);
+	while (__raw_readl(CM_PER_I2C2_CLKCTRL) != PRCM_MOD_EN);
+
+	/* Ethernet */
+	__raw_writel(PRCM_MOD_EN, CM_PER_CPGMAC0_CLKCTRL);
+	__raw_writel(PRCM_MOD_EN, CM_PER_CPSW_CLKSTCTRL);
+	while ((__raw_readl(CM_PER_CPGMAC0_CLKCTRL) & 0x30000) != 0x0);
+
+	/* MMC 0 & 1 */
+	__raw_writel(PRCM_MOD_EN, CM_PER_MMC0_CLKCTRL);
+	while (__raw_readl(CM_PER_MMC0_CLKCTRL) != PRCM_MOD_EN);
+	__raw_writel(PRCM_MOD_EN, CM_PER_MMC1_CLKCTRL);
+	while (__raw_readl(CM_PER_MMC1_CLKCTRL) != PRCM_MOD_EN);
+
+	/* Enable the control module though RBL would have done it*/
+	__raw_writel(PRCM_MOD_EN, CM_WKUP_CONTROL_CLKCTRL);
+	while (__raw_readl(CM_WKUP_CONTROL_CLKCTRL) != PRCM_MOD_EN);
+
+	/* SPI 0 & 1 */
+	__raw_writel(PRCM_MOD_EN, CM_PER_SPI0_CLKCTRL);
+	while (__raw_readl(CM_PER_SPI0_CLKCTRL) != PRCM_MOD_EN);
+
+	__raw_writel(PRCM_MOD_EN, CM_PER_SPI1_CLKCTRL);
+	while (__raw_readl(CM_PER_SPI1_CLKCTRL) != PRCM_MOD_EN);
+}
+
+static void mpu_pll_config(int mpupll_M)
+{
+	u32 clkmode, clksel, div_m2;
+
+	clkmode = __raw_readl(CM_CLKMODE_DPLL_MPU);
+	clksel = __raw_readl(CM_CLKSEL_DPLL_MPU);
+	div_m2 = __raw_readl(CM_DIV_M2_DPLL_MPU);
+
+	/* Set the PLL to bypass Mode */
+	__raw_writel(PLL_BYPASS_MODE, CM_CLKMODE_DPLL_MPU);
+
+	while(__raw_readl(CM_IDLEST_DPLL_MPU) != 0x00000100);
+
+	clksel = clksel & (~0x7ffff);
+	clksel = clksel | ((mpupll_M << 0x8) | MPUPLL_N);
+	__raw_writel(clksel, CM_CLKSEL_DPLL_MPU);
+
+	div_m2 = div_m2 & ~0x1f;
+	div_m2 = div_m2 | MPUPLL_M2;
+	__raw_writel(div_m2, CM_DIV_M2_DPLL_MPU);
+
+	clkmode = clkmode | 0x7;
+	__raw_writel(clkmode, CM_CLKMODE_DPLL_MPU);
+
+	while(__raw_readl(CM_IDLEST_DPLL_MPU) != 0x1);
+}
+
+static void core_pll_config(void)
+{
+	u32 clkmode, clksel, div_m4, div_m5, div_m6;
+
+	clkmode = __raw_readl(CM_CLKMODE_DPLL_CORE);
+	clksel = __raw_readl(CM_CLKSEL_DPLL_CORE);
+	div_m4 = __raw_readl(CM_DIV_M4_DPLL_CORE);
+	div_m5 = __raw_readl(CM_DIV_M5_DPLL_CORE);
+	div_m6 = __raw_readl(CM_DIV_M6_DPLL_CORE);
+
+	/* Set the PLL to bypass Mode */
+	__raw_writel(PLL_BYPASS_MODE, CM_CLKMODE_DPLL_CORE);
+
+	while(__raw_readl(CM_IDLEST_DPLL_CORE) != 0x00000100);
+
+	clksel = clksel & (~0x7ffff);
+	clksel = clksel | ((COREPLL_M << 0x8) | COREPLL_N);
+	__raw_writel(clksel, CM_CLKSEL_DPLL_CORE);
+
+	div_m4 = div_m4 & ~0x1f;
+	div_m4 = div_m4 | COREPLL_M4;
+	__raw_writel(div_m4, CM_DIV_M4_DPLL_CORE);
+
+	div_m5 = div_m5 & ~0x1f;
+	div_m5 = div_m5 | COREPLL_M5;
+	__raw_writel(div_m5, CM_DIV_M5_DPLL_CORE);
+
+	div_m6 = div_m6 & ~0x1f;
+	div_m6 = div_m6 | COREPLL_M6;
+	__raw_writel(div_m6, CM_DIV_M6_DPLL_CORE);
+
+
+	clkmode = clkmode | 0x7;
+	__raw_writel(clkmode, CM_CLKMODE_DPLL_CORE);
+
+	while(__raw_readl(CM_IDLEST_DPLL_CORE) != 0x1);
+}
+
+static void per_pll_config(void)
+{
+	u32 clkmode, clksel, div_m2;
+
+	clkmode = __raw_readl(CM_CLKMODE_DPLL_PER);
+	clksel = __raw_readl(CM_CLKSEL_DPLL_PER);
+	div_m2 = __raw_readl(CM_DIV_M2_DPLL_PER);
+
+	/* Set the PLL to bypass Mode */
+	__raw_writel(PLL_BYPASS_MODE, CM_CLKMODE_DPLL_PER);
+
+	while(__raw_readl(CM_IDLEST_DPLL_PER) != 0x00000100);
+
+	clksel = clksel & (~0x7ffff);
+	clksel = clksel | ((PERPLL_M << 0x8) | PERPLL_N);
+	__raw_writel(clksel, CM_CLKSEL_DPLL_PER);
+
+	div_m2 = div_m2 & ~0x7f;
+	div_m2 = div_m2 | PERPLL_M2;
+	__raw_writel(div_m2, CM_DIV_M2_DPLL_PER);
+
+	clkmode = clkmode | 0x7;
+	__raw_writel(clkmode, CM_CLKMODE_DPLL_PER);
+
+	while(__raw_readl(CM_IDLEST_DPLL_PER) != 0x1);
+}
+
+static void ddr_pll_config(void)
+{
+	u32 clkmode, clksel, div_m2;
+
+	clkmode = __raw_readl(CM_CLKMODE_DPLL_DDR);
+	clksel = __raw_readl(CM_CLKSEL_DPLL_DDR);
+	div_m2 = __raw_readl(CM_DIV_M2_DPLL_DDR);
+
+	/* Set the PLL to bypass Mode */
+	clkmode = (clkmode & 0xfffffff8) | 0x00000004;
+	__raw_writel(clkmode, CM_CLKMODE_DPLL_DDR);
+
+	while ((__raw_readl(CM_IDLEST_DPLL_DDR) & 0x00000100) != 0x00000100);
+
+	clksel = clksel & (~0x7ffff);
+	clksel = clksel | ((DDRPLL_M << 0x8) | DDRPLL_N);
+	__raw_writel(clksel, CM_CLKSEL_DPLL_DDR);
+
+	div_m2 = div_m2 & 0xFFFFFFE0;
+	div_m2 = div_m2 | DDRPLL_M2;
+	__raw_writel(div_m2, CM_DIV_M2_DPLL_DDR);
+
+	clkmode = (clkmode & 0xfffffff8) | 0x7;
+	__raw_writel(clkmode, CM_CLKMODE_DPLL_DDR);
+
+	while ((__raw_readl(CM_IDLEST_DPLL_DDR) & 0x00000001) != 0x1);
+}
+
+void enable_ddr_clocks(void)
+{
+	/* Enable the  EMIF_FW Functional clock */
+	__raw_writel(PRCM_MOD_EN, CM_PER_EMIF_FW_CLKCTRL);
+	/* Enable EMIF0 Clock */
+	__raw_writel(PRCM_MOD_EN, CM_PER_EMIF_CLKCTRL);
+	/* Poll for emif_gclk  & L3_G clock  are active */
+	while ((__raw_readl(CM_PER_L3_CLKSTCTRL) & (PRCM_EMIF_CLK_ACTIVITY |
+		PRCM_L3_GCLK_ACTIVITY)) != (PRCM_EMIF_CLK_ACTIVITY |
+		PRCM_L3_GCLK_ACTIVITY));
+	/* Poll if module is functional */
+	while ((__raw_readl(CM_PER_EMIF_CLKCTRL)) != PRCM_MOD_EN);
+
+}
+
+/*
+ * Configure the PLL/PRCM for necessary peripherals
+ */
+void pll_init()
+{
+	mpu_pll_config(MPUPLL_M_500);
+	core_pll_config();
+	per_pll_config();
+	ddr_pll_config();
+	/* Enable the required interconnect clocks */
+	interface_clocks_enable();
+	/* Enable power domain transition */
+	power_domain_transition_enable();
+	/* Enable the required peripherals */
+	per_clocks_enable();
+}
diff --git a/arch/arm/mach-omap/am33xx_generic.c b/arch/arm/mach-omap/am33xx_generic.c
index f73f946..e8293f7 100644
--- a/arch/arm/mach-omap/am33xx_generic.c
+++ b/arch/arm/mach-omap/am33xx_generic.c
@@ -1,5 +1,6 @@
 /*
  * (C) Copyright 2012 Teresa Gámez, Phytec Messtechnik GmbH
+ * (C) Copyright 2012 Jan Luebbe <j.luebbe@pengutronix.de>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -20,6 +21,8 @@
 #include <io.h>
 #include <mach/am33xx-silicon.h>
 #include <mach/am33xx-clock.h>
+#include <mach/sys_info.h>
+#include <mach/xload.h>
 
 void __noreturn reset_cpu(unsigned long addr)
 {
@@ -27,3 +30,68 @@ void __noreturn reset_cpu(unsigned long addr)
 
 	while (1);
 }
+
+/**
+ * @brief Get the upper address of current execution
+ *
+ * we can use this to figure out if we are running in SRAM /
+ * XIP Flash or in SDRAM
+ *
+ * @return base address
+ */
+u32 get_base(void)
+{
+	u32 val;
+	__asm__ __volatile__("mov %0, pc \n":"=r"(val)::"memory");
+	val &= 0xF0000000;
+	val >>= 28;
+	return val;
+}
+
+/**
+ * @brief Are we running in Flash XIP?
+ *
+ * If the base is in GPMC address space, we probably are!
+ *
+ * @return 1 if we are running in XIP mode, else return 0
+ */
+u32 running_in_flash(void)
+{
+	if (get_base() < 4)
+		return 1;	/* in flash */
+	return 0;		/* running in SRAM or SDRAM */
+}
+
+/**
+ * @brief Are we running in OMAP internal SRAM?
+ *
+ * If in SRAM address, then yes!
+ *
+ * @return  1 if we are running in SRAM, else return 0
+ */
+u32 running_in_sram(void)
+{
+	if (get_base() == 4)
+		return 1;	/* in SRAM */
+	return 0;		/* running in FLASH or SDRAM */
+}
+
+/**
+ * @brief Are we running in SDRAM?
+ *
+ * if we are not in GPMC nor in SRAM address space,
+ * we are in SDRAM execution area
+ *
+ * @return 1 if we are running from SDRAM, else return 0
+ */
+u32 running_in_sdram(void)
+{
+	if (get_base() > 4)
+		return 1;	/* in sdram */
+	return 0;		/* running in SRAM or FLASH */
+}
+
+enum omap_boot_src am33xx_bootsrc(void)
+{
+	return OMAP_BOOTSRC_MMC1; /* only MMC for now */
+}
diff --git a/arch/arm/mach-omap/am33xx_mux.c b/arch/arm/mach-omap/am33xx_mux.c
new file mode 100644
index 0000000..22bf317
--- /dev/null
+++ b/arch/arm/mach-omap/am33xx_mux.c
@@ -0,0 +1,506 @@
+/*
+ * mux.c
+ *
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+#include <common.h>
+#include <config.h>
+#include <asm/io.h>
+#include <mach/am33xx-silicon.h>
+
+#define MUX_CFG(value, offset)	\
+	__raw_writel(value, (AM33XX_CTRL_BASE + offset));
+
+/* PAD Control Fields */
+#define SLEWCTRL	(0x1 << 6)
+#define	RXACTIVE	(0x1 << 5)
+#define	PULLUP_EN	(0x1 << 4) /* Pull UP Selection */
+#define PULLUDEN	(0x0 << 3) /* Pull up enabled */
+#define PULLUDDIS	(0x1 << 3) /* Pull up disabled */
+#define MODE(val)	val
+
+/*
+ * PAD CONTROL OFFSETS
+ * Field names corresponds to the pad signal name
+ */
+/* TODO replace with defines */
+struct pad_signals {
+	int gpmc_ad0;
+	int gpmc_ad1;
+	int gpmc_ad2;
+	int gpmc_ad3;
+	int gpmc_ad4;
+	int gpmc_ad5;
+	int gpmc_ad6;
+	int gpmc_ad7;
+	int gpmc_ad8;
+	int gpmc_ad9;
+	int gpmc_ad10;
+	int gpmc_ad11;
+	int gpmc_ad12;
+	int gpmc_ad13;
+	int gpmc_ad14;
+	int gpmc_ad15;
+	int gpmc_a0;
+	int gpmc_a1;
+	int gpmc_a2;
+	int gpmc_a3;
+	int gpmc_a4;
+	int gpmc_a5;
+	int gpmc_a6;
+	int gpmc_a7;
+	int gpmc_a8;
+	int gpmc_a9;
+	int gpmc_a10;
+	int gpmc_a11;
+	int gpmc_wait0;
+	int gpmc_wpn;
+	int gpmc_be1n;
+	int gpmc_csn0;
+	int gpmc_csn1;
+	int gpmc_csn2;
+	int gpmc_csn3;
+	int gpmc_clk;
+	int gpmc_advn_ale;
+	int gpmc_oen_ren;
+	int gpmc_wen;
+	int gpmc_be0n_cle;
+	int lcd_data0;
+	int lcd_data1;
+	int lcd_data2;
+	int lcd_data3;
+	int lcd_data4;
+	int lcd_data5;
+	int lcd_data6;
+	int lcd_data7;
+	int lcd_data8;
+	int lcd_data9;
+	int lcd_data10;
+	int lcd_data11;
+	int lcd_data12;
+	int lcd_data13;
+	int lcd_data14;
+	int lcd_data15;
+	int lcd_vsync;
+	int lcd_hsync;
+	int lcd_pclk;
+	int lcd_ac_bias_en;
+	int mmc0_dat3;
+	int mmc0_dat2;
+	int mmc0_dat1;
+	int mmc0_dat0;
+	int mmc0_clk;
+	int mmc0_cmd;
+	int mii1_col;
+	int mii1_crs;
+	int mii1_rxerr;
+	int mii1_txen;
+	int mii1_rxdv;
+	int mii1_txd3;
+	int mii1_txd2;
+	int mii1_txd1;
+	int mii1_txd0;
+	int mii1_txclk;
+	int mii1_rxclk;
+	int mii1_rxd3;
+	int mii1_rxd2;
+	int mii1_rxd1;
+	int mii1_rxd0;
+	int rmii1_refclk;
+	int mdio_data;
+	int mdio_clk;
+	int spi0_sclk;
+	int spi0_d0;
+	int spi0_d1;
+	int spi0_cs0;
+	int spi0_cs1;
+	int ecap0_in_pwm0_out;
+	int uart0_ctsn;
+	int uart0_rtsn;
+	int uart0_rxd;
+	int uart0_txd;
+	int uart1_ctsn;
+	int uart1_rtsn;
+	int uart1_rxd;
+	int uart1_txd;
+	int i2c0_sda;
+	int i2c0_scl;
+	int mcasp0_aclkx;
+	int mcasp0_fsx;
+	int mcasp0_axr0;
+	int mcasp0_ahclkr;
+	int mcasp0_aclkr;
+	int mcasp0_fsr;
+	int mcasp0_axr1;
+	int mcasp0_ahclkx;
+	int xdma_event_intr0;
+	int xdma_event_intr1;
+	int nresetin_out;
+	int porz;
+	int nnmi;
+	int osc0_in;
+	int osc0_out;
+	int rsvd1;
+	int tms;
+	int tdi;
+	int tdo;
+	int tck;
+	int ntrst;
+	int emu0;
+	int emu1;
+	int osc1_in;
+	int osc1_out;
+	int pmic_power_en;
+	int rtc_porz;
+	int rsvd2;
+	int ext_wakeup;
+	int enz_kaldo_1p8v;
+	int usb0_dm;
+	int usb0_dp;
+	int usb0_ce;
+	int usb0_id;
+	int usb0_vbus;
+	int usb0_drvvbus;
+	int usb1_dm;
+	int usb1_dp;
+	int usb1_ce;
+	int usb1_id;
+	int usb1_vbus;
+	int usb1_drvvbus;
+	int ddr_resetn;
+	int ddr_csn0;
+	int ddr_cke;
+	int ddr_ck;
+	int ddr_nck;
+	int ddr_casn;
+	int ddr_rasn;
+	int ddr_wen;
+	int ddr_ba0;
+	int ddr_ba1;
+	int ddr_ba2;
+	int ddr_a0;
+	int ddr_a1;
+	int ddr_a2;
+	int ddr_a3;
+	int ddr_a4;
+	int ddr_a5;
+	int ddr_a6;
+	int ddr_a7;
+	int ddr_a8;
+	int ddr_a9;
+	int ddr_a10;
+	int ddr_a11;
+	int ddr_a12;
+	int ddr_a13;
+	int ddr_a14;
+	int ddr_a15;
+	int ddr_odt;
+	int ddr_d0;
+	int ddr_d1;
+	int ddr_d2;
+	int ddr_d3;
+	int ddr_d4;
+	int ddr_d5;
+	int ddr_d6;
+	int ddr_d7;
+	int ddr_d8;
+	int ddr_d9;
+	int ddr_d10;
+	int ddr_d11;
+	int ddr_d12;
+	int ddr_d13;
+	int ddr_d14;
+	int ddr_d15;
+	int ddr_dqm0;
+	int ddr_dqm1;
+	int ddr_dqs0;
+	int ddr_dqsn0;
+	int ddr_dqs1;
+	int ddr_dqsn1;
+	int ddr_vref;
+	int ddr_vtp;
+	int ddr_strben0;
+	int ddr_strben1;
+	int ain7;
+	int ain6;
+	int ain5;
+	int ain4;
+	int ain3;
+	int ain2;
+	int ain1;
+	int ain0;
+	int vrefp;
+	int vrefn;
+};
+
+struct module_pin_mux {
+	short reg_offset;
+	unsigned char val;
+};
+
+#define PAD_CTRL_BASE	0x800
+#define OFFSET(x)	(unsigned int) (&((struct pad_signals *) \
+				(PAD_CTRL_BASE))->x)
+
+static const __maybe_unused struct module_pin_mux uart0_pin_mux[] = {
+	{OFFSET(uart0_rxd), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* UART0_RXD */
+	{OFFSET(uart0_txd), (MODE(0) | PULLUDEN)},		/* UART0_TXD */
+	{-1},
+};
+
+static const __maybe_unused struct module_pin_mux uart3_pin_mux[] = {
+	{OFFSET(spi0_cs1), (MODE(1) | PULLUDEN | RXACTIVE)},	/* UART3_RXD */
+	{OFFSET(ecap0_in_pwm0_out), (MODE(1) | PULLUDEN)},	/* UART3_TXD */
+	{-1},
+};
+
+
+#ifdef CONFIG_NAND
+static const __maybe_unused struct module_pin_mux nand_pin_mux[] = {
+	{OFFSET(gpmc_ad0), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD0 */
+	{OFFSET(gpmc_ad1), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD1 */
+	{OFFSET(gpmc_ad2), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD2 */
+	{OFFSET(gpmc_ad3), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD3 */
+	{OFFSET(gpmc_ad4), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD4 */
+	{OFFSET(gpmc_ad5), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD5 */
+	{OFFSET(gpmc_ad6), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD6 */
+	{OFFSET(gpmc_ad7), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD7 */
+	{OFFSET(gpmc_wait0), (MODE(0) | RXACTIVE | PULLUP_EN)}, /* NAND WAIT */
+	{OFFSET(gpmc_wpn), (MODE(7) | PULLUP_EN | RXACTIVE)},	/* NAND_WPN */
+	{OFFSET(gpmc_csn0), (MODE(0) | PULLUDEN)},	/* NAND_CS0 */
+	{OFFSET(gpmc_advn_ale), (MODE(0) | PULLUDEN)}, /* NAND_ADV_ALE */
+	{OFFSET(gpmc_oen_ren), (MODE(0) | PULLUDEN)},	/* NAND_OE */
+	{OFFSET(gpmc_wen), (MODE(0) | PULLUDEN)},	/* NAND_WEN */
+	{OFFSET(gpmc_be0n_cle), (MODE(0) | PULLUDEN)},	/* NAND_BE_CLE */
+	{-1},
+};
+#endif
+
+static const __maybe_unused struct module_pin_mux i2c0_pin_mux[] = {
+	{OFFSET(i2c0_sda), (MODE(0) | RXACTIVE | PULLUDEN | SLEWCTRL)},	/* I2C_DATA */
+	{OFFSET(i2c0_scl), (MODE(0) | RXACTIVE | PULLUDEN | SLEWCTRL)},	/* I2C_SCLK */
+	{-1},
+};
+
+static const __maybe_unused struct module_pin_mux i2c1_pin_mux[] = {
+	{OFFSET(spi0_d1), (MODE(2) | RXACTIVE | PULLUDEN | SLEWCTRL)},	/* I2C_DATA */
+	{OFFSET(spi0_cs0), (MODE(2) | RXACTIVE | PULLUDEN | SLEWCTRL)},	/* I2C_SCLK */
+	{-1},
+};
+
+static const __maybe_unused struct module_pin_mux i2c2_pin_mux[] = {
+	{OFFSET(uart1_ctsn), (MODE(3) | RXACTIVE | PULLUDEN | SLEWCTRL)},  /* I2C_DATA */
+	{OFFSET(uart1_rtsn), (MODE(3) | RXACTIVE | PULLUDEN | SLEWCTRL)}, /* I2C_SCLK */
+	{-1},
+};
+
+static const __maybe_unused struct module_pin_mux rgmii1_pin_mux[] = {
+	{OFFSET(mii1_txen), MODE(2)},			/* RGMII1_TCTL */
+	{OFFSET(mii1_rxdv), MODE(2) | RXACTIVE},	/* RGMII1_RCTL */
+	{OFFSET(mii1_txd3), MODE(2)},			/* RGMII1_TD3 */
+	{OFFSET(mii1_txd2), MODE(2)},			/* RGMII1_TD2 */
+	{OFFSET(mii1_txd1), MODE(2)},			/* RGMII1_TD1 */
+	{OFFSET(mii1_txd0), MODE(2)},			/* RGMII1_TD0 */
+	{OFFSET(mii1_txclk), MODE(2)},			/* RGMII1_TCLK */
+	{OFFSET(mii1_rxclk), MODE(2) | RXACTIVE},	/* RGMII1_RCLK */
+	{OFFSET(mii1_rxd3), MODE(2) | RXACTIVE},	/* RGMII1_RD3 */
+	{OFFSET(mii1_rxd2), MODE(2) | RXACTIVE},	/* RGMII1_RD2 */
+	{OFFSET(mii1_rxd1), MODE(2) | RXACTIVE},	/* RGMII1_RD1 */
+	{OFFSET(mii1_rxd0), MODE(2) | RXACTIVE},	/* RGMII1_RD0 */
+	{OFFSET(mdio_data), MODE(0) | RXACTIVE | PULLUP_EN}, /* MDIO_DATA */
+	{OFFSET(mdio_clk), MODE(0) | PULLUP_EN},	/* MDIO_CLK */
+	{-1},
+};
+
+static const __maybe_unused struct module_pin_mux rgmii2_pin_mux[] = {
+	{OFFSET(gpmc_a0), MODE(2)},			/* RGMII2_TCTL */
+	{OFFSET(gpmc_a1), MODE(2) | RXACTIVE},		/* RGMII2_RCTL */
+	{OFFSET(gpmc_a2), MODE(2)},			/* RGMII2_TD3 */
+	{OFFSET(gpmc_a3), MODE(2)},			/* RGMII2_TD2 */
+	{OFFSET(gpmc_a4), MODE(2)},			/* RGMII2_TD1 */
+	{OFFSET(gpmc_a5), MODE(2)},			/* RGMII2_TD0 */
+	{OFFSET(gpmc_a6), MODE(2)},			/* RGMII2_TCLK */
+	{OFFSET(gpmc_a7), MODE(2) | RXACTIVE},		/* RGMII2_RCLK */
+	{OFFSET(gpmc_a8), MODE(2) | RXACTIVE},		/* RGMII2_RD3 */
+	{OFFSET(gpmc_a9), MODE(2) | RXACTIVE},		/* RGMII2_RD2 */
+	{OFFSET(gpmc_a10), MODE(2) | RXACTIVE},		/* RGMII2_RD1 */
+	{OFFSET(gpmc_a11), MODE(2) | RXACTIVE},		/* RGMII2_RD0 */
+	{OFFSET(mdio_data), MODE(0) | RXACTIVE | PULLUP_EN}, /* MDIO_DATA */
+	{OFFSET(mdio_clk), MODE(0) | PULLUP_EN},	/* MDIO_CLK */
+	{-1},
+};
+
+static const __maybe_unused struct module_pin_mux mii1_pin_mux[] = {
+	{OFFSET(mii1_rxerr), MODE(0) | RXACTIVE},	/* MII1_RXERR */
+	{OFFSET(mii1_txen), MODE(0)},			/* MII1_TXEN */
+	{OFFSET(mii1_rxdv), MODE(0) | RXACTIVE},	/* MII1_RXDV */
+	{OFFSET(mii1_txd3), MODE(0)},			/* MII1_TXD3 */
+	{OFFSET(mii1_txd2), MODE(0)},			/* MII1_TXD2 */
+	{OFFSET(mii1_txd1), MODE(0)},			/* MII1_TXD1 */
+	{OFFSET(mii1_txd0), MODE(0)},			/* MII1_TXD0 */
+	{OFFSET(mii1_txclk), MODE(0) | RXACTIVE},	/* MII1_TXCLK */
+	{OFFSET(mii1_rxclk), MODE(0) | RXACTIVE},	/* MII1_RXCLK */
+	{OFFSET(mii1_rxd3), MODE(0) | RXACTIVE},	/* MII1_RXD3 */
+	{OFFSET(mii1_rxd2), MODE(0) | RXACTIVE},	/* MII1_RXD2 */
+	{OFFSET(mii1_rxd1), MODE(0) | RXACTIVE},	/* MII1_RXD1 */
+	{OFFSET(mii1_rxd0), MODE(0) | RXACTIVE},	/* MII1_RXD0 */
+	{OFFSET(mdio_data), MODE(0) | RXACTIVE | PULLUP_EN}, /* MDIO_DATA */
+	{OFFSET(mdio_clk), MODE(0) | PULLUP_EN},	/* MDIO_CLK */
+	{-1},
+};
+
+static const __maybe_unused struct module_pin_mux rmii1_pin_mux[] = {
+	{OFFSET(mii1_crs), MODE(1) | RXACTIVE},     /* RMII1_CRS */
+	{OFFSET(mii1_rxerr), MODE(1) | RXACTIVE},   /* RMII1_RXERR */
+	{OFFSET(mii1_txen), MODE(1)},           /* RMII1_TXEN */
+	{OFFSET(mii1_txd1), MODE(1)},           /* RMII1_TXD1 */
+	{OFFSET(mii1_txd0), MODE(1)},           /* RMII1_TXD0 */
+	{OFFSET(mii1_rxd1), MODE(1) | RXACTIVE},    /* RMII1_RXD1 */
+	{OFFSET(mii1_rxd0), MODE(1) | RXACTIVE},    /* RMII1_RXD0 */
+	{OFFSET(mdio_data), MODE(0) | RXACTIVE | PULLUP_EN}, /* MDIO_DATA */
+	{OFFSET(mdio_clk), MODE(0) | PULLUP_EN},    /* MDIO_CLK */
+	{OFFSET(rmii1_refclk), MODE(0) | RXACTIVE}, /* RMII1_REFCLK */
+	{-1},
+};
+
+#ifdef CONFIG_NOR
+static const __maybe_unused struct module_pin_mux nor_pin_mux[] = {
+	{OFFSET(lcd_data0), MODE(1) | PULLUDEN},	/* NOR_A0 */
+	{OFFSET(lcd_data1), MODE(1) | PULLUDEN},	/* NOR_A1 */
+	{OFFSET(lcd_data2), MODE(1) | PULLUDEN},	/* NOR_A2 */
+	{OFFSET(lcd_data3), MODE(1) | PULLUDEN},	/* NOR_A3 */
+	{OFFSET(lcd_data4), MODE(1) | PULLUDEN},	/* NOR_A4 */
+	{OFFSET(lcd_data5), MODE(1) | PULLUDEN},	/* NOR_A5 */
+	{OFFSET(lcd_data6), MODE(1) | PULLUDEN},	/* NOR_A6 */
+	{OFFSET(lcd_data7), MODE(1) | PULLUDEN},	/* NOR_A7 */
+	{OFFSET(gpmc_a8), MODE(0)},			/* NOR_A8 */
+	{OFFSET(gpmc_a9), MODE(0)},			/* NOR_A9 */
+	{OFFSET(gpmc_a10), MODE(0)},			/* NOR_A10 */
+	{OFFSET(gpmc_a11), MODE(0)},			/* NOR_A11 */
+	{OFFSET(lcd_data8), MODE(1) | PULLUDEN},	/* NOR_A12 */
+	{OFFSET(lcd_data9), MODE(1) | PULLUDEN},	/* NOR_A13 */
+	{OFFSET(lcd_data10), MODE(1) | PULLUDEN},	/* NOR_A14 */
+	{OFFSET(lcd_data11), MODE(1) | PULLUDEN},	/* NOR_A15 */
+	{OFFSET(lcd_data12), MODE(1) | PULLUDEN},	/* NOR_A16 */
+	{OFFSET(lcd_data13), MODE(1) | PULLUDEN},	/* NOR_A17 */
+	{OFFSET(lcd_data14), MODE(1) | PULLUDEN},	/* NOR_A18 */
+	{OFFSET(lcd_data15), MODE(1) | PULLUDEN},	/* NOR_A19 */
+	{OFFSET(gpmc_a4), MODE(4)},			/* NOR_A20 */
+	{OFFSET(gpmc_a5), MODE(4)},			/* NOR_A21 */
+	{OFFSET(gpmc_a6), MODE(4)},			/* NOR_A22 */
+	{OFFSET(gpmc_ad0), MODE(0) | RXACTIVE},		/* NOR_AD0 */
+	{OFFSET(gpmc_ad1), MODE(0) | RXACTIVE},		/* NOR_AD1 */
+	{OFFSET(gpmc_ad2), MODE(0) | RXACTIVE},		/* NOR_AD2 */
+	{OFFSET(gpmc_ad3), MODE(0) | RXACTIVE},		/* NOR_AD3 */
+	{OFFSET(gpmc_ad4), MODE(0) | RXACTIVE},		/* NOR_AD4 */
+	{OFFSET(gpmc_ad5), MODE(0) | RXACTIVE},		/* NOR_AD5 */
+	{OFFSET(gpmc_ad6), MODE(0) | RXACTIVE},		/* NOR_AD6 */
+	{OFFSET(gpmc_ad7), MODE(0) | RXACTIVE},		/* NOR_AD7 */
+	{OFFSET(gpmc_ad8), MODE(0) | RXACTIVE},		/* NOR_AD8 */
+	{OFFSET(gpmc_ad9), MODE(0) | RXACTIVE},		/* NOR_AD9 */
+	{OFFSET(gpmc_ad10), MODE(0) | RXACTIVE},	/* NOR_AD10 */
+	{OFFSET(gpmc_ad11), MODE(0) | RXACTIVE},	/* NOR_AD11 */
+	{OFFSET(gpmc_ad12), MODE(0) | RXACTIVE},	/* NOR_AD12 */
+	{OFFSET(gpmc_ad13), MODE(0) | RXACTIVE},	/* NOR_AD13 */
+	{OFFSET(gpmc_ad14), MODE(0) | RXACTIVE},	/* NOR_AD14 */
+	{OFFSET(gpmc_ad15), MODE(0) | RXACTIVE},	/* NOR_AD15 */
+	{OFFSET(gpmc_csn0), (MODE(0) | PULLUP_EN)},	/* NOR_CE */
+	{OFFSET(gpmc_oen_ren), (MODE(0) | PULLUP_EN)},	/* NOR_OE */
+	{OFFSET(gpmc_wen), (MODE(0) | PULLUP_EN)},	/* NOR_WEN */
+	{OFFSET(gpmc_wait0), (MODE(0) | RXACTIVE | PULLUP_EN)}, /* NOR WAIT */
+	{OFFSET(lcd_ac_bias_en), MODE(7) | RXACTIVE | PULLUDEN}, /* NOR RESET */
+	{-1},
+};
+#endif
+
+static const __maybe_unused struct module_pin_mux mmc0_pin_mux[] = {
+	{OFFSET(mmc0_dat3), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT3 */
+	{OFFSET(mmc0_dat2), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT2 */
+	{OFFSET(mmc0_dat1), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT1 */
+	{OFFSET(mmc0_dat0), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT0 */
+	{OFFSET(mmc0_clk), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CLK */
+	{OFFSET(mmc0_cmd), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CMD */
+	{OFFSET(mcasp0_aclkr), (MODE(4) | RXACTIVE)},		/* MMC0_WP */
+	{OFFSET(spi0_cs1), (MODE(5) | RXACTIVE | PULLUP_EN)},	/* MMC0_CD */
+	{-1},
+};
+
+static const __maybe_unused struct module_pin_mux mmc1_pin_mux[] = {
+	{OFFSET(gpmc_ad3), (MODE(1) | RXACTIVE)},	/* MMC1_DAT3 */
+	{OFFSET(gpmc_ad2), (MODE(1) | RXACTIVE)},	/* MMC1_DAT2 */
+	{OFFSET(gpmc_ad1), (MODE(1) | RXACTIVE)},	/* MMC1_DAT1 */
+	{OFFSET(gpmc_ad0), (MODE(1) | RXACTIVE)},	/* MMC1_DAT0 */
+	{OFFSET(gpmc_csn1), (MODE(2) | RXACTIVE | PULLUP_EN)},	/* MMC1_CLK */
+	{OFFSET(gpmc_csn2), (MODE(2) | RXACTIVE | PULLUP_EN)},	/* MMC1_CMD */
+	{OFFSET(uart1_rxd), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_WP */
+	{OFFSET(mcasp0_fsx), (MODE(4) | RXACTIVE)},	/* MMC1_CD */
+	{-1},
+};
+
+static const __maybe_unused struct module_pin_mux spi0_pin_mux[] = {
+	{OFFSET(spi0_sclk), MODE(0) | PULLUDEN | RXACTIVE},	/*SPI0_SCLK */
+	{OFFSET(spi0_d0), MODE(0) | PULLUDEN | PULLUP_EN |
+							RXACTIVE}, /*SPI0_D0 */
+	{OFFSET(spi0_d1), MODE(0) | PULLUDEN |
+							RXACTIVE}, /*SPI0_D1 */
+	{OFFSET(spi0_cs0), MODE(0) | PULLUDEN | PULLUP_EN | RXACTIVE},	/*SPI0_CS0 */
+	{-1},
+};
+
+static const __maybe_unused struct module_pin_mux spi1_pin_mux[] = {
+	{OFFSET(mcasp0_aclkx), MODE(3) | PULLUDEN | RXACTIVE},	/*SPI0_SCLK */
+	{OFFSET(mcasp0_fsx), MODE(3) | PULLUDEN | PULLUP_EN |
+							RXACTIVE}, /*SPI0_D0 */
+	{OFFSET(mcasp0_axr0), MODE(3) | PULLUDEN | RXACTIVE}, /*SPI0_D1 */
+	{OFFSET(mcasp0_ahclkr), MODE(3) | PULLUDEN | PULLUP_EN |
+							RXACTIVE}, /*SPI0_CS0 */
+	{-1},
+};
+
+/*
+ * Configure the pin mux for the module
+ */
+static void configure_module_pin_mux(const struct module_pin_mux *mod_pin_mux)
+{
+	int i;
+
+	if (!mod_pin_mux)
+		return;
+
+	for (i = 0; mod_pin_mux[i].reg_offset != -1; i++)
+		MUX_CFG(mod_pin_mux[i].val, mod_pin_mux[i].reg_offset);
+}
+
+void enable_mii1_pin_mux(void)
+{
+	configure_module_pin_mux(mii1_pin_mux);
+}
+
+void enable_i2c0_pin_mux(void)
+{
+	configure_module_pin_mux(i2c0_pin_mux);
+}
+
+void enable_i2c1_pin_mux(void)
+{
+	configure_module_pin_mux(i2c1_pin_mux);
+}
+
+void enable_i2c2_pin_mux(void)
+{
+	configure_module_pin_mux(i2c2_pin_mux);
+}
+
+void enable_uart0_pin_mux(void)
+{
+	configure_module_pin_mux(uart0_pin_mux);
+}
diff --git a/arch/arm/mach-omap/gpmc.c b/arch/arm/mach-omap/gpmc.c
index 4f54a10..3aaa4f6 100644
--- a/arch/arm/mach-omap/gpmc.c
+++ b/arch/arm/mach-omap/gpmc.c
@@ -26,6 +26,7 @@
 #include <errno.h>
 #include <mach/omap3-silicon.h>
 #include <mach/omap4-silicon.h>
+#include <mach/am33xx-silicon.h>
 #include <mach/gpmc.h>
 #include <mach/sys_info.h>
 #include <mach/syslib.h>
@@ -38,6 +39,8 @@ static int gpmc_init(void)
 	omap_gpmc_base = (void *)OMAP3_GPMC_BASE;
 #elif defined(CONFIG_ARCH_OMAP4)
 	omap_gpmc_base = (void *)OMAP44XX_GPMC_BASE;
+#elif defined(CONFIG_ARCH_AM33XX)
+	omap_gpmc_base = (void *)AM33XX_GPMC_BASE;
 #else
 #error "Unknown ARCH"
 #endif
diff --git a/arch/arm/mach-omap/include/mach/am33xx-clock.h b/arch/arm/mach-omap/include/mach/am33xx-clock.h
index 6845412..39c107f 100644
--- a/arch/arm/mach-omap/include/mach/am33xx-clock.h
+++ b/arch/arm/mach-omap/include/mach/am33xx-clock.h
@@ -19,5 +19,176 @@
 #ifndef _AM33XX_CLOCKS_H_
 #define _AM33XX_CLOCKS_H_
 
+#include "am33xx-silicon.h"
+
+/* Put the pll config values over here */
+
+#define OSC	24
+
+/* MAIN PLL Fdll = 1 GHZ, */
+#define MPUPLL_M_500	500	/* 125 * n */
+#define MPUPLL_M_550	550	/* 125 * n */
+#define MPUPLL_M_600	600	/* 125 * n */
+#define MPUPLL_M_720	720	/* 125 * n */
+
+#define MPUPLL_N	23	/* (n -1 ) */
+#define MPUPLL_M2	1
+
+/* Core PLL Fdll = 1 GHZ, */
+#define COREPLL_M	1000	/* 125 * n */
+#define COREPLL_N	23	/* (n -1 ) */
+
+#define COREPLL_M4	10	/* CORE_CLKOUTM4 = 200 MHZ */
+#define COREPLL_M5	8	/* CORE_CLKOUTM5 = 250 MHZ */
+#define COREPLL_M6	4	/* CORE_CLKOUTM6 = 500 MHZ */
+
+/*
+ * USB PHY clock is 960 MHZ. Since, this comes directly from Fdll, Fdll
+ * frequency needs to be set to 960 MHZ. Hence,
+ * For clkout = 192 MHZ, Fdll = 960 MHZ, divider values are given below
+ */
+#define PERPLL_M	960
+#define PERPLL_N	23
+#define PERPLL_M2	5
+
+/* DDR Freq is 166 MHZ for now*/
+/* Set Fdll = 400 MHZ , Fdll = M * 2 * CLKINP/ N + 1; clkout = Fdll /(2 * M2) */
+//#if	(CONFIG_AM335X_EVM_IS_13x13 == 1)
+#if 0
+#define DDRPLL_M	166	/* M/N + 1 = 25/3 */
+#else
+#define DDRPLL_M	266
+#endif
+
+#define DDRPLL_N	23
+#define DDRPLL_M2	1
+
+/* PRCM */
+/* Module Offsets */
+#define CM_PER                          (AM33XX_PRM_BASE + 0x0)
+#define CM_WKUP                         (AM33XX_PRM_BASE + 0x400)
+#define CM_DPLL                         (AM33XX_PRM_BASE + 0x500)
+#define CM_DEVICE                       (AM33XX_PRM_BASE + 0x0700)
+#define CM_CEFUSE                       (AM33XX_PRM_BASE + 0x0A00)
+#define PRM_DEVICE                      (AM33XX_PRM_BASE + 0x0F00)
+/* Register Offsets */
+/* Core PLL ADPLLS */
+#define CM_CLKSEL_DPLL_CORE             (CM_WKUP + 0x68)
+#define CM_CLKMODE_DPLL_CORE            (CM_WKUP + 0x90)
+
+/* Core HSDIV */
+#define CM_DIV_M4_DPLL_CORE             (CM_WKUP + 0x80)
+#define CM_DIV_M5_DPLL_CORE             (CM_WKUP + 0x84)
+#define CM_DIV_M6_DPLL_CORE             (CM_WKUP + 0xD8)
+#define CM_IDLEST_DPLL_CORE             (CM_WKUP + 0x5c)
+
+/* Peripheral PLL */
+#define CM_CLKSEL_DPLL_PER              (CM_WKUP + 0x9c)
+#define CM_CLKMODE_DPLL_PER             (CM_WKUP + 0x8c)
+#define CM_DIV_M2_DPLL_PER              (CM_WKUP + 0xAC)
+#define CM_IDLEST_DPLL_PER              (CM_WKUP + 0x70)
+
+/* Display PLL */
+#define CM_CLKSEL_DPLL_DISP             (CM_WKUP + 0x54)
+#define CM_CLKMODE_DPLL_DISP            (CM_WKUP + 0x98)
+#define CM_DIV_M2_DPLL_DISP             (CM_WKUP + 0xA4)
+
+/* DDR PLL */
+#define CM_CLKSEL_DPLL_DDR              (CM_WKUP + 0x40)
+#define CM_CLKMODE_DPLL_DDR             (CM_WKUP + 0x94)
+#define CM_DIV_M2_DPLL_DDR              (CM_WKUP + 0xA0)
+#define CM_IDLEST_DPLL_DDR              (CM_WKUP + 0x34)
+
+/* MPU PLL */
+#define CM_CLKSEL_DPLL_MPU              (CM_WKUP + 0x2c)
+#define CM_CLKMODE_DPLL_MPU             (CM_WKUP + 0x88)
+#define CM_DIV_M2_DPLL_MPU              (CM_WKUP + 0xA8)
+#define CM_IDLEST_DPLL_MPU              (CM_WKUP + 0x20)
+
+/* TIMER Clock Source Select */
+#define CLKSEL_TIMER2_CLK               (CM_DPLL + 0x8)
+
+/* Interconnect clocks */
+#define CM_PER_L4LS_CLKCTRL             (CM_PER + 0x60) /* EMIF */
+#define CM_PER_L4FW_CLKCTRL             (CM_PER + 0x64) /* EMIF FW */
+#define CM_PER_L3_CLKCTRL               (CM_PER + 0xE0) /* OCMC RAM */
+#define CM_PER_L3_INSTR_CLKCTRL         (CM_PER + 0xDC)
+#define CM_PER_L4HS_CLKCTRL             (CM_PER + 0x120)
+#define CM_WKUP_L4WKUP_CLKCTRL          (CM_WKUP + 0x0c)/* UART0 */
+
+/* Domain Wake UP */
+#define CM_WKUP_CLKSTCTRL               (CM_WKUP + 0)   /* UART0 */
+#define CM_PER_L4LS_CLKSTCTRL           (CM_PER + 0x0)  /* TIMER2 */
+#define CM_PER_L3_CLKSTCTRL             (CM_PER + 0x0c) /* EMIF */
+#define CM_PER_L4FW_CLKSTCTRL           (CM_PER + 0x08) /* EMIF FW */
+#define CM_PER_L3S_CLKSTCTRL            (CM_PER + 0x4)
+#define CM_PER_L4HS_CLKSTCTRL           (CM_PER + 0x011c)
+#define CM_CEFUSE_CLKSTCTRL             (CM_CEFUSE + 0x0)
+
+/* Module Enable Registers */
+#define CM_PER_TIMER2_CLKCTRL           (CM_PER + 0x80) /* Timer2 */
+#define CM_WKUP_UART0_CLKCTRL           (CM_WKUP + 0xB4)/* UART0 */
+#define CM_WKUP_CONTROL_CLKCTRL         (CM_WKUP + 0x4) /* Control Module */
+#define CM_PER_EMIF_CLKCTRL             (CM_PER + 0x28) /* EMIF */
+#define CM_PER_EMIF_FW_CLKCTRL          (CM_PER + 0xD0) /* EMIF FW */
+#define CM_PER_GPMC_CLKCTRL             (CM_PER + 0x30) /* GPMC */
+#define CM_PER_ELM_CLKCTRL              (CM_PER + 0x40) /* ELM */
+#define CM_PER_SPI0_CLKCTRL             (CM_PER + 0x4c) /* SPI0 */
+#define CM_PER_SPI1_CLKCTRL             (CM_PER + 0x50) /* SPI1 */
+#define CM_WKUP_I2C0_CLKCTRL            (CM_WKUP + 0xB8) /* I2C0 */
+#define CM_PER_CPGMAC0_CLKCTRL          (CM_PER + 0x14) /* Ethernet */
+#define CM_PER_CPSW_CLKSTCTRL           (CM_PER + 0x144)/* Ethernet */
+#define CM_PER_OCMCRAM_CLKCTRL          (CM_PER + 0x2C) /* OCMC RAM */
+#define CM_PER_GPIO2_CLKCTRL            (CM_PER + 0xB0) /* GPIO2 */
+#define CM_PER_UART3_CLKCTRL            (CM_PER + 0x74) /* UART3 */
+#define CM_PER_I2C1_CLKCTRL             (CM_PER + 0x48) /* I2C1 */
+#define CM_PER_I2C2_CLKCTRL             (CM_PER + 0x44) /* I2C2 */
+#define CM_WKUP_GPIO0_CLKCTRL           (CM_WKUP + 0x8) /* GPIO0 */
+
+#define CM_PER_MMC0_CLKCTRL             (CM_PER + 0x3C)
+#define CM_PER_MMC1_CLKCTRL             (CM_PER + 0xF4)
+#define CM_PER_MMC2_CLKCTRL             (CM_PER + 0xF8)
+
+/* PRCM */
+#define CM_DPLL_OFFSET                  (AM33XX_PRM_BASE + 0x0300)
+
+#define CM_ALWON_WDTIMER_CLKCTRL        (AM33XX_PRM_BASE + 0x158C)
+#define CM_ALWON_SPI_CLKCTRL            (AM33XX_PRM_BASE + 0x1590)
+#define CM_ALWON_CONTROL_CLKCTRL        (AM33XX_PRM_BASE + 0x15C4)
+
+#define CM_ALWON_L3_SLOW_CLKSTCTRL      (AM33XX_PRM_BASE + 0x1400)
+
+#define CM_ALWON_GPIO_0_CLKCTRL         (AM33XX_PRM_BASE + 0x155c)
+#define CM_ALWON_GPIO_0_OPTFCLKEN_DBCLK (AM33XX_PRM_BASE + 0x155c)
+
+/* Ethernet */
+#define CM_ETHERNET_CLKSTCTRL           (AM33XX_PRM_BASE + 0x1404)
+#define CM_ALWON_ETHERNET_0_CLKCTRL     (AM33XX_PRM_BASE + 0x15D4)
+#define CM_ALWON_ETHERNET_1_CLKCTRL     (AM33XX_PRM_BASE + 0x15D8)
+
+/* UARTs */
+#define CM_ALWON_UART_0_CLKCTRL         (AM33XX_PRM_BASE + 0x1550)
+#define CM_ALWON_UART_1_CLKCTRL         (AM33XX_PRM_BASE + 0x1554)
+#define CM_ALWON_UART_2_CLKCTRL         (AM33XX_PRM_BASE + 0x1558)
+
+/* I2C */
+/* Note: In ti814x I2C0 and I2C2 have common clk control */
+#define CM_ALWON_I2C_0_CLKCTRL          (AM33XX_PRM_BASE + 0x1564)
+
+/* EMIF4 PRCM Defintion */
+#define CM_DEFAULT_L3_FAST_CLKSTCTRL    (AM33XX_PRM_BASE + 0x0508)
+#define CM_DEFAULT_EMIF_0_CLKCTRL       (AM33XX_PRM_BASE + 0x0520)
+#define CM_DEFAULT_EMIF_1_CLKCTRL       (AM33XX_PRM_BASE + 0x0524)
+#define CM_DEFAULT_DMM_CLKCTRL          (AM33XX_PRM_BASE + 0x0528)
+#define CM_DEFAULT_FW_CLKCTRL           (AM33XX_PRM_BASE + 0x052C)
+
+/* ALWON PRCM */
+#define CM_ALWON_OCMC_0_CLKSTCTRL       CM_PER_L3_CLKSTCTRL
+#define CM_ALWON_OCMC_0_CLKCTRL         CM_PER_OCMCRAM_CLKCTRL
+
+#define CM_ALWON_GPMC_CLKCTRL           CM_PER_GPMC_CLKCTRL
+
+extern void pll_init(void);
+extern void enable_ddr_clocks(void);
 
 #endif  /* endif _AM33XX_CLOCKS_H_ */
diff --git a/arch/arm/mach-omap/include/mach/am33xx-devices.h b/arch/arm/mach-omap/include/mach/am33xx-devices.h
new file mode 100644
index 0000000..cfb931f
--- /dev/null
+++ b/arch/arm/mach-omap/include/mach/am33xx-devices.h
@@ -0,0 +1,32 @@
+#ifndef __MACH_OMAP3_DEVICES_H
+#define __MACH_OMAP3_DEVICES_H
+
+#include <driver.h>
+#include <sizes.h>
+#include <mach/am33xx-silicon.h>
+#include <mach/devices.h>
+#include <mach/omap_hsmmc.h>
+
+/* the device numbering is the same as in the TRM memory map (SPRUH73G) */
+
+static inline struct device_d *am33xx_add_uart0(void)
+{
+	return omap_add_uart(0, AM33XX_UART0_BASE);
+}
+
+static inline struct device_d *am33xx_add_uart1(void)
+{
+	return omap_add_uart(1, AM33XX_UART1_BASE);
+}
+
+static inline struct device_d *am33xx_add_uart2(void)
+{
+	return omap_add_uart(2, AM33XX_UART2_BASE);
+}
+
+static inline struct device_d *am33xx_add_mmc0(struct omap_hsmmc_platform_data *pdata)
+{
+	return omap_add_mmc(0, AM33XX_MMCHS0_BASE, pdata);
+}
+
+#endif /* __MACH_OMAP3_DEVICES_H */
diff --git a/arch/arm/mach-omap/include/mach/am33xx-mux.h b/arch/arm/mach-omap/include/mach/am33xx-mux.h
new file mode 100644
index 0000000..ed328f5
--- /dev/null
+++ b/arch/arm/mach-omap/include/mach/am33xx-mux.h
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+#ifndef __AM33XX_MUX_H__
+#define __AM33XX_MUX_H__
+
+extern void enable_mii1_pin_mux(void);
+extern void enable_i2c0_pin_mux(void);
+extern void enable_i2c1_pin_mux(void);
+extern void enable_i2c2_pin_mux(void);
+extern void enable_uart0_pin_mux(void);
+
+#endif /*__AM33XX_MUX_H__ */
diff --git a/arch/arm/mach-omap/include/mach/am33xx-silicon.h b/arch/arm/mach-omap/include/mach/am33xx-silicon.h
index 090489c..b46a2d7 100644
--- a/arch/arm/mach-omap/include/mach/am33xx-silicon.h
+++ b/arch/arm/mach-omap/include/mach/am33xx-silicon.h
@@ -22,6 +22,8 @@
 #define AM33XX_L4_PER_BASE		0x48000000
 #define AM33XX_L4_FAST_BASE		0x4A000000
 
+/* the device numbering is the same as in the TRM memory map (SPRUH73G) */
+
 /* UART */
 #define AM33XX_UART0_BASE		(AM33XX_L4_WKUP_BASE + 0x209000)
 #define AM33XX_UART1_BASE		(AM33XX_L4_PER_BASE + 0x22000)
@@ -45,5 +47,118 @@
 /* PRM */
 #define AM33XX_PRM_BASE			(AM33XX_L4_WKUP_BASE + 0x200000)
 
+#define AM33XX_PRM_RSTCTRL		(AM33XX_PRM_BASE + 0x0f00)
+#define AM33XX_PRM_RSTCTRL_RESET	0x1
+
+/* CTRL */
+#define AM33XX_CTRL_BASE		(AM33XX_L4_WKUP_BASE + 0x210000)
+
+/* Watchdog Timer */
+#define AM33XX_WDT_BASE			0x44E35000
+
+/* EMIF Base address */
+#define AM33XX_EMIF4_0_CFG_BASE		0x4C000000
+#define AM33XX_EMIF4_1_CFG_BASE		0x4D000000
+#define AM33XX_DMM_BASE			0x4E000000
+
+#define AM335X_CPSW_BASE		0x4A100000
+#define AM335X_CPSW_MDIO_BASE		0x4A101000
+
+/*DMM & EMIF4 MMR Declaration*/
+#define AM33XX_DMM_LISA_MAP__0		(AM33XX_DMM_BASE + 0x40)
+#define AM33XX_DMM_LISA_MAP__1		(AM33XX_DMM_BASE + 0x44)
+#define AM33XX_DMM_LISA_MAP__2		(AM33XX_DMM_BASE + 0x48)
+#define AM33XX_DMM_LISA_MAP__3		(AM33XX_DMM_BASE + 0x4C)
+#define AM33XX_DMM_PAT_BASE_ADDR	(AM33XX_DMM_BASE + 0x460)
+
+#define AM33XX_EMIF4_0_REG(REGNAME)	(AM33XX_EMIF4_0_CFG_BASE + EMIF4_##REGNAME)
+#define AM33XX_EMIF4_1_REG(REGNAME)	(AM33XX_EMIF4_1_CFG_BASE + EMIF4_##REGNAME)
+
+#define EMIF4_MOD_ID_REV		0x0
+#define EMIF4_SDRAM_STATUS		0x04
+#define EMIF4_SDRAM_CONFIG		0x08
+#define EMIF4_SDRAM_CONFIG2		0x0C
+#define EMIF4_SDRAM_REF_CTRL		0x10
+#define EMIF4_SDRAM_REF_CTRL_SHADOW	0x14
+#define EMIF4_SDRAM_TIM_1		0x18
+#define EMIF4_SDRAM_TIM_1_SHADOW	0x1C
+#define EMIF4_SDRAM_TIM_2		0x20
+#define EMIF4_SDRAM_TIM_2_SHADOW	0x24
+#define EMIF4_SDRAM_TIM_3		0x28
+#define EMIF4_SDRAM_TIM_3_SHADOW	0x2C
+#define EMIF0_SDRAM_MGMT_CTRL		0x38
+#define EMIF0_SDRAM_MGMT_CTRL_SHD	0x3C
+#define EMIF4_DDR_PHY_CTRL_1		0xE4
+#define EMIF4_DDR_PHY_CTRL_1_SHADOW	0xE8
+#define EMIF4_DDR_PHY_CTRL_2		0xEC
+#define EMIF4_IODFT_TLGC		0x60
+
+#define AM33XX_VTP0_CTRL_REG		0x44E10E0C
+#define AM33XX_VTP1_CTRL_REG		0x48140E10
+
+/* OCMC */
+#define AM33XX_SRAM0_SIZE			(0x1B400) /* 109 KB */
+#define AM33XX_SRAM_GPMC_STACK_SIZE		(0x40)
+
+#define AM33XX_LOW_LEVEL_SRAM_STACK		(AM33XX_SRAM0_START + AM33XX_SRAM0_SIZE - 4)
+
+/* DDR offsets */
+#define	AM33XX_DDR_PHY_BASE_ADDR		0x44E12000
+#define	AM33XX_DDR_IO_CTRL			0x44E10E04
+#define	AM33XX_DDR_CKE_CTRL			0x44E1131C
+#define	AM33XX_CONTROL_BASE_ADDR		0x44E10000
+
+#define	AM33XX_DDR_CMD0_IOCTRL			(AM33XX_CONTROL_BASE_ADDR + 0x1404)
+#define	AM33XX_DDR_CMD1_IOCTRL			(AM33XX_CONTROL_BASE_ADDR + 0x1408)
+#define	AM33XX_DDR_CMD2_IOCTRL			(AM33XX_CONTROL_BASE_ADDR + 0x140C)
+#define	AM33XX_DDR_DATA0_IOCTRL			(AM33XX_CONTROL_BASE_ADDR + 0x1440)
+#define	AM33XX_DDR_DATA1_IOCTRL			(AM33XX_CONTROL_BASE_ADDR + 0x1444)
+
+#define	AM33XX_CMD0_CTRL_SLAVE_RATIO_0		(AM33XX_DDR_PHY_BASE_ADDR + 0x01C)
+#define	AM33XX_CMD0_CTRL_SLAVE_FORCE_0		(AM33XX_DDR_PHY_BASE_ADDR + 0x020)
+#define	AM33XX_CMD0_CTRL_SLAVE_DELAY_0		(AM33XX_DDR_PHY_BASE_ADDR + 0x024)
+#define	AM33XX_CMD0_DLL_LOCK_DIFF_0		(AM33XX_DDR_PHY_BASE_ADDR + 0x028)
+#define	AM33XX_CMD0_INVERT_CLKOUT_0		(AM33XX_DDR_PHY_BASE_ADDR + 0x02C)
+
+#define	AM33XX_CMD1_CTRL_SLAVE_RATIO_0		(AM33XX_DDR_PHY_BASE_ADDR + 0x050)
+#define	AM33XX_CMD1_CTRL_SLAVE_FORCE_0		(AM33XX_DDR_PHY_BASE_ADDR + 0x054)
+#define	AM33XX_CMD1_CTRL_SLAVE_DELAY_0		(AM33XX_DDR_PHY_BASE_ADDR + 0x058)
+#define	AM33XX_CMD1_DLL_LOCK_DIFF_0		(AM33XX_DDR_PHY_BASE_ADDR + 0x05C)
+#define	AM33XX_CMD1_INVERT_CLKOUT_0		(AM33XX_DDR_PHY_BASE_ADDR + 0x060)
+
+#define	AM33XX_CMD2_CTRL_SLAVE_RATIO_0		(AM33XX_DDR_PHY_BASE_ADDR + 0x084)
+#define	AM33XX_CMD2_CTRL_SLAVE_FORCE_0		(AM33XX_DDR_PHY_BASE_ADDR + 0x088)
+#define	AM33XX_CMD2_CTRL_SLAVE_DELAY_0		(AM33XX_DDR_PHY_BASE_ADDR + 0x08C)
+#define	AM33XX_CMD2_DLL_LOCK_DIFF_0		(AM33XX_DDR_PHY_BASE_ADDR + 0x090)
+#define	AM33XX_CMD2_INVERT_CLKOUT_0		(AM33XX_DDR_PHY_BASE_ADDR + 0x094)
+
+#define AM33XX_DATA0_RD_DQS_SLAVE_RATIO_0	(AM33XX_DDR_PHY_BASE_ADDR + 0x0C8)
+#define AM33XX_DATA0_RD_DQS_SLAVE_RATIO_1	(AM33XX_DDR_PHY_BASE_ADDR + 0x0CC)
+#define	AM33XX_DATA0_WR_DQS_SLAVE_RATIO_0	(AM33XX_DDR_PHY_BASE_ADDR + 0x0DC)
+
+#define	AM33XX_DATA0_WR_DQS_SLAVE_RATIO_1	(AM33XX_DDR_PHY_BASE_ADDR + 0x0E0)
+#define	AM33XX_DATA0_WRLVL_INIT_RATIO_0		(AM33XX_DDR_PHY_BASE_ADDR + 0x0F0)
+
+#define	AM33XX_DATA0_WRLVL_INIT_RATIO_1		(AM33XX_DDR_PHY_BASE_ADDR + 0x0F4)
+#define	AM33XX_DATA0_GATELVL_INIT_RATIO_0	(AM33XX_DDR_PHY_BASE_ADDR + 0x0FC)
+
+#define	AM33XX_DATA0_GATELVL_INIT_RATIO_1	(AM33XX_DDR_PHY_BASE_ADDR + 0x100)
+#define	AM33XX_DATA0_FIFO_WE_SLAVE_RATIO_0	(AM33XX_DDR_PHY_BASE_ADDR + 0x108)
+
+#define	AM33XX_DATA0_FIFO_WE_SLAVE_RATIO_1	(AM33XX_DDR_PHY_BASE_ADDR + 0x10C)
+#define	AM33XX_DATA0_WR_DATA_SLAVE_RATIO_0	(AM33XX_DDR_PHY_BASE_ADDR + 0x120)
+
+#define	AM33XX_DATA0_WR_DATA_SLAVE_RATIO_1	(AM33XX_DDR_PHY_BASE_ADDR + 0x124)
+#define AM33XX_DATA0_DLL_LOCK_DIFF_0		(AM33XX_DDR_PHY_BASE_ADDR + 0x138)
+
+#define AM33XX_DATA0_RANK0_DELAYS_0		(AM33XX_DDR_PHY_BASE_ADDR + 0x134)
+#define	AM33XX_DATA1_RANK0_DELAYS_0		(AM33XX_DDR_PHY_BASE_ADDR + 0x1D8)
+
+/* Ethernet MAC ID from EFuse */
+#define AM33XX_MAC_ID0_LO	(AM33XX_CTRL_BASE + 0x630)
+#define AM33XX_MAC_ID0_HI	(AM33XX_CTRL_BASE + 0x634)
+#define AM33XX_MAC_ID1_LO	(AM33XX_CTRL_BASE + 0x638)
+#define AM33XX_MAC_ID1_HI	(AM33XX_CTRL_BASE + 0x63c)
+#define AM33XX_MAC_MII_SEL	(AM33XX_CTRL_BASE + 0x650)
 
 #endif
diff --git a/arch/arm/mach-omap/include/mach/wdt.h b/arch/arm/mach-omap/include/mach/wdt.h
index 5f3bb60..9a5288d 100644
--- a/arch/arm/mach-omap/include/mach/wdt.h
+++ b/arch/arm/mach-omap/include/mach/wdt.h
@@ -22,6 +22,8 @@
 
 /** Watchdog Register defines */
 #define OMAP3_WDT_REG(REGNAME)	(OMAP3_MPU_WDTIMER_BASE + OMAP_WDT_##REGNAME)
+#define AM33XX_WDT_REG(REGNAME)	(AM33XX_WDT_BASE + OMAP_WDT_##REGNAME)
+
 #define OMAP_WDT_WIDR		(0x000)
 #define OMAP_WDT_SYSCONFIG	(0x010)
 #define OMAP_WDT_WD_SYSSTATUS	(0x014)
diff --git a/arch/arm/mach-omap/include/mach/xload.h b/arch/arm/mach-omap/include/mach/xload.h
index 44d3754..d632735 100644
--- a/arch/arm/mach-omap/include/mach/xload.h
+++ b/arch/arm/mach-omap/include/mach/xload.h
@@ -9,6 +9,7 @@ enum omap_boot_src {
 	OMAP_BOOTSRC_USB1,
 };
 
+enum omap_boot_src am33xx_bootsrc(void);
 enum omap_boot_src omap3_bootsrc(void);
 enum omap_boot_src omap4_bootsrc(void);
 
diff --git a/arch/arm/mach-omap/xload.c b/arch/arm/mach-omap/xload.c
index 240d3ff..47c5d98 100644
--- a/arch/arm/mach-omap/xload.c
+++ b/arch/arm/mach-omap/xload.c
@@ -163,6 +163,8 @@ enum omap_boot_src omap_bootsrc(void)
 	return omap3_bootsrc();
 #elif defined(CONFIG_ARCH_OMAP4)
 	return omap4_bootsrc();
+#elif defined(CONFIG_ARCH_AM33XX)
+	return am33xx_bootsrc();
 #endif
 }
 
