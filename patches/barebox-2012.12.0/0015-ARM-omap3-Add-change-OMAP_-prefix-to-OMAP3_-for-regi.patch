From 2677288da894681aaf40df93a34cfea2e5d50850 Mon Sep 17 00:00:00 2001
From: Sascha Hauer <s.hauer@pengutronix.de>
Date: Fri, 14 Dec 2012 11:20:42 +0100
Subject: [PATCH] ARM omap3: Add change OMAP_ prefix to OMAP3_ for registers

Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
---
 arch/arm/boards/beagle/board.c                  |   32 +--
 arch/arm/boards/omap343xdsp/board.c             |   32 +--
 arch/arm/boards/omap3evm/board.c                |   28 +--
 arch/arm/boards/phycard-a-l1/pca-a-l1.c         |   36 ++--
 arch/arm/mach-omap/include/mach/control.h       |    4 +-
 arch/arm/mach-omap/include/mach/omap3-clock.h   |    4 +-
 arch/arm/mach-omap/include/mach/omap3-devices.h |   18 +-
 arch/arm/mach-omap/include/mach/omap3-silicon.h |  132 ++++++------
 arch/arm/mach-omap/include/mach/omap3-smx.h     |   16 +-
 arch/arm/mach-omap/include/mach/sdrc.h          |    2 +-
 arch/arm/mach-omap/include/mach/wdt.h           |    2 +-
 arch/arm/mach-omap/omap3_clock.c                |  244 +++++++++++------------
 arch/arm/mach-omap/omap3_generic.c              |   38 ++--
 drivers/usb/host/ehci-omap.c                    |   76 +++----
 14 files changed, 332 insertions(+), 332 deletions(-)

diff --git a/arch/arm/boards/beagle/board.c b/arch/arm/boards/beagle/board.c
index 6004566..04c4d32 100644
--- a/arch/arm/boards/beagle/board.c
+++ b/arch/arm/boards/beagle/board.c
@@ -81,47 +81,47 @@ static void sdrc_init(void)
 {
 	/* SDRAM software reset */
 	/* No idle ack and RESET enable */
-	writel(0x1A, SDRC_REG(SYSCONFIG));
+	writel(0x1A, OMAP3_SDRC_REG(SYSCONFIG));
 	sdelay(100);
 	/* No idle ack and RESET disable */
-	writel(0x18, SDRC_REG(SYSCONFIG));
+	writel(0x18, OMAP3_SDRC_REG(SYSCONFIG));
 
 	/* SDRC Sharing register */
 	/* 32-bit SDRAM on data lane [31:0] - CS0 */
 	/* pin tri-stated = 1 */
-	writel(0x00000100, SDRC_REG(SHARING));
+	writel(0x00000100, OMAP3_SDRC_REG(SHARING));
 
 	/* ----- SDRC Registers Configuration --------- */
 	/* SDRC_MCFG0 register */
-	writel(0x02584099, SDRC_REG(MCFG_0));
+	writel(0x02584099, OMAP3_SDRC_REG(MCFG_0));
 
 	/* SDRC_RFR_CTRL0 register */
-	writel(0x54601, SDRC_REG(RFR_CTRL_0));
+	writel(0x54601, OMAP3_SDRC_REG(RFR_CTRL_0));
 
 	/* SDRC_ACTIM_CTRLA0 register */
-	writel(0xA29DB4C6, SDRC_REG(ACTIM_CTRLA_0));
+	writel(0xA29DB4C6, OMAP3_SDRC_REG(ACTIM_CTRLA_0));
 
 	/* SDRC_ACTIM_CTRLB0 register */
-	writel(0x12214, SDRC_REG(ACTIM_CTRLB_0));
+	writel(0x12214, OMAP3_SDRC_REG(ACTIM_CTRLB_0));
 
 	/* Disble Power Down of CKE due to 1 CKE on combo part */
-	writel(0x00000081, SDRC_REG(POWER));
+	writel(0x00000081, OMAP3_SDRC_REG(POWER));
 
 	/* SDRC_MANUAL command register */
 	/* NOP command */
-	writel(0x00000000, SDRC_REG(MANUAL_0));
+	writel(0x00000000, OMAP3_SDRC_REG(MANUAL_0));
 	/* Precharge command */
-	writel(0x00000001, SDRC_REG(MANUAL_0));
+	writel(0x00000001, OMAP3_SDRC_REG(MANUAL_0));
 	/* Auto-refresh command */
-	writel(0x00000002, SDRC_REG(MANUAL_0));
+	writel(0x00000002, OMAP3_SDRC_REG(MANUAL_0));
 	/* Auto-refresh command */
-	writel(0x00000002, SDRC_REG(MANUAL_0));
+	writel(0x00000002, OMAP3_SDRC_REG(MANUAL_0));
 
 	/* SDRC MR0 register Burst length=4 */
-	writel(0x00000032, SDRC_REG(MR_0));
+	writel(0x00000032, OMAP3_SDRC_REG(MR_0));
 
 	/* SDRC DLLA control register */
-	writel(0x0000000A, SDRC_REG(DLLA_CTRL));
+	writel(0x0000000A, OMAP3_SDRC_REG(DLLA_CTRL));
 
 	return;
 }
@@ -293,8 +293,8 @@ static int beagle_devices_init(void)
 
 #ifdef CONFIG_USB_EHCI_OMAP
 	if (ehci_omap_init(&omap_ehci_pdata) >= 0)
-		add_usb_ehci_device(DEVICE_ID_DYNAMIC, OMAP_EHCI_BASE,
-				    OMAP_EHCI_BASE + 0x10, &ehci_pdata);
+		add_usb_ehci_device(DEVICE_ID_DYNAMIC, OMAP3_EHCI_BASE,
+				    OMAP3_EHCI_BASE + 0x10, &ehci_pdata);
 #endif /* CONFIG_USB_EHCI_OMAP */
 #ifdef CONFIG_OMAP_GPMC
 	/* WP is made high and WAIT1 active Low */
diff --git a/arch/arm/boards/omap343xdsp/board.c b/arch/arm/boards/omap343xdsp/board.c
index 6de86f4..eb752ff 100644
--- a/arch/arm/boards/omap343xdsp/board.c
+++ b/arch/arm/boards/omap343xdsp/board.c
@@ -94,54 +94,54 @@ pure_initcall(sdp343x_board_init);
 static void sdrc_init(void)
 {
 	/* Issue SDRC Soft reset  */
-	writel(0x12, SDRC_REG(SYSCONFIG));
+	writel(0x12, OMAP3_SDRC_REG(SYSCONFIG));
     /* Wait until Reset complete */
-    while ((readl(SDRC_REG(STATUS)) & 0x1) == 0);
+    while ((readl(OMAP3_SDRC_REG(STATUS)) & 0x1) == 0);
     /* SDRC to normal mode */
-	writel(0x10, SDRC_REG(SYSCONFIG));
+	writel(0x10, OMAP3_SDRC_REG(SYSCONFIG));
 	/* SDRC Sharing register */
 	/* 32-bit SDRAM on data lane [31:0] - CS0 */
 	/* pin tri-stated = 1 */
-	writel(0x00000100, SDRC_REG(SHARING));
+	writel(0x00000100, OMAP3_SDRC_REG(SHARING));
 
 	/* ----- SDRC_REG(CS0 Configuration --------- */
 	/* SDRC_REG(MCFG0 register */
-	writel(0x02584019, SDRC_REG(MCFG_0));
+	writel(0x02584019, OMAP3_SDRC_REG(MCFG_0));
 
 	/* SDRC_REG(RFR_CTRL0 register */
-	writel(0x0003DE01, SDRC_REG(RFR_CTRL_0));
+	writel(0x0003DE01, OMAP3_SDRC_REG(RFR_CTRL_0));
 
 	/* SDRC_REG(ACTIM_CTRLA0 register */
-	writel(0X5A9A4486, SDRC_REG(ACTIM_CTRLA_0));
+	writel(0X5A9A4486, OMAP3_SDRC_REG(ACTIM_CTRLA_0));
 
 	/* SDRC_REG(ACTIM_CTRLB0 register */
-	writel(0x00000010, SDRC_REG(ACTIM_CTRLB_0));
+	writel(0x00000010, OMAP3_SDRC_REG(ACTIM_CTRLB_0));
 
 	/* Disble Power Down of CKE cuz of 1 CKE on combo part */
-	writel(0x00000081, SDRC_REG(POWER));
+	writel(0x00000081, OMAP3_SDRC_REG(POWER));
 
 	/* SDRC_REG(Manual command register */
 	/* NOP command */
-	writel(0x00000000, SDRC_REG(MANUAL_0));
+	writel(0x00000000, OMAP3_SDRC_REG(MANUAL_0));
 	/* Precharge command */
-	writel(0x00000001, SDRC_REG(MANUAL_0));
+	writel(0x00000001, OMAP3_SDRC_REG(MANUAL_0));
 	/* Auto-refresh command */
-	writel(0x00000002, SDRC_REG(MANUAL_0));
+	writel(0x00000002, OMAP3_SDRC_REG(MANUAL_0));
 	/* Auto-refresh command */
-	writel(0x00000002, SDRC_REG(MANUAL_0));
+	writel(0x00000002, OMAP3_SDRC_REG(MANUAL_0));
 
 	/* SDRC MR0 register */
 	/* CAS latency = 3 */
 	/* Write Burst = Read Burst */
 	/* Serial Mode */
-	writel(0x00000032, SDRC_REG(MR_0));	/* Burst length =4 */
+	writel(0x00000032, OMAP3_SDRC_REG(MR_0));	/* Burst length =4 */
 
     /* SDRC DLLA control register */
 	/* Enable DLL A */
-	writel(0x0000000A, SDRC_REG(DLLA_CTRL));
+	writel(0x0000000A, OMAP3_SDRC_REG(DLLA_CTRL));
 
     /* wait until DLL is locked  */
-    while ((readl(SDRC_REG(DLLA_STATUS)) & 0x4) == 0);
+    while ((readl(OMAP3_SDRC_REG(DLLA_STATUS)) & 0x4) == 0);
 	return;
 }
 
diff --git a/arch/arm/boards/omap3evm/board.c b/arch/arm/boards/omap3evm/board.c
index 179450f..03d3ab8 100644
--- a/arch/arm/boards/omap3evm/board.c
+++ b/arch/arm/boards/omap3evm/board.c
@@ -71,47 +71,47 @@ static void sdrc_init(void)
 {
 	/* SDRAM software reset */
 	/* No idle ack and RESET enable */
-	writel(0x1A, SDRC_REG(SYSCONFIG));
+	writel(0x1A, OMAP3_SDRC_REG(SYSCONFIG));
 	sdelay(100);
 	/* No idle ack and RESET disable */
-	writel(0x18, SDRC_REG(SYSCONFIG));
+	writel(0x18, OMAP3_SDRC_REG(SYSCONFIG));
 
 	/* SDRC Sharing register */
 	/* 32-bit SDRAM on data lane [31:0] - CS0 */
 	/* pin tri-stated = 1 */
-	writel(0x00000100, SDRC_REG(SHARING));
+	writel(0x00000100, OMAP3_SDRC_REG(SHARING));
 
 	/* ----- SDRC Registers Configuration --------- */
 	/* SDRC_MCFG0 register */
-	writel(0x02584099, SDRC_REG(MCFG_0));
+	writel(0x02584099, OMAP3_SDRC_REG(MCFG_0));
 
 	/* SDRC_RFR_CTRL0 register */
-	writel(0x54601, SDRC_REG(RFR_CTRL_0));
+	writel(0x54601, OMAP3_SDRC_REG(RFR_CTRL_0));
 
 	/* SDRC_ACTIM_CTRLA0 register */
-	writel(0xA29DB4C6, SDRC_REG(ACTIM_CTRLA_0));
+	writel(0xA29DB4C6, OMAP3_SDRC_REG(ACTIM_CTRLA_0));
 
 	/* SDRC_ACTIM_CTRLB0 register */
-	writel(0x12214, SDRC_REG(ACTIM_CTRLB_0));
+	writel(0x12214, OMAP3_SDRC_REG(ACTIM_CTRLB_0));
 
 	/* Disble Power Down of CKE due to 1 CKE on combo part */
-	writel(0x00000081, SDRC_REG(POWER));
+	writel(0x00000081, OMAP3_SDRC_REG(POWER));
 
 	/* SDRC_MANUAL command register */
 	/* NOP command */
-	writel(0x00000000, SDRC_REG(MANUAL_0));
+	writel(0x00000000, OMAP3_SDRC_REG(MANUAL_0));
 	/* Precharge command */
-	writel(0x00000001, SDRC_REG(MANUAL_0));
+	writel(0x00000001, OMAP3_SDRC_REG(MANUAL_0));
 	/* Auto-refresh command */
-	writel(0x00000002, SDRC_REG(MANUAL_0));
+	writel(0x00000002, OMAP3_SDRC_REG(MANUAL_0));
 	/* Auto-refresh command */
-	writel(0x00000002, SDRC_REG(MANUAL_0));
+	writel(0x00000002, OMAP3_SDRC_REG(MANUAL_0));
 
 	/* SDRC MR0 register Burst length=4 */
-	writel(0x00000032, SDRC_REG(MR_0));
+	writel(0x00000032, OMAP3_SDRC_REG(MR_0));
 
 	/* SDRC DLLA control register */
-	writel(0x0000000A, SDRC_REG(DLLA_CTRL));
+	writel(0x0000000A, OMAP3_SDRC_REG(DLLA_CTRL));
 
 	return;
 }
diff --git a/arch/arm/boards/phycard-a-l1/pca-a-l1.c b/arch/arm/boards/phycard-a-l1/pca-a-l1.c
index 3b89631..b582d71 100644
--- a/arch/arm/boards/phycard-a-l1/pca-a-l1.c
+++ b/arch/arm/boards/phycard-a-l1/pca-a-l1.c
@@ -103,16 +103,16 @@ struct sdrc_config {
 void init_sdram_ddr(void)
 {
 	/* reset sdrc controller */
-	writel(SOFTRESET, SDRC_REG(SYSCONFIG));
-	wait_on_value(1<<0, 1<<0, SDRC_REG(STATUS), 12000000);
-	writel(0, SDRC_REG(SYSCONFIG));
+	writel(SOFTRESET, OMAP3_SDRC_REG(SYSCONFIG));
+	wait_on_value(1<<0, 1<<0, OMAP3_SDRC_REG(STATUS), 12000000);
+	writel(0, OMAP3_SDRC_REG(SYSCONFIG));
 
 	/* setup sdrc to ball mux */
-	writel(SDP_SDRC_SHARING, SDRC_REG(SHARING));
-	writel(SDP_SDRC_POWER_POP, SDRC_REG(POWER));
+	writel(SDP_SDRC_SHARING, OMAP3_SDRC_REG(SHARING));
+	writel(SDP_SDRC_POWER_POP, OMAP3_SDRC_REG(POWER));
 
 	/* set up dll */
-	writel(SDP_SDRC_DLLAB_CTRL, SDRC_REG(DLLA_CTRL));
+	writel(SDP_SDRC_DLLAB_CTRL, OMAP3_SDRC_REG(DLLA_CTRL));
 	sdelay(0x2000);	/* give time to lock */
 
 }
@@ -122,21 +122,21 @@ void init_sdram_ddr(void)
 void config_sdram_ddr(u8 cs, u8 cfg)
 {
 
-	writel(sdrc_config[cfg].mcfg, SDRC_REG(MCFG_0) + (0x30 * cs));
-	writel(sdrc_config[cfg].actim_ctrla, SDRC_REG(ACTIM_CTRLA_0) + (0x28 * cs));
-	writel(sdrc_config[cfg].actim_ctrlb, SDRC_REG(ACTIM_CTRLB_0) + (0x28 * cs));
-	writel(sdrc_config[cfg].rfr_ctrl, SDRC_REG(RFR_CTRL_0) + (0x30 * cs));
+	writel(sdrc_config[cfg].mcfg, OMAP3_SDRC_REG(MCFG_0) + (0x30 * cs));
+	writel(sdrc_config[cfg].actim_ctrla, OMAP3_SDRC_REG(ACTIM_CTRLA_0) + (0x28 * cs));
+	writel(sdrc_config[cfg].actim_ctrlb, OMAP3_SDRC_REG(ACTIM_CTRLB_0) + (0x28 * cs));
+	writel(sdrc_config[cfg].rfr_ctrl, OMAP3_SDRC_REG(RFR_CTRL_0) + (0x30 * cs));
 
-	writel(CMD_NOP, SDRC_REG(MANUAL_0) + (0x30 * cs));
+	writel(CMD_NOP, OMAP3_SDRC_REG(MANUAL_0) + (0x30 * cs));
 
 	sdelay(5000);
 
-	writel(CMD_PRECHARGE, SDRC_REG(MANUAL_0) + (0x30 * cs));
-	writel(CMD_AUTOREFRESH, SDRC_REG(MANUAL_0) + (0x30 * cs));
-	writel(CMD_AUTOREFRESH, SDRC_REG(MANUAL_0) + (0x30 * cs));
+	writel(CMD_PRECHARGE, OMAP3_SDRC_REG(MANUAL_0) + (0x30 * cs));
+	writel(CMD_AUTOREFRESH, OMAP3_SDRC_REG(MANUAL_0) + (0x30 * cs));
+	writel(CMD_AUTOREFRESH, OMAP3_SDRC_REG(MANUAL_0) + (0x30 * cs));
 
 	/* set mr0 */
-	writel(sdrc_config[cfg].mr, SDRC_REG(MR_0) + (0x30 * cs));
+	writel(sdrc_config[cfg].mr, OMAP3_SDRC_REG(MR_0) + (0x30 * cs));
 
 	sdelay(2000);
 }
@@ -171,7 +171,7 @@ static void pcaal1_sdrc_init(void)
 
 	if (test1 == 0) {
 		init_sdram_ddr();
-		writel((sdrc_config[(uchar) cfg].mcfg & 0xfffc00ff), SDRC_REG(MCFG_1));
+		writel((sdrc_config[(uchar) cfg].mcfg & 0xfffc00ff), OMAP3_SDRC_REG(MCFG_1));
 
 		/* 1 x 256MByte */
 		if (test0 == SZ_256M)
@@ -179,7 +179,7 @@ static void pcaal1_sdrc_init(void)
 
 		if (cfg != -1) {
 			config_sdram_ddr(0, cfg);
-			writel(sdrc_config[(uchar) cfg].cs_cfg, SDRC_REG(CS_CFG));
+			writel(sdrc_config[(uchar) cfg].cs_cfg, OMAP3_SDRC_REG(CS_CFG));
 		}
 		return;
 	}
@@ -194,7 +194,7 @@ static void pcaal1_sdrc_init(void)
 
 	if (cfg != -1) {
 		init_sdram_ddr();
-		writel(sdrc_config[(uchar) cfg].cs_cfg, SDRC_REG(CS_CFG));
+		writel(sdrc_config[(uchar) cfg].cs_cfg, OMAP3_SDRC_REG(CS_CFG));
 		config_sdram_ddr(0, cfg);
 		config_sdram_ddr(1, cfg);
 	}
diff --git a/arch/arm/mach-omap/include/mach/control.h b/arch/arm/mach-omap/include/mach/control.h
index e03d8d5..1cc4cd4 100644
--- a/arch/arm/mach-omap/include/mach/control.h
+++ b/arch/arm/mach-omap/include/mach/control.h
@@ -31,7 +31,7 @@
  * Control register defintion which unwraps to the real register
  * offset + base address
  */
-#define CONTROL_REG(REGNAME)		(OMAP_CTRL_BASE + CONTROL_##REGNAME)
+#define OMAP3_CONTROL_REG(REGNAME)	(OMAP3_CTRL_BASE + CONTROL_##REGNAME)
 
 #define CONTROL_SCALABLE_OMAP_STATUS    (0x44C)
 #define CONTROL_SCALABLE_OMAP_OCP       (0x534)
@@ -79,7 +79,7 @@
 
 /** Provide the Regoffset, Value */
 #define	MUX_VAL(OFFSET,VALUE)\
-	writew((VALUE), OMAP_CTRL_BASE + (OFFSET))
+	writew((VALUE), OMAP3_CTRL_BASE + (OFFSET))
 
 /**
  * macro for Padconfig Registers @see
diff --git a/arch/arm/mach-omap/include/mach/omap3-clock.h b/arch/arm/mach-omap/include/mach/omap3-clock.h
index 00ce6a5..1ef46aa 100644
--- a/arch/arm/mach-omap/include/mach/omap3-clock.h
+++ b/arch/arm/mach-omap/include/mach/omap3-clock.h
@@ -23,7 +23,7 @@
 #define _OMAP343X_CLOCKS_H_
 
 /** CM Clock Regs Wrapper */
-#define CM_REG(REGNAME)	(OMAP_CM_BASE + CM_##REGNAME)
+#define OMAP3_CM_REG(REGNAME)	(OMAP3_CM_BASE + CM_##REGNAME)
 
 #define CM_FCLKEN_IVA2		0X0000
 #define CM_CLKEN_PLL_IVA2	0X0004
@@ -73,7 +73,7 @@
 #define CM_CLKSTCTRL_USBH	0x1448
 
 /** PRM Clock Regs */
-#define PRM_REG(REGNAME)	(OMAP_PRM_BASE + PRM_##REGNAME)
+#define OMAP3_PRM_REG(REGNAME)	(OMAP3_PRM_BASE + PRM_##REGNAME)
 #define PRM_CLKSEL		0x0D40
 #define PRM_RSTCTRL		0x1250
 #define PRM_CLKSRC_CTRL		0x1270
diff --git a/arch/arm/mach-omap/include/mach/omap3-devices.h b/arch/arm/mach-omap/include/mach/omap3-devices.h
index 555e86f..6617430 100644
--- a/arch/arm/mach-omap/include/mach/omap3-devices.h
+++ b/arch/arm/mach-omap/include/mach/omap3-devices.h
@@ -38,47 +38,47 @@ static inline struct device_d *omap3_add_spi4(void)
 
 static inline struct device_d *omap3_add_uart1(void)
 {
-	return omap_add_uart(0, OMAP_UART1_BASE);
+	return omap_add_uart(0, OMAP3_UART1_BASE);
 }
 
 static inline struct device_d *omap3_add_uart2(void)
 {
-	return omap_add_uart(1, OMAP_UART2_BASE);
+	return omap_add_uart(1, OMAP3_UART2_BASE);
 }
 
 static inline struct device_d *omap3_add_uart3(void)
 {
-	return omap_add_uart(2, OMAP_UART3_BASE);
+	return omap_add_uart(2, OMAP3_UART3_BASE);
 }
 
 static inline struct device_d *omap3_add_mmc1(struct omap_hsmmc_platform_data *pdata)
 {
-	return omap_add_mmc(0, OMAP_MMC1_BASE, pdata);
+	return omap_add_mmc(0, OMAP3_MMC1_BASE, pdata);
 }
 
 static inline struct device_d *omap3_add_mmc2(struct omap_hsmmc_platform_data *pdata)
 {
-	return omap_add_mmc(1, OMAP_MMC2_BASE, pdata);
+	return omap_add_mmc(1, OMAP3_MMC2_BASE, pdata);
 }
 
 static inline struct device_d *omap3_add_mmc3(struct omap_hsmmc_platform_data *pdata)
 {
-	return omap_add_mmc(2, OMAP_MMC3_BASE, pdata);
+	return omap_add_mmc(2, OMAP3_MMC3_BASE, pdata);
 }
 
 static inline struct device_d *omap3_add_i2c1(void *pdata)
 {
-	return omap_add_i2c(0, OMAP_I2C1_BASE, pdata);
+	return omap_add_i2c(0, OMAP3_I2C1_BASE, pdata);
 }
 
 static inline struct device_d *omap3_add_i2c2(void *pdata)
 {
-	return omap_add_i2c(1, OMAP_I2C2_BASE, pdata);
+	return omap_add_i2c(1, OMAP3_I2C2_BASE, pdata);
 }
 
 static inline struct device_d *omap3_add_i2c3(void *pdata)
 {
-	return omap_add_i2c(2, OMAP_I2C3_BASE, pdata);
+	return omap_add_i2c(2, OMAP3_I2C3_BASE, pdata);
 }
 
 #endif /* __MACH_OMAP3_DEVICES_H */
diff --git a/arch/arm/mach-omap/include/mach/omap3-silicon.h b/arch/arm/mach-omap/include/mach/omap3-silicon.h
index 0cf43bd..282b587 100644
--- a/arch/arm/mach-omap/include/mach/omap3-silicon.h
+++ b/arch/arm/mach-omap/include/mach/omap3-silicon.h
@@ -34,82 +34,82 @@
 /* PLEASE PLACE ONLY BASE DEFINES HERE */
 
 /** OMAP Internal Bus Base addresses */
-#define OMAP_L4_CORE_BASE	0x48000000
-#define OMAP_INTC_BASE		0x48200000
-#define OMAP_L4_WKUP_BASE	0x48300000
-#define OMAP_L4_PER_BASE	0x49000000
-#define OMAP_L4_EMU_BASE	0x54000000
-#define OMAP_SGX_BASE		0x50000000
-#define OMAP_IVA_BASE		0x5C000000
-#define OMAP_SMX_APE_BASE	0x68000000
-#define OMAP_SMS_BASE		0x6C000000
-#define OMAP_SDRC_BASE		0x6D000000
+#define OMAP3_L4_CORE_BASE	0x48000000
+#define OMAP3_INTC_BASE		0x48200000
+#define OMAP3_L4_WKUP_BASE	0x48300000
+#define OMAP3_L4_PER_BASE	0x49000000
+#define OMAP3_L4_EMU_BASE	0x54000000
+#define OMAP3_SGX_BASE		0x50000000
+#define OMAP3_IVA_BASE		0x5C000000
+#define OMAP3_SMX_APE_BASE	0x68000000
+#define OMAP3_SMS_BASE		0x6C000000
+#define OMAP3_SDRC_BASE		0x6D000000
 #define OMAP3_GPMC_BASE		0x6E000000
 
 /** Peripheral Base Addresses */
-#define OMAP_CTRL_BASE		(OMAP_L4_CORE_BASE + 0x02000)
-#define OMAP_CM_BASE		(OMAP_L4_CORE_BASE + 0x04000)
-#define OMAP_PRM_BASE		(OMAP_L4_WKUP_BASE + 0x06000)
-
-#define OMAP_UART1_BASE		(OMAP_L4_CORE_BASE + 0x6A000)
-#define OMAP_UART2_BASE		(OMAP_L4_CORE_BASE + 0x6C000)
-#define OMAP_UART3_BASE		(OMAP_L4_PER_BASE + 0x20000)
-
-#define OMAP_I2C1_BASE		(OMAP_L4_CORE_BASE + 0x70000)
-#define OMAP_I2C2_BASE		(OMAP_L4_CORE_BASE + 0x72000)
-#define OMAP_I2C3_BASE		(OMAP_L4_CORE_BASE + 0x60000)
-
-#define OMAP_GPTIMER1_BASE	(OMAP_L4_WKUP_BASE + 0x18000)
-#define OMAP_GPTIMER2_BASE	(OMAP_L4_PER_BASE + 0x32000)
-#define OMAP_GPTIMER3_BASE	(OMAP_L4_PER_BASE + 0x34000)
-#define OMAP_GPTIMER4_BASE	(OMAP_L4_PER_BASE + 0x36000)
-#define OMAP_GPTIMER5_BASE	(OMAP_L4_PER_BASE + 0x38000)
-#define OMAP_GPTIMER6_BASE	(OMAP_L4_PER_BASE + 0x3A000)
-#define OMAP_GPTIMER7_BASE	(OMAP_L4_PER_BASE + 0x3C000)
-#define OMAP_GPTIMER8_BASE	(OMAP_L4_PER_BASE + 0x3E000)
-#define OMAP_GPTIMER9_BASE	(OMAP_L4_PER_BASE + 0x40000)
-#define OMAP_GPTIMER10_BASE	(OMAP_L4_CORE_BASE + 0x86000)
-#define OMAP_GPTIMER11_BASE	(OMAP_L4_CORE_BASE + 0x88000)
-
-#define OMAP_WDTIMER2_BASE	(OMAP_L4_WKUP_BASE + 0x14000)
-#define OMAP_WDTIMER3_BASE	(OMAP_L4_PER_BASE + 0x30000)
-
-#define OMAP3_32KTIMER_BASE	(OMAP_L4_WKUP_BASE + 0x20000)
-
-#define OMAP_MMC1_BASE		(OMAP_L4_CORE_BASE + 0x9C000)
-#define OMAP_MMC2_BASE		(OMAP_L4_CORE_BASE + 0xB4000)
-#define OMAP_MMC3_BASE		(OMAP_L4_CORE_BASE + 0xAD000)
-
-#define OMAP_MUSB0_BASE		(OMAP_L4_CORE_BASE + 0xAB000)
-
-#define OMAP_GPIO1_BASE		(OMAP_L4_WKUP_BASE + 0x10000)
-#define OMAP_GPIO2_BASE		(OMAP_L4_PER_BASE + 0x50000)
-#define OMAP_GPIO3_BASE		(OMAP_L4_PER_BASE + 0x52000)
-#define OMAP_GPIO4_BASE		(OMAP_L4_PER_BASE + 0x54000)
-#define OMAP_GPIO5_BASE		(OMAP_L4_PER_BASE + 0x56000)
-#define OMAP_GPIO6_BASE		(OMAP_L4_PER_BASE + 0x58000)
+#define OMAP3_CTRL_BASE		(OMAP3_L4_CORE_BASE + 0x02000)
+#define OMAP3_CM_BASE		(OMAP3_L4_CORE_BASE + 0x04000)
+#define OMAP3_PRM_BASE		(OMAP3_L4_WKUP_BASE + 0x06000)
+
+#define OMAP3_UART1_BASE	(OMAP3_L4_CORE_BASE + 0x6A000)
+#define OMAP3_UART2_BASE	(OMAP3_L4_CORE_BASE + 0x6C000)
+#define OMAP3_UART3_BASE	(OMAP3_L4_PER_BASE + 0x20000)
+
+#define OMAP3_I2C1_BASE		(OMAP3_L4_CORE_BASE + 0x70000)
+#define OMAP3_I2C2_BASE		(OMAP3_L4_CORE_BASE + 0x72000)
+#define OMAP3_I2C3_BASE		(OMAP3_L4_CORE_BASE + 0x60000)
+
+#define OMAP3_GPTIMER1_BASE	(OMAP3_L4_WKUP_BASE + 0x18000)
+#define OMAP3_GPTIMER2_BASE	(OMAP3_L4_PER_BASE + 0x32000)
+#define OMAP3_GPTIMER3_BASE	(OMAP3_L4_PER_BASE + 0x34000)
+#define OMAP3_GPTIMER4_BASE	(OMAP3_L4_PER_BASE + 0x36000)
+#define OMAP3_GPTIMER5_BASE	(OMAP3_L4_PER_BASE + 0x38000)
+#define OMAP3_GPTIMER6_BASE	(OMAP3_L4_PER_BASE + 0x3A000)
+#define OMAP3_GPTIMER7_BASE	(OMAP3_L4_PER_BASE + 0x3C000)
+#define OMAP3_GPTIMER8_BASE	(OMAP3_L4_PER_BASE + 0x3E000)
+#define OMAP3_GPTIMER9_BASE	(OMAP3_L4_PER_BASE + 0x40000)
+#define OMAP3_GPTIMER10_BASE	(OMAP3_L4_CORE_BASE + 0x86000)
+#define OMAP3_GPTIMER11_BASE	(OMAP3_L4_CORE_BASE + 0x88000)
+
+#define OMAP3_WDTIMER2_BASE	(OMAP3_L4_WKUP_BASE + 0x14000)
+#define OMAP3_WDTIMER3_BASE	(OMAP3_L4_PER_BASE + 0x30000)
+
+#define OMAP3_32KTIMER_BASE	(OMAP3_L4_WKUP_BASE + 0x20000)
+
+#define OMAP3_MMC1_BASE		(OMAP3_L4_CORE_BASE + 0x9C000)
+#define OMAP3_MMC2_BASE		(OMAP3_L4_CORE_BASE + 0xB4000)
+#define OMAP3_MMC3_BASE		(OMAP3_L4_CORE_BASE + 0xAD000)
+
+#define OMAP3_MUSB0_BASE	(OMAP3_L4_CORE_BASE + 0xAB000)
+
+#define OMAP3_GPIO1_BASE	(OMAP3_L4_WKUP_BASE + 0x10000)
+#define OMAP3_GPIO2_BASE	(OMAP3_L4_PER_BASE + 0x50000)
+#define OMAP3_GPIO3_BASE	(OMAP3_L4_PER_BASE + 0x52000)
+#define OMAP3_GPIO4_BASE	(OMAP3_L4_PER_BASE + 0x54000)
+#define OMAP3_GPIO5_BASE	(OMAP3_L4_PER_BASE + 0x56000)
+#define OMAP3_GPIO6_BASE	(OMAP3_L4_PER_BASE + 0x58000)
 
 /** MPU WDT Definition */
-#define OMAP_MPU_WDTIMER_BASE	OMAP_WDTIMER2_BASE
+#define OMAP3_MPU_WDTIMER_BASE	OMAP3_WDTIMER2_BASE
 
-#define OMAP_HSUSB_OTG_BASE    (OMAP_L4_CORE_BASE + 0xAB000)
-#define OMAP_USBTLL_BASE       (OMAP_L4_CORE_BASE + 0x62000)
-#define OMAP_UHH_CONFIG_BASE   (OMAP_L4_CORE_BASE + 0x64000)
-#define OMAP_OHCI_BASE         (OMAP_L4_CORE_BASE + 0x64400)
-#define OMAP_EHCI_BASE         (OMAP_L4_CORE_BASE + 0x64800)
+#define OMAP3_HSUSB_OTG_BASE    (OMAP3_L4_CORE_BASE + 0xAB000)
+#define OMAP3_USBTLL_BASE       (OMAP3_L4_CORE_BASE + 0x62000)
+#define OMAP3_UHH_CONFIG_BASE   (OMAP3_L4_CORE_BASE + 0x64000)
+#define OMAP3_OHCI_BASE         (OMAP3_L4_CORE_BASE + 0x64400)
+#define OMAP3_EHCI_BASE         (OMAP3_L4_CORE_BASE + 0x64800)
 
 /** Interrupt Vector base address */
-#define OMAP_SRAM_BASE		0x40200000
-#define OMAP_SRAM_INTVECT	0x4020F800
-#define OMAP_SRAM_INTVECT_COPYSIZE	0x64
+#define OMAP3_SRAM_BASE		0x40200000
+#define OMAP3_SRAM_INTVECT	0x4020F800
+#define OMAP3_SRAM_INTVECT_COPYSIZE	0x64
 
 /** Gives the silicon revision */
-#define OMAP_TAP_BASE		(OMAP_L4_WKUP_BASE + 0xA000)
-#define IDCODE_REG		(OMAP_TAP_BASE + 0x204)
-#define DIE_ID_0		(OMAP_TAP_BASE + 0x218)
-#define DIE_ID_1		(OMAP_TAP_BASE + 0x21c)
-#define DIE_ID_2		(OMAP_TAP_BASE + 0x220)
-#define DIE_ID_3		(OMAP_TAP_BASE + 0x224)
+#define OMAP3_TAP_BASE		(OMAP3_L4_WKUP_BASE + 0xA000)
+#define OMAP3_IDCODE_REG	(OMAP3_TAP_BASE + 0x204)
+#define OMAP3_DIE_ID_0		(OMAP3_TAP_BASE + 0x218)
+#define OMAP3_DIE_ID_1		(OMAP3_TAP_BASE + 0x21c)
+#define OMAP3_DIE_ID_2		(OMAP3_TAP_BASE + 0x220)
+#define OMAP3_DIE_ID_3		(OMAP3_TAP_BASE + 0x224)
 
 /** Masks to extract information from ID code register */
 #define IDCODE_HAWKEYE_MASK	0x0FFFF000
diff --git a/arch/arm/mach-omap/include/mach/omap3-smx.h b/arch/arm/mach-omap/include/mach/omap3-smx.h
index f7fa4d2..fb444b8 100644
--- a/arch/arm/mach-omap/include/mach/omap3-smx.h
+++ b/arch/arm/mach-omap/include/mach/omap3-smx.h
@@ -28,11 +28,11 @@
 #define __ASM_ARCH_OMAP_SMX_H
 
 /* SMX-APE */
-#define PM_RT_APE_BASE_ADDR_ARM		(OMAP_SMX_APE_BASE + 0x10000)
-#define PM_GPMC_BASE_ADDR_ARM		(OMAP_SMX_APE_BASE + 0x12400)
-#define PM_OCM_RAM_BASE_ADDR_ARM	(OMAP_SMX_APE_BASE + 0x12800)
-#define PM_OCM_ROM_BASE_ADDR_ARM	(OMAP_SMX_APE_BASE + 0x12C00)
-#define PM_IVA2_BASE_ADDR_ARM		(OMAP_SMX_APE_BASE + 0x14000)
+#define PM_RT_APE_BASE_ADDR_ARM		(OMAP3_SMX_APE_BASE + 0x10000)
+#define PM_GPMC_BASE_ADDR_ARM		(OMAP3_SMX_APE_BASE + 0x12400)
+#define PM_OCM_RAM_BASE_ADDR_ARM	(OMAP3_SMX_APE_BASE + 0x12800)
+#define PM_OCM_ROM_BASE_ADDR_ARM	(OMAP3_SMX_APE_BASE + 0x12C00)
+#define PM_IVA2_BASE_ADDR_ARM		(OMAP3_SMX_APE_BASE + 0x14000)
 
 #define RT_REQ_INFO_PERMISSION_1	(PM_RT_APE_BASE_ADDR_ARM + 0x68)
 #define RT_READ_PERMISSION_0		(PM_RT_APE_BASE_ADDR_ARM + 0x50)
@@ -54,9 +54,9 @@
 #define IVA2_WRITE_PERMISSION_0		(PM_IVA2_BASE_ADDR_ARM + 0x58)
 
 /* SMS */
-#define SMS_SYSCONFIG			(OMAP_SMS_BASE + 0x10)
-#define SMS_RG_ATT0			(OMAP_SMS_BASE + 0x48)
-#define SMS_CLASS_ARB0			(OMAP_SMS_BASE + 0xD0)
+#define SMS_SYSCONFIG			(OMAP3_SMS_BASE + 0x10)
+#define SMS_RG_ATT0			(OMAP3_SMS_BASE + 0x48)
+#define SMS_CLASS_ARB0			(OMAP3_SMS_BASE + 0xD0)
 #define BURSTCOMPLETE_GROUP7		(0x1 << 31)
 
 #endif /* __ASM_ARCH_OMAP_SMX_H */
diff --git a/arch/arm/mach-omap/include/mach/sdrc.h b/arch/arm/mach-omap/include/mach/sdrc.h
index 73031b9..434f119 100644
--- a/arch/arm/mach-omap/include/mach/sdrc.h
+++ b/arch/arm/mach-omap/include/mach/sdrc.h
@@ -24,7 +24,7 @@
 #ifndef _ASM_ARCH_SDRC_H
 #define _ASM_ARCH_SDRC_H
 
-#define SDRC_REG(REGNAME)	(OMAP_SDRC_BASE + OMAP_SDRC_##REGNAME)
+#define OMAP3_SDRC_REG(REGNAME)	(OMAP3_SDRC_BASE + OMAP_SDRC_##REGNAME)
 #define OMAP_SDRC_SYSCONFIG	(0x10)
 #define OMAP_SDRC_STATUS	(0x14)
 #define OMAP_SDRC_CS_CFG	(0x40)
diff --git a/arch/arm/mach-omap/include/mach/wdt.h b/arch/arm/mach-omap/include/mach/wdt.h
index 10cb1f4..5f3bb60 100644
--- a/arch/arm/mach-omap/include/mach/wdt.h
+++ b/arch/arm/mach-omap/include/mach/wdt.h
@@ -21,7 +21,7 @@
 #define __ASM_ARCH_OMAP_WDT_H
 
 /** Watchdog Register defines */
-#define WDT_REG(REGNAME)	(OMAP_MPU_WDTIMER_BASE + OMAP_WDT_##REGNAME)
+#define OMAP3_WDT_REG(REGNAME)	(OMAP3_MPU_WDTIMER_BASE + OMAP_WDT_##REGNAME)
 #define OMAP_WDT_WIDR		(0x000)
 #define OMAP_WDT_SYSCONFIG	(0x010)
 #define OMAP_WDT_WD_SYSSTATUS	(0x014)
diff --git a/arch/arm/mach-omap/omap3_clock.c b/arch/arm/mach-omap/omap3_clock.c
index 5cf2747..bcde48f 100644
--- a/arch/arm/mach-omap/omap3_clock.c
+++ b/arch/arm/mach-omap/omap3_clock.c
@@ -58,7 +58,7 @@ static u32 get_osc_clk_speed(void)
 {
 	u32 start, cstart, cend, cdiff, cdiv, val;
 
-	val = readl(PRM_REG(CLKSRC_CTRL));
+	val = readl(OMAP3_PRM_REG(CLKSRC_CTRL));
 
 	if (val & SYSCLK_DIV_2)
 		cdiv = 2;
@@ -72,28 +72,28 @@ static u32 get_osc_clk_speed(void)
 		cdiv = 1;
 
 	/* enable timer2 */
-	val = readl(CM_REG(CLKSEL_WKUP)) | (0x1 << 0);
-	writel(val, CM_REG(CLKSEL_WKUP));	/* select sys_clk for GPT1 */
+	val = readl(OMAP3_CM_REG(CLKSEL_WKUP)) | (0x1 << 0);
+	writel(val, OMAP3_CM_REG(CLKSEL_WKUP));	/* select sys_clk for GPT1 */
 
 	/* Enable I and F Clocks for GPT1 */
-	val = readl(CM_REG(ICLKEN_WKUP)) | (0x1 << 0) | (0x1 << 2);
-	writel(val, CM_REG(ICLKEN_WKUP));
-	val = readl(CM_REG(FCLKEN_WKUP)) | (0x1 << 0);
-	writel(val, CM_REG(FCLKEN_WKUP));
+	val = readl(OMAP3_CM_REG(ICLKEN_WKUP)) | (0x1 << 0) | (0x1 << 2);
+	writel(val, OMAP3_CM_REG(ICLKEN_WKUP));
+	val = readl(OMAP3_CM_REG(FCLKEN_WKUP)) | (0x1 << 0);
+	writel(val, OMAP3_CM_REG(FCLKEN_WKUP));
 	/* start counting at 0 */
-	writel(0, OMAP_GPTIMER1_BASE + TLDR);
+	writel(0, OMAP3_GPTIMER1_BASE + TLDR);
 	/* enable clock */
-	writel(GPT_EN, OMAP_GPTIMER1_BASE + TCLR);
+	writel(GPT_EN, OMAP3_GPTIMER1_BASE + TCLR);
 	/* enable 32kHz source - enabled out of reset */
 	/* determine sys_clk via gauging */
 
 	start = 20 + readl(S32K_CR);	/* start time in 20 cycles */
 	while (readl(S32K_CR) < start) ;	/* dead loop till start time */
 	/* get start sys_clk count */
-	cstart = readl(OMAP_GPTIMER1_BASE + TCRR);
+	cstart = readl(OMAP3_GPTIMER1_BASE + TCRR);
 	while (readl(S32K_CR) < (start + 20)) ;	/* wait for 40 cycles */
 	/* get end sys_clk count */
-	cend = readl(OMAP_GPTIMER1_BASE + TCRR);
+	cend = readl(OMAP3_GPTIMER1_BASE + TCRR);
 	cdiff = cend - cstart;	/* get elapsed ticks */
 
 	if (cdiv == 2)
@@ -171,8 +171,8 @@ static void init_core_dpll_34x(u32 cpu_rev, u32 clk_sel)
 	dp += clk_sel;
 
 	if (running_in_sram()) {
-		sr32(CM_REG(CLKEN_PLL), 0, 3, PLL_FAST_RELOCK_BYPASS);
-		wait_on_value((0x1 << 0), 0, CM_REG(IDLEST_CKGEN), LDELAY);
+		sr32(OMAP3_CM_REG(CLKEN_PLL), 0, 3, PLL_FAST_RELOCK_BYPASS);
+		wait_on_value((0x1 << 0), 0, OMAP3_CM_REG(IDLEST_CKGEN), LDELAY);
 
 		/*
 		 * OMAP3430 ES1.0 Errata 1.50
@@ -181,34 +181,34 @@ static void init_core_dpll_34x(u32 cpu_rev, u32 clk_sel)
 		 */
 
 		/* CM_CLKSEL1_EMU[DIV_DPLL3] */
-		sr32(CM_REG(CLKSEL1_EMU), 16, 5, CORE_M3X2 + 1);
-		sr32(CM_REG(CLKSEL1_EMU), 16, 5, CORE_M3X2);
+		sr32(OMAP3_CM_REG(CLKSEL1_EMU), 16, 5, CORE_M3X2 + 1);
+		sr32(OMAP3_CM_REG(CLKSEL1_EMU), 16, 5, CORE_M3X2);
 
 		/* M2 (CORE_DPLL_CLKOUT_DIV): CM_CLKSEL1_PLL[27:31] */
-		sr32(CM_REG(CLKSEL1_PLL), 27, 2, dp->m2);
+		sr32(OMAP3_CM_REG(CLKSEL1_PLL), 27, 2, dp->m2);
 
 		/* M (CORE_DPLL_MULT): CM_CLKSEL1_PLL[16:26] */
-		sr32(CM_REG(CLKSEL1_PLL), 16, 11, dp->m);
+		sr32(OMAP3_CM_REG(CLKSEL1_PLL), 16, 11, dp->m);
 
 		/* N (CORE_DPLL_DIV): CM_CLKSEL1_PLL[8:14] */
-		sr32(CM_REG(CLKSEL1_PLL), 8, 7, dp->n);
+		sr32(OMAP3_CM_REG(CLKSEL1_PLL), 8, 7, dp->n);
 
 		/* Set source CM_96M_FCLK: CM_CLKSEL1_PLL[6] */
-		sr32(CM_REG(CLKSEL1_PLL), 6, 1, 0);
+		sr32(OMAP3_CM_REG(CLKSEL1_PLL), 6, 1, 0);
 
-		sr32(CM_REG(CLKSEL_CORE), 8, 4, CORE_SSI_DIV);
-		sr32(CM_REG(CLKSEL_CORE), 4, 2, CORE_FUSB_DIV);
-		sr32(CM_REG(CLKSEL_CORE), 2, 2, CORE_L4_DIV);
-		sr32(CM_REG(CLKSEL_CORE), 0, 2, CORE_L3_DIV);
-		sr32(CM_REG(CLKSEL_GFX), 0, 3, GFX_DIV_34X);
-		sr32(CM_REG(CLKSEL_WKUP), 1, 2, WKUP_RSM);
+		sr32(OMAP3_CM_REG(CLKSEL_CORE), 8, 4, CORE_SSI_DIV);
+		sr32(OMAP3_CM_REG(CLKSEL_CORE), 4, 2, CORE_FUSB_DIV);
+		sr32(OMAP3_CM_REG(CLKSEL_CORE), 2, 2, CORE_L4_DIV);
+		sr32(OMAP3_CM_REG(CLKSEL_CORE), 0, 2, CORE_L3_DIV);
+		sr32(OMAP3_CM_REG(CLKSEL_GFX), 0, 3, GFX_DIV_34X);
+		sr32(OMAP3_CM_REG(CLKSEL_WKUP), 1, 2, WKUP_RSM);
 
 		/* FREQSEL (CORE_DPLL_FREQSEL): CM_CLKEN_PLL[4:7] */
-		sr32(CM_REG(CLKEN_PLL), 4, 4, dp->fsel);
+		sr32(OMAP3_CM_REG(CLKEN_PLL), 4, 4, dp->fsel);
 
 		/* Lock Mode */
-		sr32(CM_REG(CLKEN_PLL), 0, 3, PLL_LOCK);
-		wait_on_value((0x1 << 0), 1, CM_REG(IDLEST_CKGEN), LDELAY);
+		sr32(OMAP3_CM_REG(CLKEN_PLL), 0, 3, PLL_LOCK);
+		wait_on_value((0x1 << 0), 1, OMAP3_CM_REG(IDLEST_CKGEN), LDELAY);
 	} else if (running_in_flash()) {
 		/***Oopps.. Wrong .config!! *****/
 		hang();
@@ -242,41 +242,41 @@ static void init_per_dpll_34x(u32 cpu_rev, u32 clk_sel)
 	 * value and then write the default value.
 	 */
 
-	sr32(CM_REG(CLKEN_PLL), 16, 3, PLL_STOP);
-	wait_on_value((0x1 << 1), 0, CM_REG(IDLEST_CKGEN), LDELAY);
+	sr32(OMAP3_CM_REG(CLKEN_PLL), 16, 3, PLL_STOP);
+	wait_on_value((0x1 << 1), 0, OMAP3_CM_REG(IDLEST_CKGEN), LDELAY);
 
 	/* Set M6 */
-	sr32(CM_REG(CLKSEL1_EMU), 24, 5, PER_M6X2 + 1);
-	sr32(CM_REG(CLKSEL1_EMU), 24, 5, PER_M6X2);
+	sr32(OMAP3_CM_REG(CLKSEL1_EMU), 24, 5, PER_M6X2 + 1);
+	sr32(OMAP3_CM_REG(CLKSEL1_EMU), 24, 5, PER_M6X2);
 
 	/* Set M5 */
-	sr32(CM_REG(CLKSEL_CAM), 0, 5, PER_M5X2 + 1);
-	sr32(CM_REG(CLKSEL_CAM), 0, 5, PER_M5X2);
+	sr32(OMAP3_CM_REG(CLKSEL_CAM), 0, 5, PER_M5X2 + 1);
+	sr32(OMAP3_CM_REG(CLKSEL_CAM), 0, 5, PER_M5X2);
 
 	/* Set M4 */
-	sr32(CM_REG(CLKSEL_DSS), 0, 5, PER_M4X2 + 1);
-	sr32(CM_REG(CLKSEL_DSS), 0, 5, PER_M4X2);
+	sr32(OMAP3_CM_REG(CLKSEL_DSS), 0, 5, PER_M4X2 + 1);
+	sr32(OMAP3_CM_REG(CLKSEL_DSS), 0, 5, PER_M4X2);
 
 	/* Set M3 */
-	sr32(CM_REG(CLKSEL_DSS), 8, 5, PER_M3X2 + 1);
-	sr32(CM_REG(CLKSEL_DSS), 8, 5, PER_M3X2);
+	sr32(OMAP3_CM_REG(CLKSEL_DSS), 8, 5, PER_M3X2 + 1);
+	sr32(OMAP3_CM_REG(CLKSEL_DSS), 8, 5, PER_M3X2);
 
 	/* Set M2 */
-	sr32(CM_REG(CLKSEL3_PLL), 0, 5, dp->m2 + 1);
-	sr32(CM_REG(CLKSEL3_PLL), 0, 5, dp->m2);
+	sr32(OMAP3_CM_REG(CLKSEL3_PLL), 0, 5, dp->m2 + 1);
+	sr32(OMAP3_CM_REG(CLKSEL3_PLL), 0, 5, dp->m2);
 
 	/* M (PERIPH_DPLL_MULT): CM_CLKSEL2_PLL[8:18] */
-	sr32(CM_REG(CLKSEL2_PLL), 8, 11, dp->m);
+	sr32(OMAP3_CM_REG(CLKSEL2_PLL), 8, 11, dp->m);
 
 	/* N (PERIPH_DPLL_DIV): CM_CLKSEL2_PLL[0:6] */
-	sr32(CM_REG(CLKSEL2_PLL), 0, 7, dp->n);
+	sr32(OMAP3_CM_REG(CLKSEL2_PLL), 0, 7, dp->n);
 
 	/* FREQSEL (PERIPH_DPLL_FREQSEL): CM_CLKEN_PLL[20:23] */
-	sr32(CM_REG(CLKEN_PLL), 20, 4, dp->fsel);
+	sr32(OMAP3_CM_REG(CLKEN_PLL), 20, 4, dp->fsel);
 
 	/* LOCK MODE (EN_PERIPH_DPLL): CM_CLKEN_PLL[16:18] */
-	sr32(CM_REG(CLKEN_PLL), 16, 3, PLL_LOCK);
-	wait_on_value((0x1 << 1), 2, CM_REG(IDLEST_CKGEN), LDELAY);
+	sr32(OMAP3_CM_REG(CLKEN_PLL), 16, 3, PLL_LOCK);
+	wait_on_value((0x1 << 1), 2, OMAP3_CM_REG(IDLEST_CKGEN), LDELAY);
 }
 
 static struct dpll_param mpu_dpll_param_34x_es1[] = {
@@ -316,16 +316,16 @@ static void init_mpu_dpll_34x(u32 cpu_rev, u32 clk_sel)
 	dp += clk_sel;
 
 	/* M2 (MPU_DPLL_CLKOUT_DIV) : CM_CLKSEL2_PLL_MPU[0:4] */
-	sr32(CM_REG(CLKSEL2_PLL_MPU), 0, 5, dp->m2);
+	sr32(OMAP3_CM_REG(CLKSEL2_PLL_MPU), 0, 5, dp->m2);
 
 	/* M (MPU_DPLL_MULT) : CM_CLKSEL2_PLL_MPU[8:18] */
-	sr32(CM_REG(CLKSEL1_PLL_MPU), 8, 11, dp->m);
+	sr32(OMAP3_CM_REG(CLKSEL1_PLL_MPU), 8, 11, dp->m);
 
 	/* N (MPU_DPLL_DIV) : CM_CLKSEL2_PLL_MPU[0:6] */
-	sr32(CM_REG(CLKSEL1_PLL_MPU), 0, 7, dp->n);
+	sr32(OMAP3_CM_REG(CLKSEL1_PLL_MPU), 0, 7, dp->n);
 
 	/* FREQSEL (MPU_DPLL_FREQSEL) : CM_CLKEN_PLL_MPU[4:7] */
-	sr32(CM_REG(CLKEN_PLL_MPU), 4, 4, dp->fsel);
+	sr32(OMAP3_CM_REG(CLKEN_PLL_MPU), 4, 4, dp->fsel);
 }
 
 static struct dpll_param iva_dpll_param_34x_es1[] = {
@@ -362,24 +362,24 @@ static void init_iva_dpll_34x(u32 cpu_rev, u32 clk_sel)
 	dp += clk_sel;
 
 	/* EN_IVA2_DPLL : CM_CLKEN_PLL_IVA2[0:2] */
-	sr32(CM_REG(CLKEN_PLL_IVA2), 0, 3, PLL_STOP);
-	wait_on_value((0x1 << 0), 0, CM_REG(IDLEST_PLL_IVA2), LDELAY);
+	sr32(OMAP3_CM_REG(CLKEN_PLL_IVA2), 0, 3, PLL_STOP);
+	wait_on_value((0x1 << 0), 0, OMAP3_CM_REG(IDLEST_PLL_IVA2), LDELAY);
 
 	/* M2 (IVA2_DPLL_CLKOUT_DIV) : CM_CLKSEL2_PLL_IVA2[0:4] */
-	sr32(CM_REG(CLKSEL2_PLL_IVA2), 0, 5, dp->m2);
+	sr32(OMAP3_CM_REG(CLKSEL2_PLL_IVA2), 0, 5, dp->m2);
 
 	/* M (IVA2_DPLL_MULT) : CM_CLKSEL1_PLL_IVA2[8:18] */
-	sr32(CM_REG(CLKSEL1_PLL_IVA2), 8, 11, dp->m);
+	sr32(OMAP3_CM_REG(CLKSEL1_PLL_IVA2), 8, 11, dp->m);
 
 	/* N (IVA2_DPLL_DIV) : CM_CLKSEL1_PLL_IVA2[0:6] */
-	sr32(CM_REG(CLKSEL1_PLL_IVA2), 0, 7, dp->n);
+	sr32(OMAP3_CM_REG(CLKSEL1_PLL_IVA2), 0, 7, dp->n);
 
 	/* FREQSEL (IVA2_DPLL_FREQSEL) : CM_CLKEN_PLL_IVA2[4:7] */
-	sr32(CM_REG(CLKEN_PLL_IVA2), 4, 4, dp->fsel);
+	sr32(OMAP3_CM_REG(CLKEN_PLL_IVA2), 4, 4, dp->fsel);
 
 	/* LOCK (MODE (EN_IVA2_DPLL) : CM_CLKEN_PLL_IVA2[0:2] */
-	sr32(CM_REG(CLKEN_PLL_IVA2), 0, 3, PLL_LOCK);
-	wait_on_value((0x1 << 0), 1, CM_REG(IDLEST_PLL_IVA2), LDELAY);
+	sr32(OMAP3_CM_REG(CLKEN_PLL_IVA2), 0, 3, PLL_LOCK);
+	wait_on_value((0x1 << 0), 1, OMAP3_CM_REG(IDLEST_PLL_IVA2), LDELAY);
 }
 
 /* FIXME: All values correspond to 26MHz only */
@@ -404,37 +404,37 @@ static void init_core_dpll_36x(u32 cpu_rev, u32 clk_sel)
 	dp += clk_sel;
 
 	if (running_in_sram()) {
-		sr32(CM_REG(CLKEN_PLL), 0, 3, PLL_FAST_RELOCK_BYPASS);
-		wait_on_value((0x1 << 0), 0, CM_REG(IDLEST_CKGEN), LDELAY);
+		sr32(OMAP3_CM_REG(CLKEN_PLL), 0, 3, PLL_FAST_RELOCK_BYPASS);
+		wait_on_value((0x1 << 0), 0, OMAP3_CM_REG(IDLEST_CKGEN), LDELAY);
 
 		/* CM_CLKSEL1_EMU[DIV_DPLL3] */
-		sr32(CM_REG(CLKSEL1_EMU), 16, 5, CORE_M3X2);
+		sr32(OMAP3_CM_REG(CLKSEL1_EMU), 16, 5, CORE_M3X2);
 
 		/* M2 (CORE_DPLL_CLKOUT_DIV): CM_CLKSEL1_PLL[27:31] */
-		sr32(CM_REG(CLKSEL1_PLL), 27, 5, dp->m2);
+		sr32(OMAP3_CM_REG(CLKSEL1_PLL), 27, 5, dp->m2);
 
 		/* M (CORE_DPLL_MULT): CM_CLKSEL1_PLL[16:26] */
-		sr32(CM_REG(CLKSEL1_PLL), 16, 11, dp->m);
+		sr32(OMAP3_CM_REG(CLKSEL1_PLL), 16, 11, dp->m);
 
 		/* N (CORE_DPLL_DIV): CM_CLKSEL1_PLL[8:14] */
-		sr32(CM_REG(CLKSEL1_PLL), 8, 7, dp->n);
+		sr32(OMAP3_CM_REG(CLKSEL1_PLL), 8, 7, dp->n);
 
 		/* Set source CM_96M_FCLK: CM_CLKSEL1_PLL[6] */
-		sr32(CM_REG(CLKSEL1_PLL), 6, 1, 0);
+		sr32(OMAP3_CM_REG(CLKSEL1_PLL), 6, 1, 0);
 
-		sr32(CM_REG(CLKSEL_CORE), 8, 4, CORE_SSI_DIV);
-		sr32(CM_REG(CLKSEL_CORE), 4, 2, CORE_FUSB_DIV);
-		sr32(CM_REG(CLKSEL_CORE), 2, 2, CORE_L4_DIV);
-		sr32(CM_REG(CLKSEL_CORE), 0, 2, CORE_L3_DIV);
-		sr32(CM_REG(CLKSEL_GFX),  0, 3, GFX_DIV_36X);
-		sr32(CM_REG(CLKSEL_WKUP), 1, 2, WKUP_RSM);
+		sr32(OMAP3_CM_REG(CLKSEL_CORE), 8, 4, CORE_SSI_DIV);
+		sr32(OMAP3_CM_REG(CLKSEL_CORE), 4, 2, CORE_FUSB_DIV);
+		sr32(OMAP3_CM_REG(CLKSEL_CORE), 2, 2, CORE_L4_DIV);
+		sr32(OMAP3_CM_REG(CLKSEL_CORE), 0, 2, CORE_L3_DIV);
+		sr32(OMAP3_CM_REG(CLKSEL_GFX),  0, 3, GFX_DIV_36X);
+		sr32(OMAP3_CM_REG(CLKSEL_WKUP), 1, 2, WKUP_RSM);
 
 		/* FREQSEL (CORE_DPLL_FREQSEL): CM_CLKEN_PLL[4:7] */
-		sr32(CM_REG(CLKEN_PLL), 4, 4, dp->fsel);
+		sr32(OMAP3_CM_REG(CLKEN_PLL), 4, 4, dp->fsel);
 
 		/* Lock Mode */
-		sr32(CM_REG(CLKEN_PLL), 0, 3, PLL_LOCK);
-		wait_on_value((0x1 << 0), 1, CM_REG(IDLEST_CKGEN), LDELAY);
+		sr32(OMAP3_CM_REG(CLKEN_PLL), 0, 3, PLL_LOCK);
+		wait_on_value((0x1 << 0), 1, OMAP3_CM_REG(IDLEST_CKGEN), LDELAY);
 	} else if (running_in_flash()) {
 		/***Oopps.. Wrong .config!! *****/
 		hang();
@@ -462,36 +462,36 @@ static void init_per_dpll_36x(u32 cpu_rev, u32 clk_sel)
 
 	dp += clk_sel;
 
-	sr32(CM_REG(CLKEN_PLL), 16, 3, PLL_STOP);
-	wait_on_value((0x1 << 1), 0, CM_REG(IDLEST_CKGEN), LDELAY);
+	sr32(OMAP3_CM_REG(CLKEN_PLL), 16, 3, PLL_STOP);
+	wait_on_value((0x1 << 1), 0, OMAP3_CM_REG(IDLEST_CKGEN), LDELAY);
 
 	/* Set M6 (DIV_DPLL4): CM_CLKSEL1_EMU[24:29] */
-	sr32(CM_REG(CLKSEL1_EMU), 24, 6, dp->m6);
+	sr32(OMAP3_CM_REG(CLKSEL1_EMU), 24, 6, dp->m6);
 
 	/* Set M5 (CLKSEL_CAM): CM_CLKSEL_CAM[0:5] */
-	sr32(CM_REG(CLKSEL_CAM), 0, 6, dp->m5);
+	sr32(OMAP3_CM_REG(CLKSEL_CAM), 0, 6, dp->m5);
 
 	/* Set M4 (CLKSEL_DSS1): CM_CLKSEL_DSS[0:5] */
-	sr32(CM_REG(CLKSEL_DSS), 0, 6, dp->m4);
+	sr32(OMAP3_CM_REG(CLKSEL_DSS), 0, 6, dp->m4);
 
 	/* Set M3 (CLKSEL_DSS2): CM_CLKSEL_DSS[8:13] */
-	sr32(CM_REG(CLKSEL_DSS), 8, 6, dp->m3);
+	sr32(OMAP3_CM_REG(CLKSEL_DSS), 8, 6, dp->m3);
 
 	/* Set M2: CM_CLKSEL3_PLL[0:4] */
-	sr32(CM_REG(CLKSEL3_PLL), 0, 5, dp->m2);
+	sr32(OMAP3_CM_REG(CLKSEL3_PLL), 0, 5, dp->m2);
 
 	/* M (PERIPH_DPLL_MULT): CM_CLKSEL2_PLL[8:19] */
-	sr32(CM_REG(CLKSEL2_PLL), 8, 12, dp->m);
+	sr32(OMAP3_CM_REG(CLKSEL2_PLL), 8, 12, dp->m);
 
 	/* N (PERIPH_DPLL_DIV): CM_CLKSEL2_PLL[0:6] */
-	sr32(CM_REG(CLKSEL2_PLL), 0, 7, dp->n);
+	sr32(OMAP3_CM_REG(CLKSEL2_PLL), 0, 7, dp->n);
 
 	/* M2DIV (CLKSEL_96M): CM_CLKSEL_CORE[12:13] */
-	sr32(CM_REG(CLKSEL_CORE), 12, 2, dp->m2div);
+	sr32(OMAP3_CM_REG(CLKSEL_CORE), 12, 2, dp->m2div);
 
 	/* LOCK MODE (EN_PERIPH_DPLL): CM_CLKEN_PLL[16:18] */
-	sr32(CM_REG(CLKEN_PLL), 16, 3, PLL_LOCK);
-	wait_on_value((0x1 << 1), 2, CM_REG(IDLEST_CKGEN), LDELAY);
+	sr32(OMAP3_CM_REG(CLKEN_PLL), 16, 3, PLL_LOCK);
+	wait_on_value((0x1 << 1), 2, OMAP3_CM_REG(IDLEST_CKGEN), LDELAY);
 }
 
 /* FIXME: All values correspond to 26MHz only */
@@ -516,16 +516,16 @@ static void init_mpu_dpll_36x(u32 cpu_rev, u32 clk_sel)
 	dp += clk_sel;
 
 	/* M2 (MPU_DPLL_CLKOUT_DIV) : CM_CLKSEL2_PLL_MPU[0:4] */
-	sr32(CM_REG(CLKSEL2_PLL_MPU), 0, 5, dp->m2);
+	sr32(OMAP3_CM_REG(CLKSEL2_PLL_MPU), 0, 5, dp->m2);
 
 	/* M (MPU_DPLL_MULT) : CM_CLKSEL2_PLL_MPU[8:18] */
-	sr32(CM_REG(CLKSEL1_PLL_MPU), 8, 11, dp->m);
+	sr32(OMAP3_CM_REG(CLKSEL1_PLL_MPU), 8, 11, dp->m);
 
 	/* N (MPU_DPLL_DIV) : CM_CLKSEL2_PLL_MPU[0:6] */
-	sr32(CM_REG(CLKSEL1_PLL_MPU), 0, 7, dp->n);
+	sr32(OMAP3_CM_REG(CLKSEL1_PLL_MPU), 0, 7, dp->n);
 
 	/* FREQSEL (MPU_DPLL_FREQSEL) : CM_CLKEN_PLL_MPU[4:7] */
-	sr32(CM_REG(CLKEN_PLL_MPU), 4, 4, dp->fsel);
+	sr32(OMAP3_CM_REG(CLKEN_PLL_MPU), 4, 4, dp->fsel);
 }
 
 /* FIXME: All values correspond to 26MHz only */
@@ -550,24 +550,24 @@ static void init_iva_dpll_36x(u32 cpu_rev, u32 clk_sel)
 	dp += clk_sel;
 
 	/* EN_IVA2_DPLL : CM_CLKEN_PLL_IVA2[0:2] */
-	sr32(CM_REG(CLKEN_PLL_IVA2), 0, 3, PLL_STOP);
-	wait_on_value((0x1 << 0), 0, CM_REG(IDLEST_PLL_IVA2), LDELAY);
+	sr32(OMAP3_CM_REG(CLKEN_PLL_IVA2), 0, 3, PLL_STOP);
+	wait_on_value((0x1 << 0), 0, OMAP3_CM_REG(IDLEST_PLL_IVA2), LDELAY);
 
 	/* M2 (IVA2_DPLL_CLKOUT_DIV) : CM_CLKSEL2_PLL_IVA2[0:4] */
-	sr32(CM_REG(CLKSEL2_PLL_IVA2), 0, 5, dp->m2);
+	sr32(OMAP3_CM_REG(CLKSEL2_PLL_IVA2), 0, 5, dp->m2);
 
 	/* M (IVA2_DPLL_MULT) : CM_CLKSEL1_PLL_IVA2[8:18] */
-	sr32(CM_REG(CLKSEL1_PLL_IVA2), 8, 11, dp->m);
+	sr32(OMAP3_CM_REG(CLKSEL1_PLL_IVA2), 8, 11, dp->m);
 
 	/* N (IVA2_DPLL_DIV) : CM_CLKSEL1_PLL_IVA2[0:6] */
-	sr32(CM_REG(CLKSEL1_PLL_IVA2), 0, 7, dp->n);
+	sr32(OMAP3_CM_REG(CLKSEL1_PLL_IVA2), 0, 7, dp->n);
 
 	/* FREQSEL (IVA2_DPLL_FREQSEL) : CM_CLKEN_PLL_IVA2[4:7] */
-	sr32(CM_REG(CLKEN_PLL_IVA2), 4, 4, dp->fsel);
+	sr32(OMAP3_CM_REG(CLKEN_PLL_IVA2), 4, 4, dp->fsel);
 
 	/* LOCK (MODE (EN_IVA2_DPLL) : CM_CLKEN_PLL_IVA2[0:2] */
-	sr32(CM_REG(CLKEN_PLL_IVA2), 0, 3, PLL_LOCK);
-	wait_on_value((0x1 << 0), 1, CM_REG(IDLEST_PLL_IVA2), LDELAY);
+	sr32(OMAP3_CM_REG(CLKEN_PLL_IVA2), 0, 3, PLL_LOCK);
+	wait_on_value((0x1 << 0), 1, OMAP3_CM_REG(IDLEST_PLL_IVA2), LDELAY);
 }
 
 /**
@@ -590,7 +590,7 @@ void prcm_init(void)
 	osc_clk = get_osc_clk_speed();
 	get_sys_clkin_sel(osc_clk, &sys_clkin_sel);
 	/* set input crystal speed */
-	sr32(PRM_REG(CLKSEL), 0, 3, sys_clkin_sel);
+	sr32(OMAP3_PRM_REG(CLKSEL), 0, 3, sys_clkin_sel);
 
 	/*
 	 * OMAP3430:
@@ -602,19 +602,19 @@ void prcm_init(void)
 	 */
 	if ((cpu_type != CPU_3630) && (sys_clkin_sel > 2)) {
 		/* input clock divider */
-		sr32(PRM_REG(CLKSRC_CTRL), 6, 2, 2);
+		sr32(OMAP3_PRM_REG(CLKSRC_CTRL), 6, 2, 2);
 		clk_index = sys_clkin_sel / 2;
 	} else {
 		/* input clock divider */
-		sr32(PRM_REG(CLKSRC_CTRL), 6, 2, 1);
+		sr32(OMAP3_PRM_REG(CLKSRC_CTRL), 6, 2, 1);
 		clk_index = sys_clkin_sel;
 	}
 
 	/*
 	 * Unlock the MPU PLL. Run slow while clocks are being configured.
 	 */
-	sr32(CM_REG(CLKEN_PLL_MPU), 0, 3, PLL_LOW_POWER_BYPASS);
-	wait_on_value((0x1 << 0), 0, CM_REG(IDLEST_PLL_MPU), LDELAY);
+	sr32(OMAP3_CM_REG(CLKEN_PLL_MPU), 0, 3, PLL_LOW_POWER_BYPASS);
+	wait_on_value((0x1 << 0), 0, OMAP3_CM_REG(IDLEST_PLL_MPU), LDELAY);
 
 	if (cpu_type == CPU_3430) {
 		init_core_dpll_34x(cpu_rev, clk_index);
@@ -636,12 +636,12 @@ void prcm_init(void)
 	/*
 	 * Clock configuration complete. Lock MPU PLL.
 	 */
-	sr32(CM_REG(CLKEN_PLL_MPU), 0, 3, PLL_LOCK);
-	wait_on_value((0x1 << 0), 1, CM_REG(IDLEST_PLL_MPU), LDELAY);
+	sr32(OMAP3_CM_REG(CLKEN_PLL_MPU), 0, 3, PLL_LOCK);
+	wait_on_value((0x1 << 0), 1, OMAP3_CM_REG(IDLEST_PLL_MPU), LDELAY);
 
 	/* Set up GPTimers to sys_clk source only */
-	sr32(CM_REG(CLKSEL_PER), 0, 8, 0xff);
-	sr32(CM_REG(CLKSEL_WKUP), 0, 1, 1);
+	sr32(OMAP3_CM_REG(CLKSEL_PER), 0, 8, 0xff);
+	sr32(OMAP3_CM_REG(CLKSEL_WKUP), 0, 1, 1);
 
 	sdelay(5000);
 
@@ -663,11 +663,11 @@ void prcm_init(void)
 static void per_clocks_enable(void)
 {
 	/* Enable GP2 timer. */
-	sr32(CM_REG(CLKSEL_PER), 0, 1, 0x1);	/* GPT2 = sys clk */
-	sr32(CM_REG(ICLKEN_PER), 3, 1, 0x1);	/* ICKen GPT2 */
-	sr32(CM_REG(FCLKEN_PER), 3, 1, 0x1);	/* FCKen GPT2 */
+	sr32(OMAP3_CM_REG(CLKSEL_PER), 0, 1, 0x1);	/* GPT2 = sys clk */
+	sr32(OMAP3_CM_REG(ICLKEN_PER), 3, 1, 0x1);	/* ICKen GPT2 */
+	sr32(OMAP3_CM_REG(FCLKEN_PER), 3, 1, 0x1);	/* FCKen GPT2 */
 	/* Enable the ICLK for 32K Sync Timer as its used in udelay */
-	sr32(CM_REG(ICLKEN_WKUP), 2, 1, 0x1);
+	sr32(OMAP3_CM_REG(ICLKEN_WKUP), 2, 1, 0x1);
 
 #define FCK_IVA2_ON	0x00000001
 #define FCK_CORE1_ON	0x03fffe29
@@ -681,18 +681,18 @@ static void per_clocks_enable(void)
 #define ICK_CAM_ON	0x00000001
 #define FCK_PER_ON	0x0003ffff
 #define ICK_PER_ON	0x0003ffff
-	sr32(CM_REG(FCLKEN_IVA2), 0, 32, FCK_IVA2_ON);
-	sr32(CM_REG(FCLKEN1_CORE), 0, 32, FCK_CORE1_ON);
-	sr32(CM_REG(ICLKEN1_CORE), 0, 32, ICK_CORE1_ON);
-	sr32(CM_REG(ICLKEN2_CORE), 0, 32, ICK_CORE2_ON);
-	sr32(CM_REG(FCLKEN_WKUP), 0, 32, FCK_WKUP_ON);
-	sr32(CM_REG(ICLKEN_WKUP), 0, 32, ICK_WKUP_ON);
-	sr32(CM_REG(FCLKEN_DSS), 0, 32, FCK_DSS_ON);
-	sr32(CM_REG(ICLKEN_DSS), 0, 32, ICK_DSS_ON);
-	sr32(CM_REG(FCLKEN_CAM), 0, 32, FCK_CAM_ON);
-	sr32(CM_REG(ICLKEN_CAM), 0, 32, ICK_CAM_ON);
-	sr32(CM_REG(FCLKEN_PER), 0, 32, FCK_PER_ON);
-	sr32(CM_REG(ICLKEN_PER), 0, 32, ICK_PER_ON);
+	sr32(OMAP3_CM_REG(FCLKEN_IVA2), 0, 32, FCK_IVA2_ON);
+	sr32(OMAP3_CM_REG(FCLKEN1_CORE), 0, 32, FCK_CORE1_ON);
+	sr32(OMAP3_CM_REG(ICLKEN1_CORE), 0, 32, ICK_CORE1_ON);
+	sr32(OMAP3_CM_REG(ICLKEN2_CORE), 0, 32, ICK_CORE2_ON);
+	sr32(OMAP3_CM_REG(FCLKEN_WKUP), 0, 32, FCK_WKUP_ON);
+	sr32(OMAP3_CM_REG(ICLKEN_WKUP), 0, 32, ICK_WKUP_ON);
+	sr32(OMAP3_CM_REG(FCLKEN_DSS), 0, 32, FCK_DSS_ON);
+	sr32(OMAP3_CM_REG(ICLKEN_DSS), 0, 32, ICK_DSS_ON);
+	sr32(OMAP3_CM_REG(FCLKEN_CAM), 0, 32, FCK_CAM_ON);
+	sr32(OMAP3_CM_REG(ICLKEN_CAM), 0, 32, ICK_CAM_ON);
+	sr32(OMAP3_CM_REG(FCLKEN_PER), 0, 32, FCK_PER_ON);
+	sr32(OMAP3_CM_REG(ICLKEN_PER), 0, 32, ICK_PER_ON);
 
 	/* Settle down my friend */
 	sdelay(1000);
diff --git a/arch/arm/mach-omap/omap3_generic.c b/arch/arm/mach-omap/omap3_generic.c
index a209129..8487f07 100644
--- a/arch/arm/mach-omap/omap3_generic.c
+++ b/arch/arm/mach-omap/omap3_generic.c
@@ -53,7 +53,7 @@
  */
 void __noreturn reset_cpu(unsigned long addr)
 {
-	writel(OMAP3_PRM_RSTCTRL_RESET, PRM_REG(RSTCTRL));
+	writel(OMAP3_PRM_RSTCTRL_RESET, OMAP3_PRM_REG(RSTCTRL));
 
 	while (1);
 }
@@ -69,7 +69,7 @@ u32 get_cpu_type(void)
 	u32 idcode_val;
 	u16 hawkeye;
 
-	idcode_val = readl(IDCODE_REG);
+	idcode_val = readl(OMAP3_IDCODE_REG);
 
 	hawkeye = get_hawkeye(idcode_val);
 
@@ -98,7 +98,7 @@ u32 get_cpu_rev(void)
 	u32 idcode_val;
 	u32 version, retval;
 
-	idcode_val = readl(IDCODE_REG);
+	idcode_val = readl(OMAP3_IDCODE_REG);
 
 	version = get_version(idcode_val);
 
@@ -167,7 +167,7 @@ u32 get_sdr_cs_size(u32 offset)
 {
 	u32 size;
 	/* get ram size field */
-	size = readl(SDRC_REG(MCFG_0) + offset) >> 8;
+	size = readl(OMAP3_SDRC_REG(MCFG_0) + offset) >> 8;
 	size &= 0x3FF;		/* remove unwanted bits */
 	size *= 2 * (1024 * 1024);	/* find size in MB */
 	return size;
@@ -183,7 +183,7 @@ u32 get_sdr_cs1_base(void)
 	u32 base;
 	u32 cs_cfg;
 
-	cs_cfg = readl(SDRC_REG(CS_CFG));
+	cs_cfg = readl(OMAP3_SDRC_REG(CS_CFG));
 	/* get ram size field */
 	base = (cs_cfg & 0x0000000F) << 2; /* get CS1STARTHIGH */
 	base = base | ((cs_cfg & 0x00000300) >> 8); /* get CS1STARTLOW */
@@ -201,7 +201,7 @@ EXPORT_SYMBOL(get_sdr_cs1_base);
  */
 inline u32 get_sysboot_value(void)
 {
-	return (0x0000003F & readl(CONTROL_REG(STATUS)));
+	return (0x0000003F & readl(OMAP3_CONTROL_REG(STATUS)));
 }
 
 /**
@@ -290,7 +290,7 @@ u32 get_boot_type(void)
 u32 get_device_type(void)
 {
 	int mode;
-	mode = readl(CONTROL_REG(STATUS)) & (DEVICE_MASK);
+	mode = readl(OMAP3_CONTROL_REG(STATUS)) & (DEVICE_MASK);
 	return (mode >>= 8);
 }
 
@@ -375,17 +375,17 @@ static void watchdog_init(void)
 {
 	int pending = 1;
 
-	sr32(CM_REG(FCLKEN_WKUP), 5, 1, 1);
-	sr32(CM_REG(ICLKEN_WKUP), 5, 1, 1);
-	wait_on_value((0x1 << 5), 0x20, CM_REG(IDLEST_WKUP), 5);
+	sr32(OMAP3_CM_REG(FCLKEN_WKUP), 5, 1, 1);
+	sr32(OMAP3_CM_REG(ICLKEN_WKUP), 5, 1, 1);
+	wait_on_value((0x1 << 5), 0x20, OMAP3_CM_REG(IDLEST_WKUP), 5);
 
-	writel(WDT_DISABLE_CODE1, WDT_REG(WSPR));
+	writel(WDT_DISABLE_CODE1, OMAP3_WDT_REG(WSPR));
 
 	do {
-		pending = readl(WDT_REG(WWPS));
+		pending = readl(OMAP3_WDT_REG(WWPS));
 	} while (pending);
 
-	writel(WDT_DISABLE_CODE2, WDT_REG(WSPR));
+	writel(WDT_DISABLE_CODE2, OMAP3_WDT_REG(WSPR));
 }
 
 /**
@@ -494,17 +494,17 @@ const struct gpmc_config omap3_nand_cfg = {
 #ifndef __PBL__
 static int omap3_gpio_init(void)
 {
-	add_generic_device("omap-gpio", 0, NULL, OMAP_GPIO1_BASE,
+	add_generic_device("omap-gpio", 0, NULL, OMAP3_GPIO1_BASE,
 					0xf00, IORESOURCE_MEM, NULL);
-	add_generic_device("omap-gpio", 1, NULL, OMAP_GPIO2_BASE,
+	add_generic_device("omap-gpio", 1, NULL, OMAP3_GPIO2_BASE,
 					0xf00, IORESOURCE_MEM, NULL);
-	add_generic_device("omap-gpio", 2, NULL, OMAP_GPIO3_BASE,
+	add_generic_device("omap-gpio", 2, NULL, OMAP3_GPIO3_BASE,
 					0xf00, IORESOURCE_MEM, NULL);
-	add_generic_device("omap-gpio", 3, NULL, OMAP_GPIO4_BASE,
+	add_generic_device("omap-gpio", 3, NULL, OMAP3_GPIO4_BASE,
 					0xf00, IORESOURCE_MEM, NULL);
-	add_generic_device("omap-gpio", 4, NULL, OMAP_GPIO5_BASE,
+	add_generic_device("omap-gpio", 4, NULL, OMAP3_GPIO5_BASE,
 					0xf00, IORESOURCE_MEM, NULL);
-	add_generic_device("omap-gpio", 5, NULL, OMAP_GPIO6_BASE,
+	add_generic_device("omap-gpio", 5, NULL, OMAP3_GPIO6_BASE,
 					0xf00, IORESOURCE_MEM, NULL);
 
 	return 0;
diff --git a/drivers/usb/host/ehci-omap.c b/drivers/usb/host/ehci-omap.c
index e2ce65f..fc5a54f 100644
--- a/drivers/usb/host/ehci-omap.c
+++ b/drivers/usb/host/ehci-omap.c
@@ -30,37 +30,37 @@ void omap_usb_utmi_init(struct omap_hcd *omap, u8 tll_channel_mask)
 
 	/* Program the 3 TLL channels upfront */
 	for (i = 0; i < OMAP_TLL_CHANNEL_COUNT; i++) {
-		reg = __raw_readl(OMAP_USBTLL_BASE + OMAP_TLL_CHANNEL_CONF(i));
+		reg = __raw_readl(OMAP3_USBTLL_BASE + OMAP_TLL_CHANNEL_CONF(i));
 
 		/* Disable AutoIdle, BitStuffing and use SDR Mode */
 		reg &= ~(OMAP_TLL_CHANNEL_CONF_UTMIAUTOIDLE
 				| OMAP_TLL_CHANNEL_CONF_ULPINOBITSTUFF
 				| OMAP_TLL_CHANNEL_CONF_ULPIDDRMODE);
-		__raw_writel(reg, OMAP_USBTLL_BASE + OMAP_TLL_CHANNEL_CONF(i));
+		__raw_writel(reg, OMAP3_USBTLL_BASE + OMAP_TLL_CHANNEL_CONF(i));
 	}
 
 	/* Program Common TLL register */
-	reg = __raw_readl(OMAP_USBTLL_BASE + OMAP_TLL_SHARED_CONF);
+	reg = __raw_readl(OMAP3_USBTLL_BASE + OMAP_TLL_SHARED_CONF);
 	reg |= (OMAP_TLL_SHARED_CONF_FCLK_IS_ON
 			| OMAP_TLL_SHARED_CONF_USB_DIVRATION
 			| OMAP_TLL_SHARED_CONF_USB_180D_SDR_EN);
 	reg &= ~OMAP_TLL_SHARED_CONF_USB_90D_DDR_EN;
 
-	__raw_writel(reg, OMAP_USBTLL_BASE + OMAP_TLL_SHARED_CONF);
+	__raw_writel(reg, OMAP3_USBTLL_BASE + OMAP_TLL_SHARED_CONF);
 
 	/* Enable channels now */
 	for (i = 0; i < OMAP_TLL_CHANNEL_COUNT; i++) {
-		reg = __raw_readl(OMAP_USBTLL_BASE + OMAP_TLL_CHANNEL_CONF(i));
+		reg = __raw_readl(OMAP3_USBTLL_BASE + OMAP_TLL_CHANNEL_CONF(i));
 
 		/* Enable only the reg that is needed */
 		if (!(tll_channel_mask & 1<<i))
 			continue;
 
 		reg |= OMAP_TLL_CHANNEL_CONF_CHANEN;
-		__raw_writel(reg, OMAP_USBTLL_BASE + OMAP_TLL_CHANNEL_CONF(i));
+		__raw_writel(reg, OMAP3_USBTLL_BASE + OMAP_TLL_CHANNEL_CONF(i));
 
 		__raw_writeb(0xbe,
-			OMAP_USBTLL_BASE + OMAP_TLL_ULPI_SCRATCH_REGISTER(i));
+			OMAP3_USBTLL_BASE + OMAP_TLL_ULPI_SCRATCH_REGISTER(i));
 	}
 }
 
@@ -78,56 +78,56 @@ int ehci_omap_init(struct omap_hcd *omap)
 	}
 
 
-	v = __raw_readl(CM_REG(CLKSEL4_PLL));
+	v = __raw_readl(OMAP3_CM_REG(CLKSEL4_PLL));
 	v |= (12 << OMAP3430ES2_PERIPH2_DPLL_DIV_SHIFT);
 	v |= (120 << OMAP3430ES2_PERIPH2_DPLL_MULT_SHIFT);
-	__raw_writel(v, CM_REG(CLKSEL4_PLL));
+	__raw_writel(v, OMAP3_CM_REG(CLKSEL4_PLL));
 
-	v = __raw_readl(CM_REG(CLKSEL5_PLL));
+	v = __raw_readl(OMAP3_CM_REG(CLKSEL5_PLL));
 	v |= (1 << OMAP3430ES2_DIV_120M_SHIFT);
-	__raw_writel(v, CM_REG(CLKSEL5_PLL));
+	__raw_writel(v, OMAP3_CM_REG(CLKSEL5_PLL));
 
-	v = __raw_readl(CM_REG(CLKEN2_PLL));
+	v = __raw_readl(OMAP3_CM_REG(CLKEN2_PLL));
 	v |= (7 << OMAP3430ES2_PERIPH2_DPLL_FREQSEL_SHIFT);
 	v |= (7 << OMAP3430ES2_EN_PERIPH2_DPLL_SHIFT);
-	__raw_writel(v, CM_REG(CLKEN2_PLL));
+	__raw_writel(v, OMAP3_CM_REG(CLKEN2_PLL));
 
 	/* PRCM settings for USBHOST:
 	* Interface clk un-related to domain transition
 	*/
 
-	v = __raw_readl(CM_REG(AIDLE_USBH));
+	v = __raw_readl(OMAP3_CM_REG(AIDLE_USBH));
 	v |= (0 << OMAP3430ES2_AUTO_USBHOST_SHIFT);
-	__raw_writel(v, CM_REG(AIDLE_USBH));
+	__raw_writel(v, OMAP3_CM_REG(AIDLE_USBH));
 
         /* Disable sleep dependency with MPU and IVA */
 
-	v = __raw_readl(CM_REG(SLEEPD_USBH));
+	v = __raw_readl(OMAP3_CM_REG(SLEEPD_USBH));
 	v |= (0 << OMAP3430ES2_EN_MPU_SHIFT);
 	v |= (0 << OMAP3430ES2_EN_IVA2_SHIFT);
-	__raw_writel(v, CM_REG(SLEEPD_USBH));
+	__raw_writel(v, OMAP3_CM_REG(SLEEPD_USBH));
 
 	/* Disable Automatic transition of clock */
-	v = __raw_readl(CM_REG(CLKSTCTRL_USBH));
+	v = __raw_readl(OMAP3_CM_REG(CLKSTCTRL_USBH));
 	v |= (0 << OMAP3430ES2_CLKTRCTRL_USBHOST_SHIFT);
-	__raw_writel(v, CM_REG(CLKSTCTRL_USBH));
+	__raw_writel(v, OMAP3_CM_REG(CLKSTCTRL_USBH));
 
 	/* Enable Clocks for USBHOST */
 
 	/* enable usbhost_ick */
-	v = __raw_readl(CM_REG(ICLKEN_USBH));
+	v = __raw_readl(OMAP3_CM_REG(ICLKEN_USBH));
 	v |= (1 << OMAP3430ES2_EN_USBHOST_SHIFT);
-	__raw_writel(v, CM_REG(ICLKEN_USBH));
+	__raw_writel(v, OMAP3_CM_REG(ICLKEN_USBH));
 
 	/* enable usbhost_120m_fck */
-	v = __raw_readl(CM_REG(FCLKEN_USBH));
+	v = __raw_readl(OMAP3_CM_REG(FCLKEN_USBH));
 	v |= (1 << OMAP3430ES2_EN_USBHOST2_SHIFT);
-	__raw_writel(v, CM_REG(FCLKEN_USBH));
+	__raw_writel(v, OMAP3_CM_REG(FCLKEN_USBH));
 
 	/* enable usbhost_48m_fck */
-	v = __raw_readl(CM_REG(FCLKEN_USBH));
+	v = __raw_readl(OMAP3_CM_REG(FCLKEN_USBH));
 	v |= (1 << OMAP3430ES2_EN_USBHOST1_SHIFT);
-	__raw_writel(v, CM_REG(FCLKEN_USBH));
+	__raw_writel(v, OMAP3_CM_REG(FCLKEN_USBH));
 
 	if (omap->phy_reset) {
 		/* Refer: ISSUE1 */
@@ -144,28 +144,28 @@ int ehci_omap_init(struct omap_hcd *omap)
 	}
 
 	/* enable usbtll_fck  */
-	v = __raw_readl(CM_REG(FCLKEN3_CORE));
+	v = __raw_readl(OMAP3_CM_REG(FCLKEN3_CORE));
 	v |= (1 << OMAP3430ES2_EN_USBTLL_SHIFT);
-	__raw_writel(v, CM_REG(FCLKEN3_CORE));
+	__raw_writel(v, OMAP3_CM_REG(FCLKEN3_CORE));
 
 	/* Configure TLL for 60Mhz clk for ULPI */
 	/* enable usbtll_ick */
-	v = __raw_readl(CM_REG(ICLKEN3_CORE));
+	v = __raw_readl(OMAP3_CM_REG(ICLKEN3_CORE));
 	v |= (1 << OMAP3430ES2_EN_USBTLL_SHIFT);
-	__raw_writel(v, CM_REG(ICLKEN3_CORE));
+	__raw_writel(v, OMAP3_CM_REG(ICLKEN3_CORE));
 
-	v = __raw_readl(CM_REG(AIDLE3_CORE));
+	v = __raw_readl(OMAP3_CM_REG(AIDLE3_CORE));
 	v |= (0 << OMAP3430ES2_AUTO_USBTLL_SHIFT);
-	__raw_writel(v, CM_REG(AIDLE3_CORE));
+	__raw_writel(v, OMAP3_CM_REG(AIDLE3_CORE));
 
 	/* perform TLL soft reset, and wait until reset is complete */
 	__raw_writel(OMAP_USBTLL_SYSCONFIG_SOFTRESET,
-				OMAP_USBTLL_BASE + OMAP_USBTLL_SYSCONFIG);
+				OMAP3_USBTLL_BASE + OMAP_USBTLL_SYSCONFIG);
 
 	/* Wait for TLL reset to complete */
 	start = get_time_ns();
 
-	while (!(__raw_readl(OMAP_USBTLL_BASE + OMAP_USBTLL_SYSSTATUS)
+	while (!(__raw_readl(OMAP3_USBTLL_BASE + OMAP_USBTLL_SYSSTATUS)
 			& OMAP_USBTLL_SYSSTATUS_RESETDONE)) {
 		if (is_timeout(start, timeout * USECOND)) {
 			return -ETIMEDOUT;
@@ -175,18 +175,18 @@ int ehci_omap_init(struct omap_hcd *omap)
 	/* (1<<3) = no idle mode only for initial debugging */
 	__raw_writel(OMAP_USBTLL_SYSCONFIG_ENAWAKEUP |
 			OMAP_USBTLL_SYSCONFIG_SIDLEMODE |
-			OMAP_USBTLL_SYSCONFIG_CACTIVITY, OMAP_USBTLL_BASE + OMAP_USBTLL_SYSCONFIG);
+			OMAP_USBTLL_SYSCONFIG_CACTIVITY, OMAP3_USBTLL_BASE + OMAP_USBTLL_SYSCONFIG);
 
 	/* Put UHH in NoIdle/NoStandby mode */
-	v = __raw_readl(OMAP_UHH_CONFIG_BASE + OMAP_UHH_SYSCONFIG);
+	v = __raw_readl(OMAP3_UHH_CONFIG_BASE + OMAP_UHH_SYSCONFIG);
 	v |= (OMAP_UHH_SYSCONFIG_ENAWAKEUP
 			| OMAP_UHH_SYSCONFIG_SIDLEMODE
 			| OMAP_UHH_SYSCONFIG_CACTIVITY
 			| OMAP_UHH_SYSCONFIG_MIDLEMODE);
 	v &= ~OMAP_UHH_SYSCONFIG_AUTOIDLE;
-	__raw_writel(v, OMAP_UHH_CONFIG_BASE + OMAP_UHH_SYSCONFIG);
+	__raw_writel(v, OMAP3_UHH_CONFIG_BASE + OMAP_UHH_SYSCONFIG);
 
-	v = __raw_readl(OMAP_UHH_CONFIG_BASE + OMAP_UHH_HOSTCONFIG);
+	v = __raw_readl(OMAP3_UHH_CONFIG_BASE + OMAP_UHH_HOSTCONFIG);
 	/* setup ULPI bypass and burst configurations */
 	v |= (OMAP_UHH_HOSTCONFIG_INCR4_BURST_EN
 			| OMAP_UHH_HOSTCONFIG_INCR8_BURST_EN
@@ -225,7 +225,7 @@ int ehci_omap_init(struct omap_hcd *omap)
 			v |= OMAP_UHH_HOSTCONFIG_ULPI_P3_BYPASS;
 
 	}
-	__raw_writel(v, OMAP_UHH_CONFIG_BASE + OMAP_UHH_HOSTCONFIG);
+	__raw_writel(v, OMAP3_UHH_CONFIG_BASE + OMAP_UHH_HOSTCONFIG);
 
 	if ((omap->port_mode[0] == EHCI_HCD_OMAP_MODE_TLL) ||
 		(omap->port_mode[1] == EHCI_HCD_OMAP_MODE_TLL) ||
