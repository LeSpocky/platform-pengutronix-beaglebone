From d8b67830c302eb2cf3d396f1828534850f136771 Mon Sep 17 00:00:00 2001
From: Jan Luebbe <jlu@pengutronix.de>
Date: Sun, 14 Jul 2013 19:25:39 +0200
Subject: [PATCH 17/17] beaglebone: add support for beaglebone black with DDR3
 RAM

Also allow configuration of the DDR PLL from board code

Signed-off-by: Jan Luebbe <jlu@pengutronix.de>
---
 arch/arm/boards/beaglebone/Makefile              |    2 +-
 arch/arm/boards/beaglebone/board.c               |   47 ++++++-
 arch/arm/boards/beaglebone/ddr.h                 |    1 +
 arch/arm/boards/beaglebone/ddr3.c                |  155 ++++++++++++++++++++++
 arch/arm/boards/beaglebone/lowlevel.c            |   11 +-
 arch/arm/mach-omap/am33xx_clock.c                |    9 +-
 arch/arm/mach-omap/include/mach/am33xx-clock.h   |    5 +-
 arch/arm/mach-omap/include/mach/am33xx-devices.h |    6 +
 8 files changed, 222 insertions(+), 14 deletions(-)
 create mode 100644 arch/arm/boards/beaglebone/ddr3.c

diff --git a/arch/arm/boards/beaglebone/Makefile b/arch/arm/boards/beaglebone/Makefile
index 7ec0c8b..eb2ffec 100644
--- a/arch/arm/boards/beaglebone/Makefile
+++ b/arch/arm/boards/beaglebone/Makefile
@@ -1,2 +1,2 @@
-lwl-y += lowlevel.o ddr2.o
+lwl-y += lowlevel.o ddr2.o ddr3.o
 obj-y += board.o
diff --git a/arch/arm/boards/beaglebone/board.c b/arch/arm/boards/beaglebone/board.c
index ccb7004..a01fe1b 100644
--- a/arch/arm/boards/beaglebone/board.c
+++ b/arch/arm/boards/beaglebone/board.c
@@ -26,6 +26,8 @@
 #include <init.h>
 #include <driver.h>
 #include <envfs.h>
+#include <environment.h>
+#include <globalvar.h>
 #include <sizes.h>
 #include <io.h>
 #include <ns16550.h>
@@ -68,7 +70,11 @@ console_initcall(beaglebone_console_init);
 
 static int beaglebone_mem_init(void)
 {
-	omap_add_ram0(SZ_256M);
+	if (get_cpu_rev() == AM335X_ES1_0) { /* white */
+		omap_add_ram0(SZ_256M);
+	} else { /* black */
+		omap_add_ram0(SZ_512M);
+	}
 
 	return 0;
 }
@@ -103,19 +109,56 @@ static struct i2c_board_info i2c0_devices[] = {
 	},
 };
 
+static const __maybe_unused struct module_pin_mux mmc1_pin_mux[] = {
+	{OFFSET(gpmc_ad0), (MODE(1) | RXACTIVE)},	/* MMC1_DAT0 */
+	{OFFSET(gpmc_ad1), (MODE(1) | RXACTIVE)},	/* MMC1_DAT1 */
+	{OFFSET(gpmc_ad2), (MODE(1) | RXACTIVE)},	/* MMC1_DAT2 */
+	{OFFSET(gpmc_ad3), (MODE(1) | RXACTIVE)},	/* MMC1_DAT3 */
+	{OFFSET(gpmc_ad4), (MODE(1) | RXACTIVE)},	/* MMC1_DAT4 */
+	{OFFSET(gpmc_ad5), (MODE(1) | RXACTIVE)},	/* MMC1_DAT5 */
+	{OFFSET(gpmc_ad6), (MODE(1) | RXACTIVE)},	/* MMC1_DAT6 */
+	{OFFSET(gpmc_ad7), (MODE(1) | RXACTIVE)},	/* MMC1_DAT7 */
+	{OFFSET(gpmc_csn1), (MODE(2) | RXACTIVE | PULLUP_EN)},	/* MMC1_CLK */
+	{OFFSET(gpmc_csn2), (MODE(2) | RXACTIVE | PULLUP_EN)},	/* MMC1_CMD */
+	{-1},
+};
+
 static int beaglebone_devices_init(void)
 {
+	bool black = get_cpu_rev() != AM335X_ES1_0;
+
+	am33xx_enable_mmc0_pin_mux();
 	am33xx_add_mmc0(NULL);
 
+	if (black) {
+		configure_module_pin_mux(mmc1_pin_mux);
+		am33xx_add_mmc1(NULL);
+	}
+
 	am33xx_enable_i2c0_pin_mux();
 	i2c_register_board_info(0, i2c0_devices, ARRAY_SIZE(i2c0_devices));
 	am33xx_add_i2c0(NULL);
 
 	beaglebone_eth_init();
 
+	return 0;
+}
+device_initcall(beaglebone_devices_init);
+
+static int beaglebone_env_init(void)
+{
+	bool black = get_cpu_rev() != AM335X_ES1_0;
+
+#if defined(CONFIG_GLOBALVAR)
+	globalvar_add_simple("board.variant");
+	setenv("global.board.variant", black ? "boneblack" : "bone");
+#endif
+
+	printf("detected 'BeageBone %s'\n", black ? "Black" : "White");
+
 	armlinux_set_bootparams((void *)0x80000100);
 	armlinux_set_architecture(MACH_TYPE_BEAGLEBONE);
 
 	return 0;
 }
-device_initcall(beaglebone_devices_init);
+late_initcall(beaglebone_env_init);
diff --git a/arch/arm/boards/beaglebone/ddr.h b/arch/arm/boards/beaglebone/ddr.h
index d2f0c95..46c2504 100644
--- a/arch/arm/boards/beaglebone/ddr.h
+++ b/arch/arm/boards/beaglebone/ddr.h
@@ -1 +1,2 @@
 void beaglebone_config_ddr2(void);
+void beaglebone_config_ddr3(void);
diff --git a/arch/arm/boards/beaglebone/ddr3.c b/arch/arm/boards/beaglebone/ddr3.c
new file mode 100644
index 0000000..643a94d
--- /dev/null
+++ b/arch/arm/boards/beaglebone/ddr3.c
@@ -0,0 +1,155 @@
+#include <init.h>
+#include <sizes.h>
+#include <io.h>
+#include <asm/armlinux.h>
+#include <asm/barebox-arm-head.h>
+#include <asm/barebox-arm.h>
+#include <mach/am33xx-silicon.h>
+#include <mach/am33xx-clock.h>
+
+/* AM335X EMIF Register values */
+#define EMIF_SDMGT		0x80000000
+#define EMIF_SDRAM		0x00004650
+#define EMIF_PHYCFG		0x2
+#define DDR_PHY_RESET		(0x1 << 10)
+#define DDR_FUNCTIONAL_MODE_EN	0x1
+#define DDR_PHY_READY		(0x1 << 2)
+#define	VTP_CTRL_READY		(0x1 << 5)
+#define VTP_CTRL_ENABLE		(0x1 << 6)
+#define VTP_CTRL_LOCK_EN	(0x1 << 4)
+#define VTP_CTRL_START_EN	(0x1)
+#define DDR2_RATIO		0x80	/* for mDDR */
+#define CMD_FORCE		0x00	/* common #def */
+#define CMD_DELAY		0x00
+
+#define EMIF_READ_LATENCY	0x100007
+#define EMIF_TIM1		0x0AAAD4DB
+#define EMIF_TIM2		0x266B7FDA
+#define	EMIF_TIM3		0x501F867F
+#define EMIF_SDCFG		0x61C05332
+#define EMIF_SDREF		0xC30
+#define ZQ_CFG			0x50074BE4
+#define DDR2_DLL_LOCK_DIFF	0x1
+#define DDR2_RD_DQS		0x38
+#define	DDR2_WR_DQS		0x44
+#define DDR2_PHY_FIFO_WE	0x94
+#define	DDR2_PHY_WR_DATA	0x7D
+
+#define	DDR2_INVERT_CLKOUT	0x0
+#define	PHY_RANK0_DELAY		0x01
+#define PHY_DLL_LOCK_DIFF	0x0
+#define DDR_IOCTRL_VALUE	0x18B
+
+static void beaglebone_data_macro_config_ddr3(int dataMacroNum)
+{
+	u32 BaseAddrOffset = 0x00;
+
+	if (dataMacroNum == 1)
+		BaseAddrOffset = 0xA4;
+
+	__raw_writel(DDR2_RD_DQS,
+		(AM33XX_DATA0_RD_DQS_SLAVE_RATIO_0 + BaseAddrOffset));
+	__raw_writel(DDR2_WR_DQS,
+		(AM33XX_DATA0_WR_DQS_SLAVE_RATIO_0 + BaseAddrOffset));
+	__raw_writel(DDR2_PHY_FIFO_WE,
+		(AM33XX_DATA0_FIFO_WE_SLAVE_RATIO_0 + BaseAddrOffset));
+	__raw_writel(DDR2_PHY_WR_DATA,
+		(AM33XX_DATA0_WR_DATA_SLAVE_RATIO_0 + BaseAddrOffset));
+	__raw_writel(PHY_DLL_LOCK_DIFF,
+		(AM33XX_DATA0_DLL_LOCK_DIFF_0 + BaseAddrOffset));
+}
+
+static void beaglebone_cmd_macro_config_ddr3(void)
+{
+	__raw_writel(DDR2_RATIO, AM33XX_CMD0_CTRL_SLAVE_RATIO_0);
+	__raw_writel(CMD_FORCE, AM33XX_CMD0_CTRL_SLAVE_FORCE_0);
+	__raw_writel(CMD_DELAY, AM33XX_CMD0_CTRL_SLAVE_DELAY_0);
+	__raw_writel(DDR2_DLL_LOCK_DIFF, AM33XX_CMD0_DLL_LOCK_DIFF_0);
+	__raw_writel(DDR2_INVERT_CLKOUT, AM33XX_CMD0_INVERT_CLKOUT_0);
+
+	__raw_writel(DDR2_RATIO, AM33XX_CMD1_CTRL_SLAVE_RATIO_0);
+	__raw_writel(CMD_FORCE, AM33XX_CMD1_CTRL_SLAVE_FORCE_0);
+	__raw_writel(CMD_DELAY, AM33XX_CMD1_CTRL_SLAVE_DELAY_0);
+	__raw_writel(DDR2_DLL_LOCK_DIFF, AM33XX_CMD1_DLL_LOCK_DIFF_0);
+	__raw_writel(DDR2_INVERT_CLKOUT, AM33XX_CMD1_INVERT_CLKOUT_0);
+
+	__raw_writel(DDR2_RATIO, AM33XX_CMD2_CTRL_SLAVE_RATIO_0);
+	__raw_writel(CMD_FORCE, AM33XX_CMD2_CTRL_SLAVE_FORCE_0);
+	__raw_writel(CMD_DELAY, AM33XX_CMD2_CTRL_SLAVE_DELAY_0);
+	__raw_writel(DDR2_DLL_LOCK_DIFF, AM33XX_CMD2_DLL_LOCK_DIFF_0);
+	__raw_writel(DDR2_INVERT_CLKOUT, AM33XX_CMD2_INVERT_CLKOUT_0);
+}
+
+static void beaglebone_config_vtp_ddr3(void)
+{
+	__raw_writel(__raw_readl(AM33XX_VTP0_CTRL_REG) | VTP_CTRL_ENABLE,
+		AM33XX_VTP0_CTRL_REG);
+	__raw_writel(__raw_readl(AM33XX_VTP0_CTRL_REG) & (~VTP_CTRL_START_EN),
+		AM33XX_VTP0_CTRL_REG);
+	__raw_writel(__raw_readl(AM33XX_VTP0_CTRL_REG) | VTP_CTRL_START_EN,
+		AM33XX_VTP0_CTRL_REG);
+
+	/* Poll for READY */
+	while ((__raw_readl(AM33XX_VTP0_CTRL_REG) & VTP_CTRL_READY) != VTP_CTRL_READY);
+}
+
+static void beaglebone_config_emif_ddr3(void)
+{
+	u32 i;
+
+	/*Program EMIF0 CFG Registers*/
+	__raw_writel(EMIF_READ_LATENCY, AM33XX_EMIF4_0_REG(DDR_PHY_CTRL_1));
+	__raw_writel(EMIF_READ_LATENCY, AM33XX_EMIF4_0_REG(DDR_PHY_CTRL_1_SHADOW));
+	__raw_writel(EMIF_READ_LATENCY, AM33XX_EMIF4_0_REG(DDR_PHY_CTRL_2));
+	__raw_writel(EMIF_TIM1, AM33XX_EMIF4_0_REG(SDRAM_TIM_1));
+	__raw_writel(EMIF_TIM1, AM33XX_EMIF4_0_REG(SDRAM_TIM_1_SHADOW));
+	__raw_writel(EMIF_TIM2, AM33XX_EMIF4_0_REG(SDRAM_TIM_2));
+	__raw_writel(EMIF_TIM2, AM33XX_EMIF4_0_REG(SDRAM_TIM_2_SHADOW));
+	__raw_writel(EMIF_TIM3, AM33XX_EMIF4_0_REG(SDRAM_TIM_3));
+	__raw_writel(EMIF_TIM3, AM33XX_EMIF4_0_REG(SDRAM_TIM_3_SHADOW));
+
+	__raw_writel(EMIF_SDCFG, AM33XX_EMIF4_0_REG(SDRAM_CONFIG));
+	__raw_writel(EMIF_SDCFG, AM33XX_EMIF4_0_REG(SDRAM_CONFIG2));
+
+	/* __raw_writel(EMIF_SDMGT, EMIF0_0_SDRAM_MGMT_CTRL);
+	__raw_writel(EMIF_SDMGT, EMIF0_0_SDRAM_MGMT_CTRL_SHD); */
+	__raw_writel(EMIF_SDREF, AM33XX_EMIF4_0_REG(SDRAM_REF_CTRL));
+	__raw_writel(EMIF_SDREF, AM33XX_EMIF4_0_REG(SDRAM_REF_CTRL_SHADOW));
+
+	for (i = 0; i < 5000; i++) {
+
+	}
+
+	/* __raw_writel(EMIF_SDMGT, EMIF0_0_SDRAM_MGMT_CTRL);
+	__raw_writel(EMIF_SDMGT, EMIF0_0_SDRAM_MGMT_CTRL_SHD); */
+	__raw_writel(EMIF_SDREF, AM33XX_EMIF4_0_REG(SDRAM_REF_CTRL));
+	__raw_writel(EMIF_SDREF, AM33XX_EMIF4_0_REG(SDRAM_REF_CTRL_SHADOW));
+
+	__raw_writel(EMIF_SDCFG, AM33XX_EMIF4_0_REG(SDRAM_CONFIG));
+	__raw_writel(EMIF_SDCFG, AM33XX_EMIF4_0_REG(SDRAM_CONFIG2));
+}
+
+void beaglebone_config_ddr3(void)
+{
+	enable_ddr_clocks();
+
+	beaglebone_config_vtp_ddr3();
+
+	beaglebone_cmd_macro_config_ddr3();
+	beaglebone_data_macro_config_ddr3(0);
+	beaglebone_data_macro_config_ddr3(1);
+
+	__raw_writel(PHY_RANK0_DELAY, AM33XX_DATA0_RANK0_DELAYS_0);
+	__raw_writel(PHY_RANK0_DELAY, AM33XX_DATA1_RANK0_DELAYS_0);
+
+	__raw_writel(DDR_IOCTRL_VALUE, AM33XX_DDR_CMD0_IOCTRL);
+	__raw_writel(DDR_IOCTRL_VALUE, AM33XX_DDR_CMD1_IOCTRL);
+	__raw_writel(DDR_IOCTRL_VALUE, AM33XX_DDR_CMD2_IOCTRL);
+	__raw_writel(DDR_IOCTRL_VALUE, AM33XX_DDR_DATA0_IOCTRL);
+	__raw_writel(DDR_IOCTRL_VALUE, AM33XX_DDR_DATA1_IOCTRL);
+
+	__raw_writel(__raw_readl(AM33XX_DDR_IO_CTRL) & 0xefffffff, AM33XX_DDR_IO_CTRL);
+	__raw_writel(__raw_readl(AM33XX_DDR_CKE_CTRL) | 0x00000001, AM33XX_DDR_CKE_CTRL);
+
+	beaglebone_config_emif_ddr3();
+}
diff --git a/arch/arm/boards/beaglebone/lowlevel.c b/arch/arm/boards/beaglebone/lowlevel.c
index 282b471..c1e11a1 100644
--- a/arch/arm/boards/beaglebone/lowlevel.c
+++ b/arch/arm/boards/beaglebone/lowlevel.c
@@ -31,10 +31,13 @@ void beaglebone_sram_init(void)
 	u32 regVal, uart_base;
 
 	/* Setup the PLLs and the clocks for the peripherals */
-	pll_init(MPUPLL_M_500);
-
-	if (get_cpu_rev() == AM335X_ES1_0)
+	if (get_cpu_rev() == AM335X_ES1_0) { /* white */
+		pll_init(MPUPLL_M_500, DDRPLL_M_266);
 		beaglebone_config_ddr2();
+	} else { /* black */
+		pll_init(MPUPLL_M_500, DDRPLL_M_400);
+		beaglebone_config_ddr3();
+	}
 
 	/* Enable pin mux */
 	am33xx_enable_uart0_pin_mux();
@@ -100,6 +103,6 @@ void __bare_init __naked barebox_arm_reset_vector(uint32_t *data)
 
 	beaglebone_board_init();
 
-	barebox_arm_entry(0x80000000, SZ_256M, 0);
+	barebox_arm_entry(0x80000000, SZ_256M, 0); /* real RAM setup comes later */
 	/* barebox_arm_entry(0x402F0400, 0x4030CE00-0x402F0400, 0); */ /* for SRAM */
 }
diff --git a/arch/arm/mach-omap/am33xx_clock.c b/arch/arm/mach-omap/am33xx_clock.c
index 9928e9f..e0ba197 100644
--- a/arch/arm/mach-omap/am33xx_clock.c
+++ b/arch/arm/mach-omap/am33xx_clock.c
@@ -248,7 +248,7 @@ static void per_pll_config(void)
 	while(__raw_readl(CM_IDLEST_DPLL_PER) != 0x1);
 }
 
-static void ddr_pll_config(void)
+static void ddr_pll_config(int ddrpll_M)
 {
 	u32 clkmode, clksel, div_m2;
 
@@ -263,7 +263,7 @@ static void ddr_pll_config(void)
 	while ((__raw_readl(CM_IDLEST_DPLL_DDR) & 0x00000100) != 0x00000100);
 
 	clksel = clksel & (~0x7ffff);
-	clksel = clksel | ((DDRPLL_M << 0x8) | DDRPLL_N);
+	clksel = clksel | ((ddrpll_M << 0x8) | DDRPLL_N);
 	__raw_writel(clksel, CM_CLKSEL_DPLL_DDR);
 
 	div_m2 = div_m2 & 0xFFFFFFE0;
@@ -288,18 +288,17 @@ void enable_ddr_clocks(void)
 		PRCM_L3_GCLK_ACTIVITY));
 	/* Poll if module is functional */
 	while ((__raw_readl(CM_PER_EMIF_CLKCTRL)) != PRCM_MOD_EN);
-
 }
 
 /*
  * Configure the PLL/PRCM for necessary peripherals
  */
-void pll_init(int mpupll_M)
+void pll_init(int mpupll_M, int ddrpll_M)
 {
 	mpu_pll_config(mpupll_M);
 	core_pll_config();
 	per_pll_config();
-	ddr_pll_config();
+	ddr_pll_config(ddrpll_M);
 	/* Enable the required interconnect clocks */
 	interface_clocks_enable();
 	/* Enable power domain transition */
diff --git a/arch/arm/mach-omap/include/mach/am33xx-clock.h b/arch/arm/mach-omap/include/mach/am33xx-clock.h
index 968509e..3f86d14 100644
--- a/arch/arm/mach-omap/include/mach/am33xx-clock.h
+++ b/arch/arm/mach-omap/include/mach/am33xx-clock.h
@@ -53,7 +53,8 @@
 
 /* DDR Freq is 266 MHZ for now*/
 /* Set Fdll = 400 MHZ , Fdll = M * 2 * CLKINP/ N + 1; clkout = Fdll /(2 * M2) */
-#define DDRPLL_M	266
+#define DDRPLL_M_266	266
+#define DDRPLL_M_400	400
 #define DDRPLL_N	(OSC - 1)
 #define DDRPLL_M2	1
 
@@ -187,7 +188,7 @@
 
 #define CM_ALWON_GPMC_CLKCTRL           CM_PER_GPMC_CLKCTRL
 
-extern void pll_init(int mpupll_M);
+extern void pll_init(int mpupll_M, int ddrpll_M);
 extern void enable_ddr_clocks(void);
 
 #endif  /* endif _AM33XX_CLOCKS_H_ */
diff --git a/arch/arm/mach-omap/include/mach/am33xx-devices.h b/arch/arm/mach-omap/include/mach/am33xx-devices.h
index edf8982..1d13d3d 100644
--- a/arch/arm/mach-omap/include/mach/am33xx-devices.h
+++ b/arch/arm/mach-omap/include/mach/am33xx-devices.h
@@ -31,6 +31,12 @@ static inline struct device_d *am33xx_add_mmc0(struct omap_hsmmc_platform_data *
 			AM33XX_MMCHS0_BASE, SZ_4K, IORESOURCE_MEM, pdata);
 }
 
+static inline struct device_d *am33xx_add_mmc1(struct omap_hsmmc_platform_data *pdata)
+{
+	return add_generic_device("omap4-hsmmc", 1, NULL,
+			AM33XX_MMC1_BASE, SZ_4K, IORESOURCE_MEM, pdata);
+}
+
 static inline struct device_d *am33xx_add_cpsw(struct cpsw_platform_data *cpsw_data)
 {
 	return add_generic_device("cpsw", 0, NULL,
-- 
1.7.10.4

